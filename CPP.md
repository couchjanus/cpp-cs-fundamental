# cpp-cs-fundamental

## Программа
Программа (приложение) — это набор инструкций, которые указывают компьютеру, что ему нужно делать. Физическая часть компьютера, которая выполняет эти инструкции, называется аппаратной частью.

## Машинный язык
Процессор компьютера не способен понимать напрямую языки программирования, такие как C++, Java, Python и т.д. Очень ограниченный набор инструкций, которые изначально понимает процессор, называется машинным кодом (или машинным языком).

Каждая команда (инструкция) состоит только из определенной последовательности (набора) цифр: 0 и 1. Эти числа называются битами (binary digit) или двоичным кодом.

Каждый набор бит переводится процессором в инструкции для выполнения определенного задания (например, сравнить два числа или переместить число в определенную ячейку памяти). Разные типы процессоров обычно имеют разные наборы инструкций, поэтому инструкции, которые будут работать на процессорах Intel, с большей долей вероятности, не будут работать на процессорах Xenon.

## Язык ассемблера

В этом языке каждая команда идентифицируется коротким именем (а не набором единиц с нулями), и переменными можно управлять через их имена. Таким образом, писать/читать код стало гораздо легче. Тем не менее, процессор все равно не понимает язык ассемблера напрямую. Его также нужно переводить, с помощью ассемблера, в машинный код. Ассемблер — это транслятор (переводчик), который переводит код, написанный на языке ассемблера, в машинный язык.

Преимуществом Ассемблера является его производительность (скорость выполнения) и он до сих пор используется, когда это имеет решающее значение. Тем не менее, причина подобного преимущества заключается в том, что программирование на этом языке адаптируется к конкретному процессору. Программы, адаптированные под один процессор, не будут работать с другим. Кроме того, чтобы программировать на Ассемблере, по-прежнему нужно знать очень много не очень читабельных инструкций для выполнения даже простого задания.

## Высокоуровневые языки программирования
Для решения проблем читабельности кода и чрезмерной сложности были разработаны высокоуровневые языки программирования. C, C++, Pascal, Java, JavaScript и Perl — это всё языки высокого уровня. Они позволяют писать и выполнять программы, не переживая о совместимости кода с разными архитектурами процессоров. Программы, написанные на языках высокого уровня, также должны быть переведены в машинный код перед выполнением. Есть два варианта:
 - компиляция, которая выполняется компилятором;
 - интерпретация, которая выполняется интерпретатором.

## Компилятор
Компилятор — это программа, которая читает код и создает автономную (способную работать независимо от другого аппаратного или программного обеспечения) исполняемую программу, которую процессор понимает напрямую. При запуске программы весь код компилируется целиком, а затем создается исполняемый файл и уже при повторном запуске программы компиляция не выполняется.

## Интерпретатор
Интерпретатор — это программа, которая напрямую выполняет код, без его предыдущей компиляции в исполняемый файл. Интерпретаторы более гибкие, но менее эффективные, так как процесс интерпретации выполняется повторно при каждом запуске программы.

## Процесс интерпретации: 

Любой язык программирования может быть компилируемым или интерпретируемым, однако, такие языки, как C, C++ и Pascal — компилируются, в то время как «скриптовые» языки, такие, как Perl и JavaScript — интерпретируются. Некоторые языки программирования (например, Java) могут как компилироваться, так и интерпретироваться.

## Преимущества высокоуровневых языков программирования

1. Легче писать/читать код. Вот вышеприведенная команда, но уже на языке C++:
```cpp
а = 97;
```
2. Требуется меньше инструкций для выполнения определенного задания. В языке C++ вы можете сделать что-то вроде а = Ь * 2 + 5; в одной строке. В языке ассемблера вам пришлось бы использовать 5 или 6 инструкций.

3. Вы не должны заботиться о таких деталях, как загрузка переменных в регистры процессора. Компилятор или интерпретатор берёт это на себя.

4. Высокоуровневые языки программирования более портируемые под различные архитектуры, многие платформы, такие как Microsoft Windows, имеют свои собственные специфические функции, с помощью которых писать код намного легче.

## C
Перед C++ был C. C был разработан в 1972 году Деннисом Ритчи в Bell Telephone Laboratories как системный язык программирования, т.е. язык для написания операционных систем. Основной задачей Ритчи было создание легко компилируемого минималистического языка, который предоставлял бы эффективный доступ к памяти, относительно быстро выполнялся, и на котором можно было бы писать эффективный код. Таким образом, при разработке высокоуровневого языка, был создан язык Си, который во многом относился к языкам низкого уровня, оставаясь при этом независимым от платформ, для которых мог быть написан код.

в 1973 году Ритчи и Кен Томпсон переписали больше половины операционной системы UNIX, используя этот язык. Многие предыдущие операционные системы были написаны на языке ассемблера. В отличие от Ассемблера, на котором пишутся программы под конкретные процессоры, высокая портируемость языка Cи позволила перекомпилировать UNIX и на другие типы компьютеров, ускоряя его популяризацию. Язык Cи и операционная система UNIX тесно связаны между собой, и популярность первого отчасти связана с успехом второго.

В 1978 году Брайан Керниган и Деннис Ритчи опубликовали книгу под названием «Язык программирования Cи». Эта книга, более известна как «K&R», стала стандартом и своеобразной инструкцией к Си. Когда требовалась максимальная портируемость, то программисты придерживались рекомендаций в «K&R», поскольку большинство компиляторов в то время были реализованы в соответствии со стандартами, присутствующими в этой книге.

В 1983 году Американский национальный институт стандартов (ANSI American National Standards Institute) сформировал комитет для утверждения официального стандарта языка Cи. В 1989 году они закончили и выпустили стандарт C89, более широко известный, как ANSI C. В 1990 году Международная организация по стандартизации (ISO International Organization for Standardization) приняла ANSI C. Эта версия языка Cи стала известна как C90. 

В 1999 году комитет ANSI выпустил новую версию языка Cи, которая получила название C99. Она приняла много особенностей, которые были реализованы в компиляторах (в виде различных расширений) или уже в языке C++.

## Язык C++
Язык программирования C++ был разработан Бьёрном Страуструпом в Bell Telephone Laboratories в качестве дополнения к Cи в 1979 г. Он добавил множество новых фич в язык Си. Его популярность была вызвана объектно-ориентированностью языка.

Язык C++ был ратифицирован комитетом ISO в 1998 году и потом снова в 2003 году (под названием C++03). Потом были следующие версии стандарта языка С++ (выпускаются раз в 3 года).

## Философия С и С++

Смысл философии языков С и C++ можно определить выражением доверять программисту. Например, компилятор не будет вам мешать сделать что-то новое, что имеет смысл, но также не будет мешать вам сделать что-то такое, что может привести к сбою. Это одна из главных причин, почему так важно знать то, что вы не должны делать, как и то, что вы должны делать, создавая программы на языках С/С++.

1.Определите проблему, которую хотели бы решить
Это шаг «Что?». Здесь вы должны понять, что же вы хотите, чтобы ваша программа делала. Этот шаг может быть, как самым простым, так и самым сложным. Всё, что вам нужно — это четко сформулировать идею. Только после этого вы сможете приступать к следующему шагу.

2. Определитесь, как вы собираетесь решить эту проблему

Каким образом можно решить проблему, обозначенную на шаге 1? Этим шагом довольно часто пренебрегают при разработке программного обеспечения. Суть в том, что способов решения задачи может быть много, только часть из них — хорошие решения, а часть — плохие. Вы должны научиться отделять первые от вторых. Очень часто можно наблюдать ситуацию, когда у программиста возникает идея и он сразу же садится программировать. 

Как правило, хорошие решения имеют следующие характеристики:
- простота;
- хорошая документация (с инструкциями и комментариями);
- модульный принцип: любая часть программы может быть повторно использована или изменена позже, не затрагивая другие части кода;
- надежность: соответствующая обработка ошибок и экстренных ситуаций.

Согласно закону Парето, программист тратит примерно 20% времени на написание программы и 80% времени на отладку (исправление ошибок) или поддержку (добавление новых функциональных возможностей) кода. Следовательно, лучше потратить дополнительное время на обдумывание лучшего способа решения проблемы перед процессом написания кода, нежели потом тратить оставшиеся 80% времени на поиск и исправление ошибок.

3. Напишите программу
Для того, чтобы написать программу, необходимы две вещи:
- знание выбранного вами языка программирования;
- редактор кода.

Программу можно написать, используя любой редактор, даже тот же Блокнот в Windows или текстовый редактор Vi в Unix.

Редактор типичного программиста, как правило, имеет следующие особенности, которые облегчают программирование:

   Нумерация строк. Это функция чрезвычайно полезна при отладке программ, когда компилятор выдаёт нам сообщения об ошибках. Типичная ошибка компиляции состоит из наименования ошибки и номера строки, где эта ошибка произошла (например, «ошибка переопределения переменной x, строка 90»). Без нумерации строк искать ту самую 90-ю строку кода было бы несколько затруднительно, не так ли?

   Подсветка синтаксиса. Подсветка синтаксиса изменяет цвет разных частей программы и кода, что улучшает восприятие как целой программы, так и её отдельных частей.

   Специальный шрифт. В обычных шрифтах очень часто возникает путаница между определенными символами, когда непонятно, какой символ перед вами. Например: цифра 0 или буква O, цифра 1 или буква l (нижний регистр L), или может буква I (верхний регистр i). Вот для этого и нужен специальный шрифт, в котором будет легко различить эти символы, предотвращая случайное использование одного символа вместо другого.

Программы на языке C++ следует называть name.cpp, где name заменяется именем вашей программы, а расширение .cpp сообщает компилятору, что это исходный файл кода, который содержит инструкции на языке программирования C++.

4. Компиляция

Для того, чтобы скомпилировать программу нам нужен компилятор. Работа компилятора состоит из двух частей:

   Проверка программы на соответствие правилам языка C++ (проверка синтаксиса). Если она будет неудачной, то компилятор выдаст сообщения об ошибках, которые нужно будет исправить.

   Конвертация каждого исходного файла с кодом в объектный файл (или «объектный модуль») на машинном языке. Объектные файлы, как правило, имеют названия name.o или name.obj, где name должно быть такое же как и имя вашего исходного .cpp-файла. Если ваша программа состоит из 3-х .cpp-файлов, то компилятор сгенерирует 3 объектных файла.

Linux и macOS имеют уже встроенный компилятор C++, который называется g++. 

5. Линкинг (связывание объектных файлов)
Линкинг — это процесс связывания всех объектных файлов, генерируемых компилятором, в единую исполняемую программу, которую вы затем сможете запустить/выполнить. Это делается с помощью программы, которая называется линкер (или компоновщик).

Кроме объектных файлов, линкер также подключает файлы из Стандартной библиотеки С++ (или любой другой библиотеки, которую вы используете, например, библиотеки графики или звука). Сам по себе язык С++ довольно маленький и простой. Тем не менее, к нему подключается большая библиотека дополнительных функций, которые могут использовать ваши программы, и эти функции находятся в Стандартной библиотеке C++. Например, если вы хотите вывести что-либо на экран, то у вас в коде должна быть специальная команда, которая сообщит компилятору, что вы хотите использовать функцию вывода информации на экран из Стандартной библиотеки C++.

После того, как компоновщик закончит линкинг всех объектных файлов, вы получите исполняемый файл. 

6. Тестирование и отладка

Для выполнения шагов 3-6 вам потребуется специальное программное обеспечение. Пакет программного обеспечения (IDE Integrated Development Environment) объединяет в себе все эти программы. Обычно с IDE вы получаете редактор кода с нумерацией строк и подсветкой синтаксиса, а также компилятор и линкер. А когда вам нужно будет провести отладку программы, вы сможете использовать встроенный отладчик. Кроме того, IDE объединяет и ряд других полезных возможностей: комплексная помощь, дополнение кода, в некоторых случаях еще и система контроля версий.

## Установка IDE (Интегрированной Среды Разработки)
Интегрированная среда разработки (IDE Integrated Development Environment) — это программное обеспечение, которое содержит всё необходимое для разработки, компиляции, линкинга и отладки кода. Нам нужно установить одну такую IDE для написания программ на языке С++.

IDE для пользователей Windows
Если вы пользователь Windows, то установите Visual Studio 2019 версию Community, которая является бесплатной (все остальные версии — платные):
https://visualstudio.microsoft.com/ru/downloads/

После того, как вы скачаете и запустите установщик, вам нужно будет выбрать "Разработка классических приложений на C++". Пункты, выбранные по умолчанию в правой части экрана, трогать не нужно, убедитесь, что поставлена галочка возле пункта "Пакет SDK для Windows 10". Затем нажимаем "Установить":

Для создания нового проекта в Visual Studio 2019, вам нужно сначала запустить эту IDE, затем выбрать "Файл" > "Создать" > "Проект":

Дальше появится диалоговое окно, где вам нужно будет выбрать "Консольное приложение Windows" из вкладки "Visual C++" и нажать "ОК":

В текстовом редакторе вы увидите, что уже есть некоторый текст и код — удалите его, а затем напечатайте или скопируйте следующий код:

```cpp


#include <iostream>
 
int main()
{
   std::cout << "Hello, world!" << std::endl;
   return 0;
}

```
Чтобы запустить программу в Visual Studio, нажмите комбинацию Ctrl+F5. 

Чтобы убрать строку «…завершает работу с кодом 0…», вам нужно перейти в "Отладка" > "Параметры":

Затем "Отладка" > "Общие" и поставить галочку возле "Автоматически закрыть консоль при остановке отладки" и нажать "ОК":

4. Скомпилировать проект.

5. Запустить проект.

# Режимы конфигурации «Debug» и «Release»

Конфигурация сборки (build configuration) — это набор настроек проекта, которые определяют принцип его построения. Конфигурация сборки состоит из:

- имени исполняемого файла;
- имени директории исполняемого файла;
- имён директорий, в которых IDE будет искать другой код и файлы библиотек;
- информации об отладке и параметрах оптимизации вашего проекта.

Интегрированная среда разработки имеет две конфигурации сборки: Debug (Отладка) и Release (Релиз).

   Конфигурация Debug предназначена для отладки вашей программы. Эта конфигурация отключает все настройки по оптимизации, включает информацию об отладке, что делает ваши программы больше и медленнее, но упрощает проведение отладки. Режим Debug обычно используется в качестве конфигурации по умолчанию.

   Конфигурация Release используется во время сборки программы для её дальнейшего выпуска. Программа оптимизируется по размеру и производительности и не содержит дополнительную информацию об отладке.

Переключение между режимами Debug и Release в Visual Studio

Самый простой способ изменить конфигурацию проекта — выбрать соответствующую из выпадающего списка на панели быстрого доступа



# Структура программ

Компьютерная программа — это последовательность инструкций, которые сообщают компьютеру, что ему нужно сделать.

## Стейтменты
Cтейтмент (statement) — это наиболее распространенный тип инструкций в программах. Стейтмент в программировании — это то же самое, что и предложение в языке. Мы пишем предложения, чтобы выразить какую-то идею. В языке C++ мы пишем стейтменты, чтобы выполнить какое-то задание. Все стейтменты в языке C++ заканчиваются точкой с запятой.

Есть много разных видов стейтментов в языке C++:
```cpp

int x;
x = 5;
std::cout << x;
```
int х — это стейтмент объявления (statement declaration). Он сообщает компилятору, что х является переменной. В программировании каждая переменная занимает определенное число адресуемых ячеек в памяти в зависимости от её типа. 
Минимальная адресуемая ячейка — байт. Переменная типа int может занимать до 4-х байт, т.е. до 4-х адресуемых ячеек памяти. Все переменные в программе должны быть объявлены, прежде чем использованы.

х = 5 — это стейтмент присваивания (assignment statement). Здесь мы присваиваем значение 5 переменной х.

std::cout << x; — это стейтмент вывода (output statement). Мы выводим значение переменной х на экран.

## Выражения

Компилятор также способен обрабатывать выражения. Выражение (expression) — это математический объект, который создается для проведения вычислений и нахождения соответствующего результата. Например, в математике выражение 2 + 3 имеет значение 5. Выражения в языке С++ могут содержать:
- отдельные цифры и числа (например, 2, 45);
- буквенные переменные (например, х, у);
- операторы, в т.ч. математические (например, +, -);
- функции.

Выражения могут состоять как из единичных символов — цифр или букв (например, 2 или х), так и из различных комбинаций этих символов с операторами (например, 2 + 3, 2 + х, х + у или (2 + х) * (y - 3)). 
```cpp

// корректный стейтмент присваивания 
х = 2 + 3;. 
// Здесь мы вычисляем результат сложения чисел 2 + 3, который затем присваиваем переменной х.
```
## Функции
В языке C++ стейтменты объединяются в блоки — функции. Функция — это последовательность стейтментов. 
Каждая программа, написанная на языке C++, должна содержать главную функцию main(). Именно с первого стейтмента, находящегося в функции main(), и начинается выполнение всей программы. 
Функции, как правило, выполняют конкретное задание. Например, функция max() может содержать стейтменты, которые определяют большее из заданных чисел, а функция calculateGrade() может вычислять среднюю оценку студента по какой-либо дисциплине.

Всегда размещайте функцию main() в файле .cpp с именем, совпадающим с именем проекта. Например, если вы пишете программу Chess, то поместите вашу функцию main() в файл chess.cpp.


## Библиотеки

Библиотека — это набор скомпилированного кода (например, функций), который был упакован для повторного использования в других программах. С помощью библиотек можно расширить возможности программ.

Язык C++ идет в комплекте со Стандартной библиотекой С++, которая предоставляет дополнительный функционал. Одной из наиболее часто используемых частей Стандартной библиотеки C++ является библиотека iostream, которая позволяет выводить данные на экран и обрабатывать пользовательский ввод.

### Пример программы «Hello, world!»:
```cpp


#include <iostream>
 
int main()
{
   std::cout << "Hello, world!";
   return 0;
}
```
Строка 1: Специальный тип инструкции, который называется директивой препроцессора. Директивы препроцессора сообщают компилятору, что ему нужно выполнить определенное задание. В этом случае мы говорим компилятору, что хотели бы подключить содержимое заголовочного файла <iostream> к нашей программе. Подключение заголовочного файла <iostream> дает нам возможность использовать функционал библиотеки iostream, что, в свою очередь, позволяет выводить нам данные на экран.

Строка 2: Пустое пространство, которое игнорируется компилятором.

Строка 3: Объявление главной функции main().

Строки 4 и 7: Указываем компилятору область функции main(). Всё, что находится между открывающей фигурной скобкой в строке 4 и закрывающей фигурной скобкой в строке 7 — считается содержимым функции main().

Строка №: Наш первый стейтмент (заканчивается точкой с запятой) — стейтмент вывода. std::cout — это специальный объект, используя который мы можем выводить данные на экран. << — это оператор вывода. Всё, что мы отправляем в std::cout, — выводится на экран. В этом случае, мы выводим текст "Hello, world!".

Строка 6: Оператор возврата return. Когда программа завершает свое выполнение, функция main() передает обратно в операционную систему значение, которое указывает на результат выполнения программы: успешно ли прошло выполнение программы или нет.

Если оператор return возвращает число 0, то это значит, что всё хорошо! Ненулевые возвращаемые значения указывают на то, что что-то пошло не так и выполнение программы было прервано.

## Синтаксис и синтаксические ошибки

Правила, которые регулируют построение предложений, называются синтаксисом.
Язык C++ также имеет свой синтаксис: правила написания кода/программ. При компиляции вашей программы, компилятор отвечает за то, чтобы ваша программа соответствовала правилам синтаксиса языка C++. Если вы нарушили правила, то компилятор будет ругаться и выдаст вам ошибку.

Например, посмотрим что произойдет, если мы не укажем в конце стейтмента точку с запятой:
```cpp


#include <iostream>
 
int main()
{
   std::cout << "Hello world!"
   return 0;
}
```
Результат:

E0065: требуется точка с запятой ";"
C2143: синтаксическая ошибка: отсутствие ";" перед "}"

Допущена синтаксическая ошибка в строке 6: мы забыли указать точку с запятой перед оператором return. В этом случае ошибка на самом деле в конце строки 5. В большинстве случаев компилятор правильно определяет строку с ошибкой, но есть ситуации, когда ошибка не заметна вплоть до начала следующей строки.

## Комментарии

Комментарий — это строка (или несколько строк) текста, которая вставляется в исходный код для объяснения того, что делает код. В языке C++ есть 2 типа комментариев: однострочные и многострочные.

## Однострочные комментарии
Однострочные комментарии — это комментарии, которые пишутся после символов //. Они пишутся в отдельных строках и всё, что находится после этих символов комментирования, — игнорируется компилятором, например:
```cpp


std::cout << «Hello, world!» << std::endl; // всё, что находится справа от двойного слеша, - игнорируется компилятором
```
Как правило, однострочные комментарии используются для объяснения одной строчки кода:
```cpp


std::cout << «Hello, world!» << std::endl; // cout и endl находятся в библиотеке iostream
std::cout << «It is so exciting!» << std::endl; // эти комментарии усложняют чтение кода
std::cout << «Yeah!» << std::endl; // особенно, когда строки разной длины
```
Размещая комментарии справа от кода, мы затрудняем себе как чтение кода, так и чтение комментариев. Следовательно, однострочные комментарии лучше размещать над строками кода:
```cpp


// cout и endl находятся в библиотеке iostream
std::cout << «Hello, world!» << std::endl;

// теперь уже легче читать
std::cout << «It is so exciting!» << std::endl;

// не так ли?
std::cout << «Yeah!» << std::endl;
```
## Многострочные комментарии

Многострочные комментарии — это комментарии, которые пишутся между символами 
```cpp
/* */
```
 Всё, что находится между звёздочками, — игнорируется компилятором:
```cpp


/* Это многострочный комментарий.
Эта строка игнорируется
и эта тоже. */
```
Так как всё, что находится между звёздочками, — игнорируется, то иногда вы можете наблюдать следующее:
```cpp


/* Это многострочный комментарий.
* Звёздочки слева
* упрощают чтение текста
*/
```
Многострочные комментарии не могут быть вложенными (т.е. одни комментарии внутри других):
```cpp


/* Это многострочный /* комментарий */ а это уже не комментарий */
// Верхний комментарий заканчивается перед первым */, а не перед вторым */
```
Правило: Никогда не используйте вложенные комментарии.

Как правильно писать комментарии?
Во-первых, на уровне библиотек/программ/функций комментарии отвечают на вопрос «ЧТО?»: «Что делают эти библиотеки/программы/функции?». Например:
```cpp


// Эта программа вычисляет оценку студента за семестр на основе его оценок за модули

// Эта функция использует метод Ньютона для вычисления корня функции
 
// Следующий код генерирует случайное число
```
Все эти комментарии позволяют понять, что делает программа, без необходимости смотреть на исходный код. Это особенно важно специалистам, работающим в команде, где не каждый специалист будет знаком со всем имеющимся кодом.

Во-вторых, внутри библиотек/программ/функций комментарии отвечают на вопрос «КАК?»: «Как код выполняет задание?». Например:
```cpp


/* Для расчета итоговой оценки ученика, мы складываем все его оценки за уроки и домашние задания,
   а затем делим получившееся число на общее количество оценок. 
   Таким образом, мы получаем средний балл ученика. */

// Или:

// Чтобы получить рандомный (случайный) элемент, мы выполняем следующее:

// 1) Составляем список всех элементов.
// 2) Вычисляем среднее значение для каждого элемента, исходя из его веса, цвета и цены.
// 3) Выбираем любое число.
// 4) Определяем соответствие элемента случайно выбранному числу.
// 5) Возвращаем случайный элемент.
```
Эти комментарии позволяют читателю понять, каким образом код выполняет поставленное ему задание.

В-третьих, на уровне стейтментов (однострочного кода) комментарии отвечают на вопрос ПОЧЕМУ?: «Почему код выполняет задание именно так, а не иначе?». Плохой комментарий на уровне стейтментов объясняет, что делает код. Если вы когда-нибудь писали код, который был настолько сложным, что нужен был комментарий, который бы объяснял, что он делает, то вам нужно было бы не писать комментарий, а переписывать этот код.
 
Примеры плохих и хороших однострочных комментариев:

   Плохой комментарий:
```cpp
// Присваиваем переменной sight значение 0
sight = 0;
```
   Хороший комментарий:
```cpp
// Игрок выпил зелье слепоты и ничего не видит
sight = 0;

```
   Плохой комментарий:
```cpp
// Рассчитываем стоимость элементов
cost = items / 2 * storePrice;

```

   Хороший комментарий:
```cpp

// Нам нужно разделить все элементы на 2, потому что они куплены по парам
cost = items / 2 * storePrice;

```

   Хорошие комментарии:
```cpp


// Мы решили использовать список вместо массива,
// потому что массивы осуществляют медленную вставку.

Или:

// Мы используем метод Ньютона для вычисления корня функции, 
// так как другого детерминистического способа решения этой задачи - нет.
```
И, наконец, комментарии нужно писать так, чтобы человек, который не имеет ни малейшего представления о том, что делает ваш код — смог в нем разобраться.
Подытожим:

Закомментировать код — это конвертировать одну или несколько строк кода в комментарии. Таким образом, вы можете (временно) исключить часть кода из компиляции.

Чтобы закомментировать одну строку кода, используйте однострочные символы комментирования //.
```cpp


Не закомментировано:

std::cout << 1;

Закомментировано:

//    std::cout << 1;

Чтобы закомментировать блок кода, используйте однострочные символы комментирования // на каждой строке или символы многострочного комментария /* */.

Не закомментировано:

std::cout << 1;
std::cout << 2;
std::cout << 3;

Закомментировано символами однострочного комментария:

//    std::cout << 1;
//    std::cout << 2;
//    std::cout << 3;

Закомментировано символами многострочного комментария:

/*
     std::cout << 1;
     std::cout << 2;
     std::cout << 3;
*/
```

## Переменные, Инициализация и Присваивание

Программируя на языке C++, мы создаем, обрабатываем и уничтожаем объекты. Объект — это часть памяти, которая может хранить значение. В качестве аналогии мы можем использовать почтовый ящик, куда мы помещаем информацию и откуда её извлекаем. Все компьютеры имеют оперативную память, которую используют программы. При создании объекта, часть оперативной памяти выделяется для этого объекта. Большинство объектов в языке C++ являются переменными.

## Переменные
Cтейтмент a = 8; выглядит довольно простым: мы присваиваем значение 8 переменной a. Но что такое a? a — это переменная, объект с именем.

Целое число — это число, которое можно записать без дроби, например: -11, -2, 0, 5 или 34.

Для создания переменной используется стейтмент объявления. Вот пример объявления целочисленной переменной a (которая может содержать только целые числа):

int a;

При выполнении этой инструкции центральным процессором часть оперативной памяти выделяется под этот объект. Например, предположим, что переменной a присваивается ячейка памяти под номером 150. Когда программа видит переменную a в выражении или в стейтменте, то она понимает, что для того, чтобы получить значение этой переменной, нужно заглянуть в ячейку памяти под номером 150.

Одной из наиболее распространенных операций с переменными является операция присваивания, например:

a = 8;

Когда процессор выполняет эту инструкцию, он понимает её как «поместить значение 8 в ячейку памяти под номером 150».

Затем мы сможем вывести это значение на экран с помощью std::cout:
```cpp


std::cout << a; // выводим значение переменной a (ячейка памяти под номером 150) на экран
```
## l-values и r-values

В C++ все переменные являются l-values. l-value — это значение, которое имеет свой собственный адрес в памяти. Поскольку все переменные имеют адреса, то они все являются l-values (например, переменные a, b, c — все они являются l-values). l от слова «left», так как только значения l-values могут находиться в левой стороне в операциях присваивания (в противном случае, мы получим ошибку). Например, стейтмент 9 = 10; вызовет ошибку компилятора, так как 9 не является l-value. Число 9 не имеет своего адреса в памяти и, таким образом, мы ничего не можем ему присвоить (9 = 9 и ничего здесь не изменить).

Противоположностью l-value является r-value. r-value — это значение, которое не имеет постоянного адреса в памяти. Примерами могут быть единичные числа (например, 7, которое имеет значение 7) или выражения (например, 3 + х, которое имеет значение х плюс 3).

Вот несколько примеров операций присваивания с использованием r-values:
```cpp


int a;      // объявляем целочисленную переменную a
a = 5;      // 5 имеет значение 5, которое затем присваивается переменной а
a = 4 + 6;  // 4 + 6 имеет значение 10, которое затем присваивается переменной а

int b;      // объявляем целочисленную переменную b
b = a;      // a имеет значение 10 (исходя из предыдущих операций), которое затем присваивается переменной b
b = b;      // b имеет значение 10, которое затем присваивается переменной b (ничего не происходит)
b = b + 2;  // b + 2 имеет значение 12, которое затем присваивается переменной b

// Здесь переменная b используется в двух различных контекстах. Слева b используется как l-value (переменная с адресом в памяти), а справа b используется как r-value и имеет отдельное значение (в данном случае, 12). При выполнении этого стейтмента, компилятор видит следующее:

b = 10 + 2;
```

в левой стороне операции присваивания всегда должно находиться l-value (которое имеет свой собственный адрес в памяти), а в правой стороне операции присваивания — r-value (которое имеет какое-то значение).

## Инициализация vs. Присваивание
В языке C++ есть две похожие концепции, которые новички часто путают: присваивание и инициализация.

После объявления переменной, ей можно присвоить значение с помощью оператора присваивания (знак равенства =):
```cpp


int a; // это объявление переменной
a = 8; // а это присваивание переменной a значения 8
```
В языке C++ вы можете объявить переменную и присвоить ей значение одновременно. Это называется инициализацией (или «определением»).
```cpp


int a = 8; // инициализируем переменную a значением 8
```
Переменная может быть инициализирована только после операции объявления.

Хотя эти два понятия близки по своей сути и часто могут использоваться для достижения одних и тех же целей, все же в некоторых случаях следует использовать инициализацию, вместо присваивания, а в некоторых — присваивание вместо инициализации.

Если у вас изначально имеется значение для переменной, то используйте инициализацию, вместо присваивания.

## Неинициализированные переменные

В отличие от других языков программирования, языки Cи и C++ не инициализируют переменные определенными значениями (например, нулем) по умолчанию. Поэтому, при создании переменной, ей присваивается ячейка в памяти, в которой уже может находиться какой-нибудь мусор! Переменная без значения называется неинициализированной переменной.

Использование неинициализированных переменных может привести к ошибкам, например:
```cpp


#include <iostream>

int main()
{
    // Объявляем целочисленную переменную a
    int a;

    // Выводим значение переменной a на экран (a - это неинициализированная переменная)
    std::cout << a;

    return 0;
}
```
В этом случае компилятор присваивает переменной a ячейку в памяти, которая в данный момент свободна (не используется). Затем значение переменной a отправляется на вывод. Но что мы увидим на экране? Ничего, так как компилятор это не пропустит — выведется ошибка, что переменная a является неинициализированной.

Использование неинициализированных переменных является одной из самых распространенных ошибок начинающих программистов, но большинство современных компиляторов выдадут ошибку во время компиляции, если обнаружат неинициализированную переменную.

Хорошей практикой считается всегда инициализировать свои переменные. Это будет гарантией того, что ваша переменная всегда имеет определенное значение и вы не получите ошибку от компилятора.

Убедитесь, что все ваши переменные в программе имеют значения (либо через инициализацию, либо через операцию присваивания).

## Тест
Какой результат выполнения следующих стейтментов?
```cpp

int a = 6;
a = a - 3;
std::cout << a << std::endl; // №1
 
int b = a;
std::cout << b << std::endl; // №2
 
// В этом случае a + b является r-value 
std::cout << a + b << std::endl; // №3
 
std::cout << a << std::endl; // №4
 
int c;
std::cout << c << std::endl; // №5
```


## cout, cin и endl

Объект std::cout (который находится в библиотеке iostream) используется для вывода данных на экран (в консольное окно):
```cpp


#include <iostream>
 
int main()
{
    std::cout << "Hello, world!";
    return 0;
}
```
Для вывода нескольких предложений на одной строке оператор вывода << нужно использовать несколько раз, например:
```cpp


#include <iostream>

int main()
{
   int a = 7;
   std::cout << "a is " << a;
   return 0;
}
```
Программа выведет:

a is 7

А какой результат выполнения следующей программы?
```cpp


#include <iostream>

int main()
{
   std::cout << "Hi!";
   std::cout << "My name is Anton.";
   return 0;
}
```

## Объект std::endl

Если текст нужно вывести раздельно (на нескольких строках) — используйте std::endl. При использовании с std::cout, std::endl вставляет символ новой строки. Таким образом, мы перемещаемся к началу следующей строки, например:
```cpp


#include <iostream>

int main()
{
   std::cout << "Hi!" << std::endl;
   std::cout << "My name is Anton." << std::endl;
   return 0;
}
```

## Объект std::cin
std::cin является противоположностью std::cout. В то время как std::cout выводит данные в консоль с помощью оператора вывода <<, std::cin получает данные от пользователя с помощью оператора ввода >>. Используя std::cin мы можем получать и обрабатывать пользовательский ввод:
```cpp


#include <iostream>

int main()
{
   std::cout << "Enter a number: "; // просим пользователя ввести любое число
   int a = 0;
   std::cin >> a; // получаем пользовательское число и сохраняем его в переменную a
   std::cout << "You entered " << a << std::endl;
   return 0;
}
```
Попробуйте скомпилировать и запустить эту программу. При запуске вы увидите Enter a number:, а затем программа будет ждать, пока вы укажите число. Как только вы это сделаете и нажмете Enter, программа выведет You entered, а затем ваше число.

Если же ввести действительно большое число, то вы получите переполнение, так как переменная а может содержать числа только определенного размера/диапазона. Если число больше/меньше допустимых максимумов/минимумов, то происходит переполнение.

## std::cin, std::cout, << и >>

std::cin с std::cout и << с >> различия:

- std::cin и std::cout всегда находятся в левой стороне стейтмента;
- std::cout используется для вывода значения (cOUT = вывод);
- std::cin используется для получения значения (cIN = ввод);
- оператор вывода << используется с std::cout и показывает направление, в котором данные движутся от r-value в консоль. std::cout << 7; (значение 7 перемещается в консоль);
- оператор ввода >> используется с std::cin и показывает направление, в котором данные движутся из консоли в переменную. std::cin >> a; (значение из консоли перемещается в переменную a).

## Функции и оператор возврата return

Функция — это последовательность стейтментов для выполнения определенного задания. Часто ваши программы будут прерывать выполнение одних функций ради выполнения других. Иногда, когда программа выполняет код, она может столкнуться с вызовом функции. Вызов функции — это выражение, которое указывает процессору прервать выполнение текущей функции и приступить к выполнению другой функции. Процессор оставляет закладку в текущей точке выполнения, а затем выполняет вызываемую функцию. Когда выполнение вызываемой функции завершено, процессор возвращается к закладке и возобновляет выполнение прерванной функции.

Функция, в которой находится вызов, называется caller, а функция, которую вызывают — вызываемая функция, например:
```cpp


#include <iostream> // для std::cout и std::endl

// Объявление функции doPrint(), которую мы будем вызывать
void doPrint() {
   std::cout << "In doPrint()" << std::endl;
}

// Объявление функции main()
int main()
{
   std::cout << "Starting main()" << std::endl;
   doPrint(); // прерываем выполнение функции main() вызовом функции doPrint(). Функция main() в данном случае является caller-ом
   std::cout << "Ending main()" << std::endl;
   return 0;
}
```

Эта программа начинает выполнение с первой строки функции main(), где выводится на экран следующая строка: Starting main(). Вторая строка функции main() вызывает функцию doPrint(). На этом этапе выполнение стейтментов в функции main() приостанавливается и процессор переходит к выполнению стейтментов внутри функции doPrint(). Первая (и единственная) строка в doPrint() выводит текст In doPrint(). Когда процессор завершает выполнение doPrint(), он возвращается обратно в main() к той точке, на которой остановился. Следовательно, следующим стейтментом является вывод строки Ending main().

Обратите внимание, для вызова функции нужно указать её имя и список параметров в круглых скобках (). В примере, приведенном выше, параметры не используются, поэтому круглые скобки пусты.

Не забывайте указывать круглые скобки () при вызове функций.

## Возвращаемые значения

Когда функция main() завершает свое выполнение, она возвращает целочисленное значение обратно в операционную систему, используя оператор return.

Функции, которые мы пишем, также могут возвращать значения. Для этого нужно указать тип возвращаемого значения. Он указывается при объявлении функции, перед её именем. Обратите внимание, тип возврата не указывает, какое именно значение будет возвращаться. Он указывает только тип этого значения.

Затем, внутри вызываемой функции, мы используем оператор return, чтобы указать возвращаемое значение — какое именно значение будет возвращаться обратно в caller.

Рассмотрим простую функцию, которая возвращает целочисленное значение:
```cpp


#include <iostream>

// int означает, что функция возвращает целочисленное значение обратно в caller
int return7()
{
    // Эта функция возвращает целочисленное значение, поэтому мы должны использовать оператор return
    return 7; // возвращаем число 7 обратно в caller
}
 
int main()
{
    std::cout << return7() << std::endl; // выведется 7
    std::cout << return7() + 3 << std::endl; // выведется 10
 
    return7(); // возвращаемое значение 7 игнорируется, так как функция main() ничего с ним не делает
 
    return 0;
}
```

Разберемся детально:

   Первый вызов функции return7() возвращает 7 обратно в caller, которое затем передается в std::cout для вывода.

   Второй вызов функции return7() опять возвращает 7 обратно в caller. Выражение 7 + 3 имеет результат 10, который затем выводится на экран.

   Третий вызов функции return7() опять возвращает 7 обратно в caller. Однако функция main() ничего с ним не делает, поэтому ничего и не происходит (возвращаемое значение игнорируется).

Возвращаемые значения не выводятся на экран, если их не передать объекту std::cout. В последнем вызове функции return7() значение не отправляется в std::cout, поэтому ничего и не происходит.


## Тип возврата void
Функции могут и не возвращать значения. Чтобы сообщить компилятору, что функция не возвращает значение, нужно использовать тип возврата void:
```cpp


void doPrint() // void - это тип возврата
{
    std::cout << "In doPrint()" << std::endl;
    // Эта функция не возвращает никакого значения, поэтому оператор return здесь не нужен
}
```
Эта функция имеет тип возврата void, который означает, что функция не возвращает значения. Поскольку значение не возвращается, то и оператор return не требуется.

Вот еще один пример использования функции типа void:
```cpp


#include <iostream>

// void означает, что функция не возвращает значения
void returnNothing()
{
    std::cout << "Hi!" << std::endl;
    // Эта функция не возвращает никакого значения, поэтому оператор return здесь не нужен
}
 
int main()
{
    returnNothing(); // функция returnNothing() вызывается, но обратно в main() ничего не возвращает
 
    std::cout << returnNothing(); // ошибка, эта строчка не скомпилируется. Вам нужно будет её закомментировать
    return 0;
}
```
В первом вызове функции returnNothing() выводится Hi!, но ничего не возвращается обратно в caller. Точка выполнения возвращается обратно в функцию main(), где программа продолжает свое выполнение.

Второй вызов функции returnNothing() даже не скомпилируется. Функция returnNothing() имеет тип возврата void, который означает, что эта функция не возвращает значения. Однако функция main() пытается отправить это значение (которое не возвращается) в std::cout для вывода. std::cout не может обработать этот случай, так как значения на вывод не предоставлено. Следовательно, компилятор выдаст ошибку. Вам нужно будет закомментировать эту строку, чтобы компиляция прошла успешно.

## Возврат значений функцией main()

Как работает функция main(). Когда программа выполняется, операционная система делает вызов функции main() и начинается её выполнение. Стейтменты в main() выполняются последовательно. В конце функция main() возвращает целочисленное значение (обычно 0) обратно в операционную систему. Поэтому main() объявляется как int main().

Почему нужно возвращать значения обратно в операционную систему? Дело в том, что возвращаемое значение функции main() является кодом состояния, который сообщает операционной системе об успешном или неудачном выполнении программы. Обычно, возвращаемое значение 0 (ноль) означает что всё прошло успешно, тогда как любое другое значение означает неудачу/ошибку.

Обратите внимание, по стандартам языка C++ функция main() должна возвращать целочисленное значение. Однако, если вы не укажете return в конце функции main(), компилятор возвратит 0 автоматически, если никаких ошибок не будет. Но рекомендуется указывать return в конце функции main() и использовать тип возврата int для функции main().

## Еще о возвращаемых значениях
Во-первых, если тип возврата функции не void, то она должна возвращать значение указанного типа (использовать оператор return). Единственно исключение — функция main(), которая возвращает 0, если не предоставлено другое значение.

Во-вторых, когда процессор встречает в функции оператор return, он немедленно выполняет возврат значения обратно в caller и точка выполнения также переходит в caller. Любой код, который находится за оператором return в функции — игнорируется.

Функция может возвращать только одно значение через return обратно в caller. Это может быть либо число (например, 7), либо значение переменной, либо выражение (у которого есть результат), либо определенное значение из набора возможных значений.

Наконец, автор функции решает, что означает её возвращаемое значение. Некоторые функции используют возвращаемые значения в качестве кодов состояния для указания результата выполнения функции (успешно ли выполнение или нет). Другие функции возвращают определенное значение из набора возможных значений. Кроме того, существуют функции, которые вообще ничего не возвращают.

## Повторное использование функций

Одну и ту же функцию можно вызывать несколько раз, даже в разных программах, что очень полезно:
```cpp


#include <iostream>

// Функция getValueFromUser() получает значение от пользователя, а затем возвращает его обратно в caller
int getValueFromUser()
{
   std::cout << "Enter an integer: ";
   int x;
   std::cin >> x;
   return x;
}

int main()
{
   int a = getValueFromUser(); // первый вызов функции getValueFromUser()
   int b = getValueFromUser(); // второй вызов функции getValueFromUser()

   std::cout << a << " + " << b << " = " << a + b << std::endl;

   return 0;
}
```

Здесь main() прерывается 2 раза. Обратите внимание, в обоих случаях, полученное пользовательское значение сохраняется в переменной x, а затем передается обратно в main() с помощью return, где присваивается переменной a или b!

Также main() не является единственной функцией, которая может вызывать другие функции. Любая функция может вызывать любую другую функцию!
```cpp


#include <iostream>

void printO()
{
   std::cout << "O" << std::endl;
}

void printK()
{
   std::cout << "K" << std::endl;
}

// Функция printOK() вызывает как printO(), так и printK()
void printOK()
{
   printO();
   printK();
}

// Объявление main()
int main()
{
   std::cout << "Starting main()" << std::endl;
   printOK();
   std::cout << "Ending main()" << std::endl;
   return 0;
}
```

## Вложенные функции
В языке С++ одни функции не могут быть объявлены внутри других функций (т.е. быть вложенными). Следующий код вызовет ошибку компиляции:
```cpp


#include <iostream>

int main()
{
   int boo() // эта функция находится внутри функции main(), что запрещено
   {
      std::cout << "boo!";
      return 0;
   }

   boo();
   return 0;
}
```
Правильно вот так:
```cpp


#include <iostream>

int boo() // теперь уже не в main()
{
   std::cout << "boo!";
   return 0;
}

int main()
{
   boo();
   return 0;
}
```
## Тест
Какие из следующих программ не скомпилируются (и почему), а какие скомпилируются (и какой у них результат)?

Программа 1:
```cpp


#include <iostream>

int return5()
{
    return 5;
}
 
int return8()
{
    return 8;
}
 
int main()
{
    std::cout << return5() + return8() << std::endl;
 
    return 0;
}
```
Программа 2:
```cpp


#include <iostream>

int return5()
{
    return 5;
 
    int return8()
    {
        return 8;
    }
}
 
int main()
{
    std::cout << return5() + return8() << std::endl;
 
    return 0;
}
```
Программа 3:
```cpp


#include <iostream>

int return5()
{
    return 5;
}
 
int return8()
{
    return 8;
}
 
int main()
{
    return5();
    return8();
 
    return 0;
}
```
Программа 4:
```cpp


#include <iostream>

void printO()
{
    std::cout << "O" << std::endl;
}
 
int main()
{
    std::cout << printO() << std::endl;
 
    return 0;
}
```
Программа 5:
```cpp


#include <iostream>

int getNumbers()
{
    return 6;
    return 8;
}
 
int main()
{
    std::cout << getNumbers() << std::endl;
    std::cout << getNumbers() << std::endl;
 
    return 0;
}
```
Программа 6:
```cpp


#include <iostream>

int return 6()
{
    return 6;
}
 
int main()
{
    std::cout << return 6() << std::endl;
 
    return 0;
}
```
Программа №7:
```cpp


#include <iostream>

int return6()
{
    return 6;
}
 
int main()
{
    std::cout << return6 << std::endl;
 
    return 0;
}
```
