# ООП в С++

## Объекты имеют два основных компонента:
- свойства (например, вес, цвет, размер, прочность, форма и т.д.);
- поведение, которое они могут проявлять (например, открывать что-либо, делать что-то и т.д.).

Объектно-ориентированное программирование предоставляет возможность создавать объекты, которые объединяют свойства и поведение в самостоятельный союз, который затем можно многоразово использовать. 

Вместо того, чтобы сосредоточиться на написании функций, мы концентрируемся на определении объектов, которые имеют четкий набор поведений. Вот почему эта парадигма называется «объектно-ориентированной».

Это позволяет создавать программы модульным способом, что упрощает не только написание и понимание кода, но и обеспечивает более высокий уровень возможности повторного использования этого кода. Объекты также обеспечивают более интуитивный способ работы с данными, позволяя программисту определить, как он будет взаимодействовать с объектами, и как эти объекты будут взаимодействовать с другими объектами.

ООП не заменяет традиционные методы программирования. ООП — это дополнительный инструмент управления сложностью.

Объектно-ориентированное программирование также предоставляет несколько других полезных концепций, таких как наследование, инкапсуляция, абстракция и полиморфизм. 

В традиционном программировании, объект — это часть памяти для хранения значений. В объектно-ориентированном программировании, объект — это тот же объект, что и в традиционном программировании, но который соединяет в себе как свойства, так и способы поведения.

# Классы, Объекты и Методы

Хотя язык C++ предоставляет ряд фундаментальных типов данных (например, char, int, long, float, double и т.д.), которых бывает достаточно для решения относительно простых проблем, для решения сложных проблем функционала этих простых типов может не хватать.

## Классы
Одной из наиболее полезных особенностей языка C++ является возможность определять собственные типы данных, которые будут лучше соответствовать в решении конкретных проблем.
Например, структура для хранения даты:
```c

struct DateStruct
{
    int day;
    int month;
    int year;
};

```
Перечисления и структуры — это традиционный (не объектно-ориентированный) мир программирования, в котором мы можем только хранить данные. В C++11 мы можем создать и инициализировать структуру следующим образом:
```c

DateStruct today { 12, 11, 2018}; // используем uniform-инициализацию

```
Для вывода даты на экран хорошей идеей будет написать отдельную функцию, например:
```c

#include <iostream>
 
struct DateStruct
{
    int day;
    int month;
    int year;
};
 
void print(DateStruct &date)
{
    std::cout << date.day<< "/" << date.month << "/" << date.year;
}
 
int main()
{
    DateStruct today { 12, 11, 2018}; // используем uniform-инициализацию
 
    today.day = 18; // используем оператор выбора члена для выбора члена структуры
    print(today);
 
    return 0;
}


```
В объектно-ориентированном программировании типы данных могут содержать не только данные, но и функции, которые будут работать с этими данными. Для определения такого типа данных в языке C++ используется ключевое слово class. Использование ключевого слова class определяет новый пользовательский тип данных — класс.

В языке C++ классы очень похожи на структуры, за исключением того, что они обеспечивают гораздо большую мощность и гибкость. Фактически, следующая структура и класс идентичны по функционалу:

```c

struct DateStruct
{
    int day;
    int month;
    int year;
};
 
class DateClass
{
public:
    int m_day;
    int m_month;
    int m_year;
};

```
Единственным существенным отличием здесь является public — ключевое слово в классе.

Так же, как и объявление структуры, объявление класса не приводит к выделению какой-либо памяти. Для использования класса нужно объявить переменную этого типа класса:
```c

DateClass today { 12, 11, 2018 }; // инициализируем переменную класса DateClass

```
В языке C++ переменная класса называется экземпляром (или объектом) класса. Точно так же, как определение переменной фундаментального типа данных (например, int x) приводит к выделению памяти для этой переменной, так же и создание объекта класса (например, DateClass today) приводит к выделению памяти для этого объекта.

## Методы классов

Помимо хранения данных, классы могут содержать и функции! Функции, определенные внутри класса, называются методами. Методы могут быть определены, как внутри, так и вне класса.

### Класс Date с методом вывода даты:
```c

class DateClass
{
public:
    int m_day;
    int m_month;
    int m_year;
 
    void print() // определяем функцию-член
    {
        std::cout << m_day << "/" << m_month << "/" << m_year;
    }
};

```
Точно так же, как к членам структуры, так и к членам (переменным и функциям) класса доступ осуществляется через оператор выбора членов (.):

```c

#include <iostream>
 
class DateClass
{
public:
    int m_day;
    int m_month;
    int m_year;
 
    void print()
    {
        std::cout << m_day << "/" << m_month << "/" << m_year;
    }
};
 
int main()
{
    DateClass today { 12, 11, 2018 };
 
    today.m_day = 18; // используем оператор выбора членов для выбора переменной-члена m_day объекта today класса DateClass
    today.print(); // используем оператор выбора членов для вызова метода print() объекта today класса DateClass
 
    return 0;
}

```
Обратите внимание, как эта программа похожа на вышеприведенную программу, где используется структура. Однако есть несколько отличий. В версии DateStruct нам нужно было передать переменную структуры непосредственно в функцию print() в качестве параметра. Если бы мы этого не сделали, то функция print() не знала бы, какую переменную структуры DateStruct выводить. Нам тогда бы пришлось явно ссылаться на члены структуры внутри функции.

Методы класса работают несколько иначе: все вызовы методов должны быть связаны с объектом класса. Когда мы вызываем today.print(), то мы сообщаем компилятору вызвать метод print() объекта today.

Рассмотрим определение метода print() еще раз:
```c

    void print() // определяем метод
    {
        std::cout << m_day << "/" << m_month << "/" << m_year;
    }

```
На что фактически ссылаются m_day, m_month и m_year? Они ссылаются на связанный объект today (который определен caller-ом).

Поэтому, при вызове today.print(), компилятор интерпретирует:
- m_day, как today.m_day;
- m_month, как today.m_month;
- m_year, как today.m_year.

Если бы мы вызвали tomorrow.print(), то m_day ссылался бы на tomorrow.m_day.

По сути, связанный объект неявно передается методу. По этой причине его часто называют неявным объектом.

Ключевым моментом здесь является то, что для работы с функциями, не являющимися членами класса, нам нужно передавать данные в эту функцию явно (в качестве параметров). А для работы с методами у нас всегда есть неявный объект класса!

Использование префикса m_ (m = members) для переменных-членов помогает различать переменные-члены от параметров функции или локальных переменных внутри методов класса. Это полезно по нескольким причинам:
- во-первых, когда мы видим переменную с префиксом m_, то мы понимаем, что работаем с переменной-членом класса;
- во-вторых, в отличие от параметров функции или локальных переменных, объявленных внутри функции, переменные-члены объявляются в определении класса. Следовательно, если мы хотим знать, как объявлена переменная с префиксом m_, мы понимаем, что искать нужно в определении класса, а не внутри функции.

Обычно программисты пишут имена классов с заглавной буквы.
```c
#include <iostream>
#include <string>
 
class Employee
{
public:
    std::string m_name;
    int m_id;
    double m_wage;
 
    // Метод вывода информации о работнике на экран
    void print()
    {
        std::cout << "Name: " << m_name <<
                "\nId: " << m_id << 
                "\nWage: $" << m_wage << '\n'; 
    }
};
 
int main()
{
    // Определяем двух работников
    Employee john { "John", 5, 30.00 };
    Employee max { "Max", 6, 32.75 };
 
    // Выводим информацию о работниках на экран
    john.print();
    std::cout<<std::endl;
    max.print();
 
    return 0;
}

```
В отличие от обычных функций, порядок, в котором определены методы класса, не имеет значения!

Используйте ключевое слово struct для структур, используемых только для хранения данных. 
Используйте ключевое слово class для объектов, объединяющих как данные, так и функции.

Ключевое слово class позволяет создать пользовательский тип данных в языке C++, который может содержать как переменные-члены, так и методы. Классы — это основа объектно-ориентированного программирования!


## Спецификаторы доступа public и private

```c

struct DateStruct // члены структуры являются открытыми по умолчанию 
{
    int day; // открыто по умолчанию, доступ имеет любой объект  
    int month; // открыто по умолчанию, доступ имеет любой объект
    int year; // открыто по умолчанию, доступ имеет любой объект
};
 
int main()
{
    DateStruct date;
    date.day = 12;
    date.month = 11;
    date.year = 2018;
 
    return 0;
}

```
Здесь мы объявляем структуру DateStruct, а затем напрямую обращаемся к её членам для их инициализации. Это работает, так как все члены структуры являются открытыми по умолчанию. Открытые члены (или public-члены) — это члены структуры или класса, к которым можно получить доступ извне этой же структуры или класса. В программе, приведенной выше, функция main() находится вне структуры, но она может напрямую обращаться к членам day, month и year, так как они являются открытыми.

С другой стороны, рассмотрим следующий почти идентичный класс:

```c

class DateClass // члены класса являются закрытыми по умолчанию
{
    int m_day; // закрыто по умолчанию, доступ имеют только другие члены класса
    int m_month; // закрыто по умолчанию, доступ имеют только другие члены класса
    int m_year; // закрыто по умолчанию, доступ имеют только другие члены класса
};
 
int main()
{
    DateClass date;
    date.m_day = 12; // ошибка
    date.m_month = 11; // ошибка
    date.m_year = 2018; // ошибка
 
    return 0;
}

```
Вам бы не удалось скомпилировать эту программу, так как все члены класса являются закрытыми по умолчанию. Закрытые члены (или private-члены) — это члены класса, доступ к которым имеют только другие члены этого же класса. Поскольку функция main() не является членом DateClass, то она и не имеет доступа к закрытым членам объекта date.

Хотя члены класса являются закрытыми по умолчанию, мы можем сделать их открытыми, используя ключевое слово public:
```c


class DateClass
{
public: // обратите внимание на ключевое слово public и двоеточие
    int m_day; // открыто, доступ имеет любой объект 
    int m_month; // открыто, доступ имеет любой объект
    int m_year; // открыто, доступ имеет любой объект
};
 
int main()
{
    DateClass date;
    date.m_day = 12; // ок, так как m_day имеет спецификатор доступа public
    date.m_month = 11; // ок, так как m_month имеет спецификатор доступа public
    date.m_year = 2018; // ок, так как m_year имеет спецификатор доступа public
 
    return 0;
}

```
Поскольку теперь члены класса DateClass являются открытыми, то к ним можно получить доступ напрямую из функции main().

Ключевое слово public вместе с двоеточием называется спецификатором доступа. Спецификатор доступа определяет, кто имеет доступ к членам этого спецификатора. Каждый из членов «приобретает» уровень доступа в соответствии со спецификатором доступа (или, если он не указан, в соответствии со спецификатором доступа по умолчанию).

## В языке C++ есть 3 уровня доступа:
- спецификатор public делает члены открытыми;
- спецификатор private делает члены закрытыми;
- спецификатор protected открывает доступ к членам только для дружественных и дочерних классов

## Использование спецификаторов доступа

Классы могут использовать сразу несколько спецификаторов доступа для установки уровней доступа для каждого из своих членов. Обычно переменные-члены являются закрытыми, а методы — открытыми.

Устанавливайте спецификатор доступа private переменным-членам класса и спецификатор доступа public — методам класса (если у вас нет веских оснований делать иначе).

Рассмотрим пример класса, который использует спецификаторы доступа private и public:

```c

#include <iostream>
 
class DateClass // члены класса являются закрытыми по умолчанию
{
    int m_day; // закрыто по умолчанию, доступ имеют только другие члены класса
    int m_month; // закрыто по умолчанию, доступ имеют только другие члены класса
    int m_year; // закрыто по умолчанию, доступ имеют только другие члены класса
 
public:
    void setDate(int day, int month, int year) // открыто, доступ имеет любой объект
    {
        // Метод setDate() имеет доступ к закрытым членам класса, так как сам является членом класса
        m_day = day;
        m_month = month;
        m_year = year;
    }
 
    void print() // открыто, доступ имеет любой объект
    {
        std::cout << m_day << "/" << m_month << "/" << m_year;
    }
};
 
int main()
{
    DateClass date;
    date.setDate(12, 11, 2018); // ок, так как setDate() имеет спецификатор доступа public
    date.print(); // ок, так как print() имеет спецификатор доступа public
 
    return 0;
}

```
Обратите внимание, хоть мы и не можем получить доступ к переменным-членам объекта date напрямую из main() (так как они являются private по умолчанию), мы можем получить доступ к ним через открытые методы setDate() и print()!

Открытые члены классов составляют открытый (public) интерфейс. Поскольку доступ к открытым членам класса может осуществляться извне класса, то открытый интерфейс и определяет, как программы, использующие класс, будут взаимодействовать с этим же классом.

Некоторые программисты предпочитают сначала перечислить private-члены, а затем уже public-члены. Они руководствуются следующей логикой: public-члены обычно используют private-члены (те же переменные-члены в методах класса), поэтому имеет смысл сначала определять private-члены, а затем уже public-члены. Другие же программисты считают, что сначала нужно указывать public-члены. Здесь уже иная логика: поскольку private-члены закрыты и получить к ним доступ напрямую нельзя, то и выносить их на первое место тоже не нужно. Работать будет и так, и так. Какой способ использовать — выбирайте сами, что вам удобнее.

Рассмотрим следующую программу:
```c
#include <iostream>
 
class DateClass // члены класса являются закрытыми по умолчанию 
{
  int m_day; // закрыто по умолчанию, доступ имеют только другие члены класса
  int m_month; // закрыто по умолчанию, доступ имеют только другие члены класса
  int m_year; // закрыто по умолчанию, доступ имеют только другие члены класса
 
public:
  void setDate(int day, int month, int year)
  {
    m_day = day;
    m_month = month;
    m_year = year;
  }
 
  void print()
  {
    std::cout << m_day << "/" << m_month << "/" << m_year;
  }
 
  // Обратите внимание на этот дополнительный метод
  void copyFrom(const DateClass &b)
  {
    // Мы имеем прямой доступ к закрытым членам объекта b
    m_day = b.m_day;
    m_month = b.m_month;
    m_year = b.m_year;
  }
};
 
int main()
{
  DateClass date;
  date.setDate(12, 11, 2018); // ок, так как setDate() имеет спецификатор доступа public
  
  DateClass copy;
  copy.copyFrom(date); // ок, так как copyFrom() имеет спецификатор доступа public
  copy.print();
 
  return 0;
}

```
Один нюанс в языке C++, который часто игнорируют/забывают/неправильно понимают, заключается в том, что контроль доступа работает на основе класса, а не на основе объекта. Это означает, что, когда метод имеет доступ к закрытым членам класса, он может обращаться к закрытым членам любого объекта этого класса.

В примере, приведенном выше, метод copyFrom() является членом класса DateClass, что открывает ему доступ к private-членам класса DateClass. Это означает, что copyFrom() может не только напрямую обращаться к закрытым членам неявного объекта с которым работает (копия объекта), но и имеет прямой доступ к закрытым членам объекта b класса DateClass!

Это полезно, когда нужно скопировать элементы из одного объекта класса в другой объект того же класса. 

## Структуры vs. Классы
Теперь, когда мы узнали о спецификаторах доступа, мы можем поговорить о фактических различиях между классом и структурой в языке C++. Класс по умолчанию устанавливает всем своим членам спецификатор доступа private. Структура же по умолчанию устанавливает всем своим членам спецификатор доступа public.

Есть еще одно незначительное отличие: структуры наследуют от других конструкций языка С++ открыто, в то время как классы наследуют закрыто.


## Инкапсуляция

В объектно-ориентированном программировании инкапсуляция (сокрытие информации) — это процесс скрытого хранения деталей реализации объекта. Пользователи обращаются к объекту через открытый интерфейс.

В языке C++ инкапсуляция реализована через спецификаторы доступа. Как правило, все переменные-члены класса являются закрытыми (скрывая детали реализации), а большинство методов являются открытыми (с открытым интерфейсом для пользователя). Хотя требование к пользователям использовать публичный интерфейс может показаться более обременительным, нежели просто открыть доступ к переменным-членам, но на самом деле это предоставляет большое количество полезных преимуществ, которые улучшают возможность повторного использования кода и его поддержку.

1. Инкапсулированные классы проще в использовании и уменьшают сложность ваших программ.

С полностью инкапсулированным классом вам нужно знать только то, какие методы являются доступными для использования, какие аргументы они принимают и какие значения возвращают. Не нужно знать, как класс реализован изнутри. Например, класс, содержащий список имен, может быть реализован с использованием динамического массива, строк C-style, std::array, std::vector, std::map, std::list или любой другой структуры данных. Для использования этого класса, вам не нужно знать детали его реализации. Это значительно снижает сложность ваших программ, а также уменьшает количество возможных ошибок. Это является ключевым преимуществом инкапсуляции.

Все классы Стандартной библиотеки C++ инкапсулированы. Представьте, насколько сложнее был бы процесс изучения языка C++, если бы вам нужно было знать реализацию std::string, std::vector или std::cout (и других объектов) для того, чтобы их использовать!

2. Инкапсулированные классы помогают защитить ваши данные и предотвращают их неправильное использование.

Глобальные переменные опасны, так как нет строгого контроля над тем, кто имеет к ним доступ и как их используют. Классы с открытыми членами имеют ту же проблему, только в меньших масштабах. Например, допустим, что нам нужно написать строковый класс. Мы могли бы начать со следующего:

```c

class MyString
{
    char *m_string; // динамически выделяем строку 
    int m_length; // используем переменную для отслеживания длины строки
};

```
Эти два члена связаны: m_length всегда должен соответствовать длине строки, удерживаемой m_string. Если бы m_length был открытым, то любой мог бы изменить длину строки без изменения m_string (или наоборот). Это точно привело бы к проблемам. Делая как m_length, так и m_string закрытыми, пользователи вынуждены использовать методы для взаимодействия с классом.

Мы также можем сами улучшить защиту нашего класса от неправильного использования. Например, рассмотрим класс с открытой переменной-членом в виде массива:
```c

class IntArray
{
public:
    int m_array[10];
};

```
Если бы пользователи могли напрямую обращаться к массиву, то они могли бы использовать недопустимый индекс:
```c

int main()
{
    IntArray array;
    array.m_array[16] = 2; // некорректный индекс, вследствие чего перезаписываем память, которой мы не владеем
}

```
Однако, если мы сделаем массив закрытым, то сможем заставить пользователя использовать функцию, которая первым делом проверяет корректность индекса:
```c

class IntArray
{
private:
    int m_array[10]; // пользователь не имеет прямого доступа к этому члену
 
public:
    void setValue(int index, int value)
    {
        // Если индекс недействителен, то не делаем ничего
        if (index < 0 || index >= 10)
            return;
 
        m_array[index] = value;
    }
};

```
Таким образом, мы защитим целостность нашей программы.

 
3. Инкапсулированные классы легче изменить.

```c

#include <iostream>
 
class Values
{
public:
    int m_number1;
    int m_number2;
    int m_number3;
};
 
int main()
{
    Values value;
    value.m_number1 = 7;
    std::cout << value.m_number1 << '\n';
}

```
Хотя эта программа работает нормально, но что произойдет, если мы решим переименовать m_number1 или изменить тип этой переменной? Мы бы сломали не только эту программу, но и большую часть программ, которые используют класс Values!

Инкапсуляция предоставляет возможность изменения способа реализации классов, не нарушая при этом работу всех программ, которые их используют. Вот инкапсулированная версия класса, приведенного выше, но которая использует методы для доступа к m_number1:

```c

#include <iostream>
 
class Values
{
private:
    int m_number1;
    int m_number2;
    int m_number3;
 
public:
    void setNumber1(int number) { m_number1 = number; }
    int getNumber1() { return m_number1; }
};
 
int main()
{
    Values value;
    value.setNumber1(7);
    std::cout << value.getNumber1() << '\n';
}

```
Теперь давайте изменим реализацию класса:

```c

#include <iostream>
 
class Values
{
private:
    int m_number[3]; // здесь изменяем реализацию этого класса
 
public:
    // Нам нужно обновить переменные методов, чтобы заработала новая реализация
    void setNumber1(int number) { m_number[0] = number; }
    int getNumber1() { return m_number[0]; }
};
 
int main()
{
    // Но наша программа продолжает работать как прежде
    Values value;
    value.setNumber1(7);
    std::cout << value.getNumber1() << '\n';
}

```
Обратите внимание, поскольку мы не изменяли прототипы каких-либо функций в открытом интерфейсе нашего класса, наша программа, использующая класс, продолжает работать без каких-либо изменений или проблем.
 
4. С инкапсулированными классами легче проводить отладку.

Инкапсуляция помогает проводить отладку программ, когда что-то идет не по плану. Часто причиной неправильной работы программы является некорректное значение одной из переменных. Если каждый объект имеет прямой доступ к переменной, то отследить часть кода, которая изменила переменную, может быть довольно-таки трудно. Однако, если для изменения значения нужно вызывать один и тот же метод, вы можете просто использовать точку останова для этого метода и посмотреть, как каждый вызывающий объект изменяет значение, пока не увидите что-то странное.

## Функции доступа (геттеры и сеттеры)
В зависимости от класса, может быть уместным (в контексте того, что делает класс) иметь возможность получать/устанавливать значения закрытым переменным-членам класса.

Функция доступа — это короткая открытая функция, задачей которой является получение или изменение значения закрытой переменной-члена класса. Например:
```c

class MyString
{
private:
    char *m_string; // динамически выделяем строку
    int m_length; // используем переменную для отслеживания длины строки
 
public:
    int getLength() { return m_length; } // функция доступа для получения значения m_length
};

```
Здесь getLength() является функцией доступа, которая просто возвращает значение m_length.

Функции доступа обычно бывают двух типов:
- геттеры — это функции, которые возвращают значения закрытых переменных-членов класса;
- сеттеры — это функции, которые позволяют присваивать значения закрытым переменным-членам класса.

Вот пример класса, который использует геттеры и сеттеры для всех своих закрытых переменных-членов:

```c

class Date
{
private:
    int m_day;
    int m_month;
    int m_year;
 
public:
    int getDay() { return m_day; } // геттер для day
    void setDay(int day) { m_day = day; } // сеттер для day
 
    int getMonth() { return m_month; } // геттер для month
    void setMonth(int month) { m_month = month; } // сеттер для month
 
    int getYear() { return m_year; } // геттер для year
    void setYear(int year) { m_year = year; } // сеттер для year
};

```
В этом классе нет никаких проблем с тем, чтобы пользователь мог напрямую получать или присваивать значения закрытым переменным-членам этого класса, так как есть полный набор геттеров и сеттеров. В примере с классом MyString для переменной m_length не было предоставлено сеттера, так как не было необходимости в том, чтобы пользователь мог напрямую устанавливать длину.

Предоставляйте функции доступа только в том случае, когда нужно, чтобы пользователь имел возможность получать или присваивать значения членам класса.

Хотя иногда вы можете увидеть, что геттер возвращает неконстантную ссылку на переменную-член — этого следует избегать, так как в таком случае нарушается инкапсуляция, позволяя caller-у изменять внутреннее состояние класса вне этого же класса. Лучше, чтобы ваши геттеры использовали тип возврата по значению или по константной ссылке.

Геттеры должны использовать тип возврата по значению или по константной ссылке. Не используйте для геттеров тип возврата по неконстантной ссылке.

Инкапсуляция имеет много преимуществ, основное из которых заключается в использовании класса без необходимости понимания его реализации. Инкапсулированные классы:
- проще в использовании;
- уменьшают сложность программы;
- защищают данные и предотвращают их неправильное использование;
- легче изменять;
- легче отлаживать.

## Конструкторы

Когда все члены класса (или структуры) являются открытыми, то мы можем инициализировать класс (или структуру) напрямую, используя список инициализаторов или uniform-инициализацию (в C++11):

```c

class Boo
{
public:
    int m_a;
    int m_b;
};
 
int main()
{
    Boo boo1 = { 7, 8 }; // список инициализаторов
    Boo boo2 { 9, 10 }; // uniform-инициализация (C++11)
 
    return 0;
}

```

### Как инициализировать класс с закрытыми переменными-членами

Конструктор — это особый тип метода класса, который автоматически вызывается при создании объекта этого же класса. Конструкторы обычно используются для инициализации переменных-членов класса значениями, которые предоставлены по умолчанию/пользователем, или для выполнения любых шагов настройки, необходимых для используемого класса (например, открыть определенный файл или базу данных).

В отличие от обычных методов, конструкторы имеют определенные правила их именования:
- конструкторы всегда должны иметь то же имя, что и класс (учитываются верхний и нижний регистры);
- конструкторы не имеют типа возврата (даже void).

конструкторы предназначены только для выполнения инициализации. Не следует пытаться вызывать конструктор для повторной инициализации существующего объекта. Хотя это может скомпилироваться без ошибок, результаты могут получиться неожиданные (компилятор создаст временный объект, а затем удалит его).

## Конструкторы по умолчанию
Конструктор, который не имеет параметров (или содержит параметры, которые все имеют значения по умолчанию), называется конструктором по умолчанию. Он вызывается, если пользователем не указаны значения для инициализации. Например:

```c

#include <iostream>
 
class Fraction
{
private:
    int m_numerator;
    int m_denominator;
 
public:
    Fraction() // конструктор по умолчанию 
    {
         m_numerator = 0;
         m_denominator = 1;
    }
 
    int getNumerator() { return m_numerator; }
    int getDenominator() { return m_denominator; }
    double getValue() { return static_cast<double>(m_numerator) / m_denominator; }
};
 
int main()
{
    Fraction drob; // так как нет никаких аргументов, то вызывается конструктор по умолчанию Fraction()
    std::cout << drob.getNumerator() << "/" << drob.getDenominator() << '\n';
 
    return 0;
}

```
Этот класс содержит дробь в виде отдельных значений типа int. Конструктор по умолчанию называется Fraction (как и класс). Поскольку мы создали объект класса Fraction без аргументов, то конструктор по умолчанию сработал сразу же после выделения памяти для объекта, и инициализировал наш объект.

Обратите внимание, наш числитель (m_numerator) и знаменатель (m_denominator) были инициализированы значениями, которые мы задали в конструкторе по умолчанию! Это настолько полезная особенность, что почти каждый класс имеет свой конструктор по умолчанию. Без него значениями нашего числителя и знаменателя был бы мусор до тех пор, пока мы явно не присвоили бы им нормальные значения.

## Конструкторы с параметрами
Хотя конструктор по умолчанию отлично подходит для обеспечения инициализации наших классов значениями по умолчанию, часто может быть нужно, чтобы экземпляры нашего класса имели определенные значения, которые мы предоставим позже. К счастью, конструкторы также могут быть объявлены с параметрами. Вот пример конструктора, который имеет два целочисленных параметра, которые используются для инициализации числителя и знаменателя:

```c

#include <cassert>
 
class Fraction
{
private:
    int m_numerator;
    int m_denominator;
 
public:
    Fraction() // конструктор по умолчанию
    {
         m_numerator = 0;
         m_denominator = 1;
    }
 
    // Конструктор с двумя параметрами, один из которых имеет значение по умолчанию
    Fraction(int numerator, int denominator=1)
    {
        assert(denominator != 0);
        m_numerator = numerator;
        m_denominator = denominator;
    }
 
    int getNumerator() { return m_numerator; }
    int getDenominator() { return m_denominator; }
    double getValue() { return static_cast<double>(m_numerator) / m_denominator; }
};

```
Обратите внимание, теперь у нас есть два конструктора: конструктор по умолчанию, который будет вызываться, если мы не предоставим значения, и конструктор с параметрами, который будет вызываться, если мы предоставим значения. Эти два конструктора могут мирно сосуществовать в одном классе благодаря перегрузке функций. Фактически, вы можете определить любое количество конструкторов до тех пор, пока у них будут уникальные параметры (учитывается их количество и тип).

## Прямая инициализация:
```c

int a(7); // прямая инициализация
Fraction drob(4, 5); // инициализируем напрямую, вызывается конструктор Fraction(int, int)

```
Здесь мы инициализировали нашу дробь числами 4 и 5, результат — 4/5!

В C++11 мы также можем использовать uniform-инициализацию:
```c

int a { 7 }; // uniform-инициализация 
Fraction drob {4, 5}; // uniform-инициализация, вызывается конструктор Fraction(int, int)

```
Мы также можем указать только один параметр для конструктора с параметрами, а второе значение будет значением по умолчанию:
```c

Fraction seven(7); // вызывается конструктор Fraction(int, int), второй параметр использует значение по умолчанию

```
Значения по умолчанию для конструкторов работают точно так же, как и для любой другой функции, поэтому в вышеприведенном примере, когда мы вызываем seven(7), вызывается Fraction(int, int), второй параметр которого равен 1 (значение по умолчанию).

Используйте прямую инициализацию или uniform-инициализацию с объектами ваших классов.

## Копирующая инициализация
Подобно обычным переменным, классы также можно инициализировать, используя копирующую инициализацию:

```c

int a = 7; // копирующая инициализация 
Fraction eight = Fraction(8); // копирующая инициализация, вызывается Fraction(8, 1)
Fraction nine = 9; // копирующая инициализация. Компилятор будет искать пути конвертации 9 в Fraction, что приведет к вызову конструктора Fraction(9, 1)

```
Однако рекомендуется избегать этой формы инициализации классов, так как она может быть менее эффективной. Хотя uniform-инициализация, прямая и копирующая инициализации работают одинаково с фундаментальными типами данных, с классами это не совсем так (хотя конечный результат часто совпадает). 

Не используйте копирующую инициализацию с объектами ваших классов.

## Уменьшение количества конструкторов
В примере с классом Fraction и двумя конструкторами (по умолчанию и с параметрами), конструктор по умолчанию на самом деле лишний. Мы могли бы упростить этот класс следующим образом:

```c

#include <cassert>
 
class Fraction
{
private:
    int m_numerator;
    int m_denominator;
 
public:
    // Конструктор по умолчанию
    Fraction(int numerator=0, int denominator=1)
    {
        assert(denominator != 0);
        m_numerator = numerator;
        m_denominator = denominator;
    }
 
    int getNumerator() { return m_numerator; }
    int getDenominator() { return m_denominator; }
    double getValue() { return static_cast<double>(m_numerator) / m_denominator; }
};

```
Хотя этот конструктор по-прежнему является конструктором по умолчанию, он теперь определен таким образом, что может принимать одно или два значения, предоставленные пользователем:
```c

Fraction drob; // вызов Fraction(0, 1)
Fraction seven(7); // вызов Fraction(7, 1)
Fraction sixTwo(6, 2); // вызов Fraction(6, 2)

```
На практике старайтесь сокращать количество конструкторов вашего класса.

## Неявно генерируемый конструктор по умолчанию

Если ваш класс не имеет конструкторов, то язык C++ автоматически сгенерирует для вашего класса открытый конструктор по умолчанию. Его иногда называют неявным конструктором (или «неявно сгенерированным конструктором»). Рассмотрим следующий класс:
```c

class Date
{
private:
    int m_day = 12;
    int m_month = 1;
    int m_year = 2018;
};

```
У этого класса нет конструктора, поэтому компилятор сгенерирует следующий конструктор:
```c

class Date
{
private:
    int m_day = 12;
    int m_month = 1;
    int m_year = 2018;
 
public:
    Date() // неявно генерируемый конструктор
    {
    }
};

```
Этот конструктор позволяет создавать объекты класса, но не выполняет их инициализацию и не присваивает значения членам класса.

Хотя вы не можете увидеть неявно сгенерированный конструктор, но его существование можно доказать:
```c

class Date
{
private:
    int m_day = 12;
    int m_month = 1;
    int m_year = 2018;
 
    // Не было предоставлено конструктора, поэтому C++ автоматически создаст открытый конструктор по умолчанию
};
 
int main()
{
    Date date; // вызов неявного конструктора
 
    return 0;
}

```
Вышеприведенный код скомпилируется, поскольку в объекте date сработает неявный конструктор (который является открытым). Если ваш класс имеет другие конструкторы, то неявно генерируемый конструктор создаваться не будет. Например:
```c

class Date
{
private:
    int m_day = 12;
    int m_month = 1;
    int m_year = 2018;
 
public:
    Date(int day, int month, int year) // обычный конструктор (не по умолчанию)
    {
        m_day = day;
        m_month = month;
        m_year = year;
    }
 
    // Неявный конструктор не создастся, так как мы уже определили свой конструктор
};
 
int main()
{
    Date date; // ошибка: Невозможно создать объект, так как конструктор по умолчанию не существует, и компилятор не сгенерировал неявный конструктор автоматически
    Date today(14, 10, 2020); // инициализируем объект today
 
    return 0;
}

```
Рекомендуется всегда создавать по крайней мере один конструктор в классе. Это позволит вам контролировать процесс создания объектов вашего класса, и предотвратит возникновение потенциальных проблем после добавления других конструкторов.

Создавайте хотя бы один конструктор в классе, даже если это пустой конструктор по умолчанию.

## Классы, содержащие другие классы
Одни классы могут содержать другие классы в качестве переменных-членов. По умолчанию, при создании внешнего класса, для переменных-членов будут вызываться конструкторы по умолчанию. Это произойдет до того, как тело конструктора выполнится. Это можно продемонстрировать следующим образом:
```c

#include <iostream>
 
class A
{
public:
    A() { std::cout << "A\n"; }
};
 
class B
{
private:
    A m_a; // B содержит A, как переменную-член
 
public:
    B() { std::cout << "B\n"; }
};
 
int main()
{
    B b;
    return 0;
}


```
При создании переменной b вызывается конструктор B(). Прежде чем тело конструктора выполнится, m_a инициализируется, вызывая конструктор по умолчанию класса A. Таким образом выведется A. Затем управление возвратится обратно к конструктору B, и тело конструктора B начнет свое выполнение.

Здесь есть смысл, так как конструктор B() может захотеть использовать переменную m_a, поэтому сначала нужно инициализировать m_a!


## Задание 1
Создайте класс Numbers, который содержит два целых числа. Этот класс должен иметь две переменные-члены для хранения этих двух целых чисел. Вы также должны создать два метода:
- метод set(), который позволит присваивать значения переменным;
- метод print(), который будет выводить значения переменных.

Выполнение следующей функции main():
```c

int main()
{
  Numbers n1;
  n1.set(3, 3); // инициализируем объект n1 значениями 3 и 3
  
  Numbers n2{ 4, 4 }; // инициализируем объект n2 значениями 4 и 4
 
  n1.print();
  n2.print();
 
  return 0;
}

```
Должно выдавать следующий результат:

Numbers(3, 3)
Numbers(4, 4)


## Задание 2
Почему для Numbers должен использоваться класс, а не структура?


## Задание 3
a) Что такое открытый член?
b) Что такое закрытый член?
c) Что такое спецификатор доступа?
d) Сколько есть спецификаторов доступа в языке C++? Назовите их.

## Задание 4
a) Напишите простой класс с именем Numbers. Этот класс должен иметь:
- три закрытые переменные-члены типа double: m_a, m_b и m_c;
- открытый метод с именем setValues(), который позволит устанавливать значения для m_a, m_b и m_c;
- открытый метод с именем print(), который будет выводить объект класса Numbers в следующем формате:
```c

 <m_a, m_b, m_c>.

```
Следующий код функции main():

```c

int main()
{
    Numbers point;
    point.setValues(3.0, 4.0, 5.0);
 
    point.print();
 
    return 0;
}
// Должен выдавать следующий результат:

<3, 4, 5>

```

b) Добавьте функцию isEqual() в класс Numbers, чтобы следующий код работал корректно:

```c

int main()
{
    Numbers point1;
    point1.setValues(3.0, 4.0, 5.0);
 
    Numbers point2;
    point2.setValues(3.0, 4.0, 5.0);
 
    if (point1.isEqual(point2))
        std::cout << "point1 and point2 are equal\n";
    else
        std::cout << "point1 and point2 are not equal\n";
 
    Numbers point3;
    point3.setValues(7.0, 8.0, 9.0);
 
    if (point1.isEqual(point3))
        std::cout << "point1 and point3 are equal\n";
    else
        std::cout << "point1 and point3 are not equal\n";
 
    return 0;
}

```

## Задание 5
Напишите класс, который реализует функционал стека. Класс Stack должен иметь:
- закрытый целочисленный фиксированный массив длиной 10 элементов;
- закрытое целочисленное значение для отслеживания длины стека;
- открытый метод с именем reset(), который будет инициализировать значением 0 длину и все значения элементов;
- открытый метод с именем push(), который будет добавлять значение в стек. Метод push() должен возвращать значение false, если массив уже заполнен, в противном случае — true;
- открытый метод с именем pop() для возврата значений из стека. Если в стеке нет значений, то должен выводиться стейтмент assert;
- открытый метод с именем print(), который будет выводить все значения стека.

Следующий код функции main():
```c

int main()
{
  Stack stack;
  stack.reset();
 
  stack.print();
 
  stack.push(3);
  stack.push(7);
  stack.push(5);
  stack.print();
 
  stack.pop();
  stack.print();
 
  stack.pop();
  stack.pop();
 
  stack.print();
 
  return 0;
}
// Должен выдавать следующий результат:

( )
( 3 7 5 )
( 3 7 )
( )

```
## Задание 6
a) Напишите класс Ball, который должен иметь следующие две закрытые переменные-члены со значениями по умолчанию:
```c

   m_color (Red);
   m_radius (20.0).

```
В классе Ball должны быть следующие конструкторы:
- для установления значения только для m_color;
- для установления значения только для m_radius;
- для установления значений и для m_radius, и для m_color;
- для установления значений, когда значения не предоставлены вообще.

Не используйте параметры по умолчанию для конструкторов. Напишите еще одну функцию для вывода цвета (m_color) и радиуса (m_radius) шара (объекта класса Ball).

Следующий код функции main():
```c

int main()
{
    Ball def;
    def.print();
 
  Ball black("black");
  black.print();
  
  Ball thirty(30.0);
  thirty.print();
  
  Ball blackThirty("black", 30.0);
  blackThirty.print();
 
    return 0;
}
Должен выдавать следующий результат:

color: red, radius: 20
color: black, radius: 20
color: red, radius: 30
color: black, radius: 30

```

b) Теперь обновите ваш код из предыдущего задания с использованием конструкторов с параметрами по умолчанию. Постарайтесь использовать как можно меньше конструкторов.

## Задание 7
Что произойдет, если не объявить конструктор по умолчанию?
