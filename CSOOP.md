# Классы и объекты

Объектно-Ориентированное Программирование (ООП) является одной из наиболее популярных парадигм в мире промышленной разработки программного обеспечения. Из других парадигм программирования следует выделить – структурное программирование (язык C) и функциональное программирование (Haskell, F#, Clojure).

Основными строительными элементами ООП являются классы и объекты. аналогом класса в реальной жизни является некоторый шаблон. Объект – это непосредственно реализация класса в виде некоторой сущности.

Выделяют три основных “столпа” ООП- это инкапсуляция, наследование и полиморфизм.

## Инкапсуляция
Инкапсуляция предполагает два основных момента:

- сокрытие деталей реализации;
- связывание данных и методов для их обработки в одном месте.

Связываение данных и методов предполагает, что в рамках одного класса располагаются данные, определяющие некоторые свойства сущности (например, имя и возраст, если сущность – это человек), и методы для их обработки,  получения и изменения.

## Наследование
Наследование – это концепция, которая предполагает, что один класс может наследовать функции и данные другого класса. Класс, от которого производится наследование называется родительским или базовым классом, класс который наследует – наследником. Отношение между классом наследником и базовым классом можно определить словом “является”.

## Полиморфизм
Говоря про полиморфизм в общем, можно сказать, что это возможность обработки данных разных типов одной и той же функцией. Различают параметрический полиморфизм и ad–hoc полиморфизм. Параметрический полиморфизм предполагает, что один и тот же код в функции может работать с данными разных типов. Ad–hoc полиморфизм предполагает создание различных реализаций функций в зависимости от типа аргумента(ов), при этом их сигнатура (без учета типов входных аргументов) остается одной и той же.

## Классы
Класс в языке C# объявляется с помощью ключевого слова class перед ним могут стоять несколько модификаторов, после располагается имя класса. Если предполагается, что класс является наследником другого класса или реализует один или несколько интерфейсов, то они отделяются двоеточием от имени класса и перечисляются через запятую.
```c
class Building 
{
}

```
Внутри себя, класс может содержать методы, поля и свойства. Методы похожи на функции из языков группы структурного программирования. Фактически они определяют то, как можно работать с данным классом или объектами класса. Поля – это переменные, связанные с данным классом, а свойства – это конструкции специального вида, которые упрощают работу с полями.
```c
class DemoClass
{
    // Поле класса
    int field = 0;
      
    // Свойство класса
    public int Property {get;set;}
      
    // Метод класса
    public void Method()
    {
        Console.WriteLine("Method");
    }
}

```
Объект класса создается также как переменная любого типа данных. класс является типом данных, который мы можем самостоятельно объявить. Все встроенные типы являются определенными классами, например, переменная типа int – это объект класса System.Int32.

Создадим объект класса DemoClass:
```c
// Создание объекта класса DemoClass
DemoClass demo = new DemoClass();
// Вызов метода Method объекта demo
demo.Method();

```

## Модификаторы доступа
Модификаторы доступа определяют область видимости как непосредственно самого класса, так и его составляющих (поля, свойства, методы).

В C# доступны следующие модификаторы доступа: public, private, protected, internal, protected internal, private protected. 

### Модификатор public:
- для класса: указывает на то, что класс доступен снаружи из сборки;
- для составляющих класса: указывает на то, что они могут быть доступны вне класса, к ним можно получить доступ из любого места в программе.
### Модификатор private:
- для класса: указывает на то, что класс доступен только внутри сборки.
- для составляющих класса: указывает на то, что они доступны только внутри класса.
Если модификатор не указан, то будет использован private.

## Конструктор класса
Конструктор класса – это специальный метод, который вызывается при инициализации объекта с помощью ключевого слова new. Имя конструктора должно совпадать с именем класса, в сигнатуре конструктора не указывается тип возвращаемого значения.

Вот так будет выглядеть самый простой вариант конструктора для класса DemoClass:
```c

// Конструктор класса
public DemoClass()
{}

```
Про конструктор класса нужно знать следующее:
- Конструктор можно не создавать явно, тогда для класса будет создан конструктор по умолчанию, он выглядит следующим образом:
```c
public DemoClass()
{}
```
- Конструкторов может быть несколько, они должны отличаться по количеству и типу принимаемых аргументов:
```c

public DemoClass(int field)
{
    this.field = field;
}
public DemoClass(int field, int prop)
{
    this.field = field;
    Property = prop;
}

```
Если вы создадите конструктор, который содержит набор аргументов, то конструктор по умолчанию уже не будет создан для класса. Если вы хотите создавать объекты без указания аргументов, то необходимо добавить в класс соответствующий конструктор.

## Инициализация объектов класса
Инициализация объекта класса производится с помощью ключевого слова new. Создадим объект класса DemoClass:
```c

DemoClass demo = new DemoClass();
```

Если у класса есть несколько конструкторов, то при инициализации можно выбрать один из существующих:
```c

DemoClass d2 = new DemoClass(1);
d2.Method(); // field: 1, Property: 0
DemoClass d3 = new DemoClass(1, 2);
d3.Method(); // field: 1, Property: 2

```
Доступна возможность использования неявного объявления с помощью ключевого слова  var:
```c

var d4 = new DemoClass();

```
Если у класса есть публичные свойства, то им можно присвоить значения при инициализации:
```c

var d5 = new DemoClass(10) { Property = 11 };
d5.Method(); // field: 10, Property: 11

```
## Методы
Методом класса называют функцию или процедуру, которая принадлежит классу или объекту. Отличие функции от процедуры в том, что функция возвращает значение, а процедура нет. В общем виде синтаксис объявления метода выглядит следующим образом:

### модификатор(ы) тип_возвращаемого_значения имя_функции(аргументы)

Модификаторы определяют область видимости, принадлежность метода объекту или классу, является ли метод переопределением и т.п. Тип возвращаемого значения – это любой доступный в C# тип. В качестве типа возвращаемого значения не может использоваться ключевое слово var. Если метод не возвращает ничего, то указывается тип void. Метод может содержать ноль или более аргументов, которые также могут иметь специальные модификаторы, указывающие на то является ли аргумент входным или выходным и т.п. 

## Работа с модификатором доступа
Если метод объявлен с модификатором public, то его можно использовать вне класса, например метод Printer из DemoClass:
```c

public void Printer()
{
    Console.WriteLine($"field: {field}, Property: {Property}");
}
```
Такой метод может вызываться в любом месте программы у соответствующих объектов:
```c

var d6 = new DemoClass(11) { Property = 12 };
d6.Printer(); // field: 11, Property: 12

```
Если мы объявим метод с модификатором private или без модификатора (тогда, по умолчанию, будет принят private), то его уже нельзя будет вызвать снаружи класса:
```c

class DemoClass 
{ 
    // ... 
    private void PrivateMethod() 
    { 
        Console.WriteLine($"Secret method"); 
    } 
    // ... 
}

```
(Код в методе Main):
```c

var d7 = new DemoClass();
d7.PrivateMethod(); // Ошибка компиляции!!!

```
Но при этом внутри класса его вызвать можно:
```c

class DemoClass
{
    // ... 
    public void PublicMethod() 
    { 
        Console.WriteLine($"Public method");     
        PrivateMethod(); 
    } 
    // ... 
}

```
## Статические методы и методы объекта
Различают статические методы и методы объекта. 
Статические имеют модификатор static перед именем метода и принадлежат классу. Для вызова таких методов не обязательно создавать экземпляры класса, мы уже пользовались такими методами из класса Console – это методы Write и WriteLine. 
Для вызова метода объекта, необходимо предварительно создать экземпляр класса, пример – это метод PublicMethod и Priter у класса DemoClass. Добавим статический метод и метод класса в DemoClass:
```c

class DemoClass
{
    // ...
    public static void StaticMethod()
    {
        Console.WriteLine("Message from static method");
    }
    public void NoneStaticMethod()
    {
        Console.WriteLine("Message from non static method");
    }
    // ...
}

```
Вызовем эти методы из класса DemoClass в методе Main:
```c

DemoClass.StaticMethod(); // Message from static method
var d8 = new DemoClass();
d8.NoneStaticMethod(); // Message from none static method

```
## Методы принимающие аргументы и возвращающие значения
методы могут принимать данные через аргументы и возвращать значения:
```c

class DemoClass 
{ 
    // ... 
    public int MulField(int value) 
    { 
        return field * value; 
    } 
    // ... 
}

```
(Код в Main):
```c

var d8 = new DemoClass(10);
Console.WriteLine($"MulField() result: {d8.MulField(2)}"); // MulField() result: 20

```
## Поля
Поле представляет собой переменную любого типа, объявленную внутри класса. Через модификатор доступа можно управлять уровнем доступа к полю (так же как для методов), через ключевое слово static можно определять принадлежность поля объекту либо классу:
```c

class DemoClass 
{ 
    // ... 
    int field = 0; 
    public int publicField = 0; 
    public static int publicStaticField = 0; 
    // ...
}

```
(Код в Main):
```c


var d9 = new DemoClass();
// Доступ к private полям запрещен
// Console.WriteLine($"Get private field: {d9.field}"); // Compile ERROR           
// Доступ к полю объекта
d9.publicField = 123;
Console.WriteLine($"Get public field: {d9.publicField}"); // Get public field: 123
// Доступ к статическому полю класса
DemoClass.publicStaticField = 456;
Console.WriteLine($"Get public static field: {DemoClass.publicStaticField}"); // Get public static field: 456
```
Работать с открытыми полями напрямую (поля, которые имеют модификатор public) является плохой практикой. Если необходимо читать и изменять значение какого-либо поля, то лучше это делать через getter’ы и setter’ы – специальные методы, которые выполняют эту работу.

Создадим для класса Building методы для доступа и модификации значения поля height:
```c

class Building 
{ 
    float height;
    public float GetHeight() => height;
    public float SetHeight(float height) => this.height = height; 
}

```
Для работы с этим классом воспользуемся следующим кодом:
```c

var b1 = new Building();
b1.SetHeight(12);
Console.WriteLine($"Height of building: {b1.GetHeight()}");

```
Создание специальных методов для работы с полями – возможный вариант, но в C# принят подход работы через свойства.

## Свойства
Основная причина создания getter’ов и setter’ов – это внедрение дополнительной логики, которая может потребоваться перед тем как выдать значение поля или присвоить ему новое значение. Для упрощения процесса решения такой задачи язык C# предлагает альтернативу – Свойства. 
С точки зрения пользователя класса работа с свойствами похожа на работу с открытыми полями. Но внутри, “под капотом”, это организовано так, что мы можем добавлять логику при чтении и записи.

Добавим в класс Building следующую конструкцию:
```c

public float Height
{
    get => height;
    set => height = value;
}

```
Она описывает свойство Height. У свойства есть два ключевых слова – это get, оно определяет блок кода, который выполнится при чтении значения свойства, и set – выполнится при присвоении значения свойству. Причем, при необходимости, объявить можно только одно из них, например, если у свойства будет только get, то ему нельзя будет присвоить значение.

Для демонстрации работы с этим свойством напишем следующий код:
```c

var b2 = new Building();
b2.Height = 456;
Console.WriteLine($"Height of building: {b2.Height}"); // Height of building: 456

```
Если для поля не предполагается, в текущий момент, какой-то дополнительной логики обработки при работе с ним, и это поле должно быть открытым, то в любом случае, лучший  вариант – сделать свойство с пустыми get и set, так как в будущем ситуация может измениться. Добавим в наш класс Building ещё два свойства, которые пока не связаны с какими-то конкретными полями:
```c

public float Width { get; set; }
public float Length { get; set; }

```
С ними можно работать также как и с Height.

## Ключевое слово this
Ключевое слово this используется внутри класса для ссылки на текущий экземпляр класса. Чаще всего его приходится использовать в методах для доступа к полям класса. Например, если у класса Building, с которым мы работали в предыдущем разделе, есть поле height, метод SetHeight был создан нами для того, чтобы присваивать этому полю значение, аргумент этого метода – переменная с именем height:
```c

float SetHeight(float height)

```
В теле данного метода мы должны как-то явно задать, что значение этого аргумента будет присвоено приватному полю height, записать height = height мы не можем, так как в этом случае нет четкого понимания, что чему будет присваиваться. В этом случае, для явного указания, что мы хотим присвоить значение полю класса, следует использовать ключевое слово this так, как мы это реализовали в методе SetHeight:
```c

public float SetHeight(float height) => this.height = height;

```
## Ключевое слово static
Если метод, поле или свойство имеет модификатор static, то это означает что они принадлежат уровню класса, а не объекту. То есть для работы с соответствующими элементами не нужно создавать экземпляр класса, можно работать напрямую через имя класса. Если класс объявлен с ключевым словом static, то такой класс называют статическим, он обладает следующими особенностями:
- у такого класса все методы должны быть статическими;
- его нельзя наследовать (класс является запечатанным);
- класс не может содержать конструкторы экземпляров;
- нельзя создавать экземпляры таких классов.
Примером статического класса может быть класс Math из стандартной библиотеки C#.

## Классы и объекты
 
C# является полноценным объектно-ориентированным языком. Это значит, что программу на C# можно представить в виде взаимосвязанных взаимодействующих между собой объектов.

Описанием объекта является класс, а объект представляет экземпляр этого класса. Можно еще провести следующую аналогию. У нас у всех есть некоторое представление о человеке, у которого есть имя, возраст, какие-то другие характеристики. То есть некоторый шаблон - этот шаблон можно назвать классом. Конкретное воплощение этого шаблона может отличаться, например, одни люди имеют одно имя, другие - другое имя. И реально существующий человек (фактически экземпляр данного класса) будет представлять объект этого класса.

По сути класс представляет новый тип, который определяется пользователем. Класс определяется с помощью ключевого слова сlass:
```c

class Person
{
 
}

```
Класс можно определять внутри пространства имен, вне пространства имен, внутри другого класса. Как правило, классы помещаются в отдельные файлы:
```c

using System;
 
namespace HelloApp
{
    class Person
    {
         
    }
    class Program
    {
        static void Main(string[] args)
        {
             
        }
    }
}

```
Вся функциональность класса представлена его членами - полями (полями называются переменные класса), свойствами, методами, событиями. Например, определим в классе Person поля и метод:
```c

using System;
 
namespace HelloApp
{
    class Person
    {
        public string name; // имя
        public int age = 18;     // возраст
 
        public void GetInfo()
        {
            Console.WriteLine($"Имя: {name}  Возраст: {age}");
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            Person tom;
        }
    }
}
```
В данном случае класс Person представляет человека. Поле name хранит имя, а поле age - возраст человека. А метод GetInfo выводит все данные на консоль. Чтобы все данные были доступны вне класса Person переменные и метод определены с модификатором public. Поскольку поля фактически те же переменные, им можно присвоить начальные значения, как в случае выше, поле age инициализировано значением 18.

Так как класс представляет собой новый тип, то в программе мы можем определять переменные, которые представляют данный тип. Так, здесь в методе Main определена переменная tom, которая представляет класс Person. Но пока эта переменная не указывает ни на какой объект и по умолчанию она имеет значение null. Поэтому вначале необходимо создать объект класса Person.

## Конструкторы
Кроме обычных методов в классах используются также и специальные методы, которые называются конструкторами. Конструкторы вызываются при создании нового объекта данного класса. Конструкторы выполняют инициализацию объекта.

## Конструктор по умолчанию
Если в классе не определено ни одного конструктора, то для этого класса автоматически создается конструктор по умолчанию. Такой конструктор не имеет параметров и не имеет тела.

класс Person не имеет никаких конструкторов. Поэтому для него автоматически создается конструктор по умолчанию. И мы можем использовать этот конструктор. В частности, создадим один объект класса Person:
```c

class Person
{
    public string name; // имя
    public int age;     // возраст
 
    public void GetInfo()
    {
        Console.WriteLine($"Имя: {name}  Возраст: {age}");
    }
}
class Program
{
    static void Main(string[] args)
    {
        Person tom = new Person();
        tom.GetInfo();      // Имя: Возраст: 0
 
        tom.name = "Tom";
        tom.age = 34;
        tom.GetInfo();  // Имя: Tom Возраст: 34
        Console.ReadKey();
    }
}

```
Для создания объекта Person используется выражение new Person(). Оператор new выделяет память для объекта Person. И затем вызывается конструктор по умолчанию, который не принимает никаких параметров. В итоге после выполнения данного выражения в памяти будет выделен участок, где будут храниться все данные объекта Person. А переменная tom получит ссылку на созданный объект.

Если конструктор не инициализирует значения переменных объекта, то они получают значения по умолчанию. Для переменных числовых типов это число 0, а для типа string и классов - это значение null (то есть фактически отсутствие значения).

После создания объекта мы можем обратиться к переменным объекта Person через переменную tom и установить или получить их значения, например, tom.name = "Tom";.


## Создание конструкторов
мы сами можем определить свои конструкторы:
```c

class Person
{
    public string name;
    public int age;
 
    public Person() { name = "Неизвестно"; age = 18; }      // 1 конструктор
     
    public Person(string n) { name = n; age = 18; }         // 2 конструктор
     
    public Person(string n, int a) { name = n; age = a; }   // 3 конструктор
     
    public void GetInfo()
    {
        Console.WriteLine($"Имя: {name}  Возраст: {age}");
    }
}

```
Теперь в классе определено три конструктора, каждый из которых принимает различное количество параметров и устанавливает значения полей класса. Используем эти конструкторы:
```c


static void Main(string[] args)
{
    Person tom = new Person();          // вызов 1-ого конструктора без параметров
    Person bob = new Person("Bob");     //вызов 2-ого конструктора с одним параметром
    Person sam = new Person("Sam", 25); // вызов 3-его конструктора с двумя параметрами
     
     
    bob.GetInfo();          // Имя: Bob  Возраст: 18
    tom.GetInfo();          // Имя: Неизвестно  Возраст: 18
    sam.GetInfo();          // Имя: Sam  Возраст: 25
}

```

При этом если в классе определены конструкторы, то при создании объекта необходимо использовать один из этих конструкторов.

начиная с версии C# 9.0 мы можем сократить вызов конструктора, убрав из него название типа:
```c

Person tom = new ();            // аналогично new Person();
Person bob = new ("Bob");       // аналогично new Person("Bob");
Person sam = new ("Sam", 25);   // аналогично new Person("Sam", 25);

```
## Ключевое слово this
Ключевое слово this представляет ссылку на текущий экземпляр класса. В каких ситуациях оно нам может пригодиться? В примере выше определены три конструктора. Все три конструктора выполняют однотипные действия - устанавливают значения полей name и age. Но этих повторяющихся действий могло быть больше. И мы можем не дублировать функциональность конструкторов, а просто обращаться из одного конструктора к другому через ключевое слово this, передавая нужные значения для параметров:
```c

class Person
{
    public string name;
    public int age;
 
    public Person() : this("Неизвестно")
    {
    }
    public Person(string name) : this(name, 18)
    {
    }
    public Person(string name, int age)
    {
        this.name = name;
        this.age = age;
    }
    public void GetInfo()
    {
        Console.WriteLine($"Имя: {name}  Возраст: {age}");
    }
}

```
В данном случае первый конструктор вызывает второй, а второй конструктор вызывает третий. По количеству и типу параметров компилятор узнает, какой именно конструктор вызывается. Например, во втором конструкторе:
```c

public Person(string name) : this(name, 18)
{
}

```
идет обращение к третьему конструктору, которому передаются два значения. Причем в начале будет выполняться именно третий конструктор, и только потом код второго конструктора.

Также стоит отметить, что в третьем конструкторе параметры называются также, как и поля класса.
```c

public Person(string name, int age)
{
    this.name = name;
    this.age = age;
}

```
И чтобы разграничить параметры и поля класса, к полям класса обращение идет через ключевое слово this. Так, в выражении this.name = name; первая часть this.name означает, что name - это поле текущего класса, а не название параметра name. Если бы у нас параметры и поля назывались по-разному, то использовать слово this было бы необязательно. Также через ключевое слово this можно обращаться к любому полю или методу.

## Инициализаторы объектов
Для инициализации объектов классов можно применять инициализаторы. Инициализаторы представляют передачу в фигурных скобках значений доступным полям и свойствам объекта:
```c

Person tom = new Person { name = "Tom", age=31 };
tom.GetInfo();          // Имя: Tom  Возраст: 31

```
С помощью инициализатора объектов можно присваивать значения всем доступным полям и свойствам объекта в момент создания без явного вызова конструктора.

При использовании инициализаторов следует учитывать следующие моменты:
- С помощью инициализатора мы можем установить значения только доступных из внешнего кода полей и свойств объекта. Например, в примере выше поля name и age имеют модификатор доступа public, поэтому они доступны из любой части программы.
- Инициализатор выполняется после конструктора, поэтому если и в конструкторе, и в инициализаторе устанавливаются значения одних и тех же полей и свойств, то значения, устанавливаемые в конструкторе, заменяются значениями из инициализатора.

## Структуры
 
Наряду с классами структуры представляют еще один способ создания собственных типов данных в C#. Более того многие примитивные типы, например, int, double и т.д., по сути являются структурами.

Например, определим структуру, которая представляет человека:
```c

struct User
{
    public string name;
    public int age;
 
    public void DisplayInfo()
    {
        Console.WriteLine($"Name: {name}  Age: {age}");
    }
}

```
Как и классы, структуры могут хранить состояние в виде переменных и определять поведение в виде методов. Так, в данном случае определены две переменные - name и age для хранения соответственно имени и возраста человека и метод DisplayInfo для вывода информации о человеке.

Используем эту структуру в программе:
```c

using System;
 
namespace HelloApp
{ 
    struct User
    {
        public string name;
        public int age;
 
        public void DisplayInfo()
        {
            Console.WriteLine($"Name: {name}  Age: {age}");
        }
    }
 
    class Program
    {
        static void Main(string[] args)
        {
            User tom;
            tom.name = "Tom";
            tom.age = 34;
            tom.DisplayInfo();
             
            Console.ReadKey();
        }
    }
}

```
В данном случае создается объект tom. У него устанавливаются значения глобальных переменных, и затем выводится информация о нем.

## Конструкторы структуры
Как и класс, структура может определять конструкторы. Но в отличие от класса нам не обязательно вызывать конструктор для создания объекта структуры:

User tom;

Однако если мы таким образом создаем объект структуры, то обязательно надо проинициализировать все поля (глобальные переменные) структуры перед получением их значений или перед вызовом методов структуры. То есть, например, в следующем случае мы получим ошибку, так как обращение к полям и методам происходит до присвоения им начальных значений:
```c

User tom;
int x = tom.age;    // Ошибка
tom.DisplayInfo();  // Ошибка

```
Также мы можем использовать для создания структуры конструктор без параметров, который есть в структуре по умолчанию и при вызове которого полям структуры будет присвоено значение по умолчанию (например, для числовых типов это число 0):
```c

User tom = new User();
tom.DisplayInfo();  // Name:   Age: 0

```
Обратите внимание, что при использовании конструктора по умолчанию нам не надо явным образом иницилизировать поля структуры.

Также мы можем определить свои конструкторы. Например, изменим структуру User:
```c

using System;
 
namespace HelloApp
{
    struct User
    {
        public string name;
        public int age;
        public User(string name, int age)
        {
            this.name = name;
            this.age = age;
        }
        public void DisplayInfo()
        {
            Console.WriteLine($"Name: {name}  Age: {age}");
        }
    }
 
    class Program
    {
        static void Main(string[] args)
        {
            User tom = new User("Tom", 34);
            tom.DisplayInfo();
 
            User bob = new User();
            bob.DisplayInfo();
             
            Console.ReadKey();
        }
    }
}

```
Важно учитывать, что если мы определяем конструктор в структуре, то он должен инициализировать все поля структуры, как в данном случае устанавливаются значения для переменных name и age.

Также, как и для класса, можно использовать инициализатор для создания структуры:
```c

User person = new User { name = "Sam", age = 31 };

```
Но в отличие от класса нельзя инициализировать поля структуры напрямую при их объявлении, например, следующим образом:
```c

struct User
{
    public string name = "Sam";     // ! Ошибка
    public int age = 23;            // ! Ошибка
    public void DisplayInfo()
    {
        Console.WriteLine($"Name: {name}  Age: {age}");
    }
}

```