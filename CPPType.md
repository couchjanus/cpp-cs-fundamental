# Структура программы C++
  
## Инструкции
Программа на С++ состоит из набора инструкций. Каждая инструкция (statement) выполняет определенное действие. В конце инструкции в языке C++ ставится точка с запятой (;). Данный знак указывает компилятору на завершение инструкции. Например:
```cpp
std::cout << "Hello World!";
```
Данная строка выводит на консоль строку "Hello world!", является инструкцией и поэтому завершается точкой с запятой.

Набор инструкций может представлять блок кода. Блок кода заключается в фигурные скобки, а инструкции помещаются между открывающей и закрывающей фигурными скобками:
```cpp
{
    std::cout << "Hello World!";
    std::cout << "Bye World!";
}   
```
В этом блоке кода две инструкции, которые выводят на консоль определенную строку.

## Функция main
Каждая программа на языке С++ должна иметь как минимум одну функцию - функцию main(). Именно с этой функции начинается выполнение приложения. Ее имя main фиксировано и для всех программ на Си всегда одинаково.

Функция также является блоком кода, поэтому ее тело обрамляется фигурными скобками, между которыми определяется набор инструкций.
```cpp


#include <iostream>               // подключаем заголовочный файл iostream
  
int main()                          // определяем функцию main
{                                   // начало функции
    std::cout << "Hello World!";   // выводим строку на консоль
    return 0;                       // выходим из функции
}                                   // конец функции
```
Определение функии main начинается с возвращаемого типа. Функция main в любом случае должна возвращать число. Поэтому ее определение начинается с ключевого слова int.

Далее идет название функции, то есть main. После названия в скобках идет список параметров. В данном случае функция main не принимает никаких параметров, поэтому после названия указаны пустые скобки. 
Есть другие варианты определения функции main, которые подразумевыют использование параметров:
```cpp

int main (int argc, char *argv[]) 
{
     
} 

```
И после списка параметров идет блок кода, который и содержит в виде инструкций те действия, выполняемые функцией main.

## Директивы препроцессора
Чтобы использовать вывод на консоль, необходимо в начале файла с исходным кодом подключать библиотеку iostream с помощью директивы include.

Директива include является директивой препроцессора. Каждая директива препроцессора размещается на одной строке. И в отличие от обычных инструкциий языка C++, которые завершаются точкой с запятой ; , признаком завершения препроцессорной директивы является перевод на новую строку. Кроме того, директива должна начинаться со знака решетки #. Непосредственно директива "include" определяет, какие файлы и библиотеки надо подключить в данном месте в код программы.

## Комментарии
Исходный код может содержать комментарии. Комментарии позволяют понять смыл программы, что делают те или иные ее части. При компиляции комментарии игнорируются и не оказывают никакого влияние на работу приложения и на его размер.

В языке C++ есть два типа комментариев: однострочный и многострочный. Однострочный комментарий размещается на одной строке после двойного слеша //:
```cpp
#include <iostream>               // подключаем библиотеку iostream
  
int main()                          // определяем функцию main
{                                   // начало функции
    std::cout << "Hello World!";   // выводим строку на консоль
    return 0;                       // выходим из функции
}                                   // конец функции

```
Многострочный комментарий заключается между символами 
```cpp
/* текст комментария */
```
Он может размещаться на нескольких строках. Например:
```cpp
#include <iostream>
/*
    Определение функции Main
    Выводит на консоль строку Hello World!
*/
int main()
{
    std::cout << "Hello World!"; // вывод строки на консоль
    return 0;
}
```
## Переменные
 
В C++ для хранения данных используются переменные. Переменная имеет тип, имя и значение. Тип определяет, какую информацию может хранить переменная.

Перед использованием любую переменную надо определить. Синтаксис определения переменной выглядит следующим образом: тип_переменной имя_переменной;
Простейшее определение переменной: int age;
Поскольку определение переменной представляет собой инструкцию, то после него ставится точка с запятой.

C++ - регистрозависимый язык, а это значит, что регистр символов имеет большое значение. То есть в следующем коде будут определяться две разные переменные:
```cpp
int age;
int Age;

```
В качестве имени переменной нельзя использовать ключевые слова языке C++, например, for или if. Но таких слов не так много: alignas, alignof, asm, auto, bool, break, case, catch, char, char16_t, char32_t, class, const, constexpr, const_cast, continue, decltype, default, delete, do, double, dynamic_cast, else, enum, explicit, export, extern, false, float, for, friend, goto, if, inline, int, long, mutubale, namespace, new, noexcept, nullptr, operator, private, protected, public, register, reinterpret_cast, return, short, signed, sizeof, static, static_assert, static_cast, struct, switch, template, this, thread_local, throw, true, try, typedef, typeid, typename, union, unsigned, using, virtual, void, volatile, wchar_t, while.

Также нельзя объявить больше одной переменной с одним и тем же именем, например:
```cpp
int age;
int age;
// Подобное определение вызовет ошибку на этапе компиляции.
```
## Инициализация
После определения переменной можно присвоить некоторое значение:
```cpp
int age;
age = 20;
```
Например, определим в прогамме переменную и выведем ее значение на консоль:
```cpp
#include <iostream>
 
int main()
{
    int age;
    age = 28;
    std::cout<<"Age = " << age;
    return 0;
}
```
С помощью последовательности операторов << можно вывести несколько значений на консоль.

Также можно сразу при определении переменной дать ей начальное значение. Данный прием называется инициализацией, то есть присвоение переменной начального значения:
```cpp
#include <iostream>
 
int main()
{
    int age = 28;
    std::cout<<"Age = " << age;
    return 0;
}
```
## Инициализация по умолчанию
Если переменную не инициализировать, то происходит ее инициализация по умолчанию. И переменная получает некоторое значение по умолчанию, которое зависит от места, где эта переменная определена.

Если переменная, которая представляет встроенный тип (например, тип int), определена внутри функции, то она получает неопределенное значение. Если переменная встроенного типа определена вне функции, то она получает то значение по умолчанию, которое соответствует ее типу. Для числовых типов это число 0:
```cpp
#include <iostream>
 
int x;
int main()
{
    int y;
    std::cout <<"X = " << x << "\n";
    std::cout <<"Y = " << y;
     
    return 0;
}
```
Переменная x определена вне функции, и поэтому она получит значение по умолчанию - число 0.

Гораздо сложнее дело обстоит с переменной y, которая определена внутри функции main - ее значение будет неопределенным, и многое будет зависеть от используемого компилятора. В частности, вывод программы, скомпилированной с помощью компилятора G++, может выглядеть следующим образом:
```cpp
X = 0
Y = 4200475

```
А в Visual Studio отсутствие значения переменной y вызовет ошибку.

В любом случае перед использованием переменной лучше явным образом назначать ей определенное значение, а не полагаться на значение по умолчанию.

## Изменение значения
Ключевой особенностью переменных является то, что мы можем изменять их значения:
```cpp
#include <iostream>
 
int main()
{
    int x = 6;
    x = 8;
    x = 10;
    std::cout <<"X = " << x; // X = 10
     
    return 0;
}

```
## Типы данных
 
Каждая переменная имеет определенный тип. И этот тип определяет, какие значения может иметь переменная, какие операции с ней можно производить и сколько байт в памяти она будет занимать. 
В языке C++ определены следующие базовые типы данных:
- bool: логический тип. Может принимать одну из двух значений true (истина) и false (ложь). Размер занимаемой памяти для этого типа точно не определен.
- char: представляет один символ в кодировке ASCII. Занимает в памяти 1 байт (8 бит). Может хранить любое значение из диапазона от -128 до 127, либо от 0 до 255
- signed char: представляет один символ. Занимает в памяти 1 байт (8 бит). Может хранить любой значение из диапазона от -128 до 127
- unsigned char: представляет один символ. Занимает в памяти 1 байт (8 бит). Может хранить любой значение из диапазона от 0 до 255
- wchar_t: представляет расширенный символ. На Windows занимает в памяти 2 байта (16 бит), на Linux - 4 байта (32 бита). Может хранить любой значение из диапазона от 0 до 65 535 (при 2 байтах), либо от 0 до 4 294 967 295 (для 4 байт)
- char16_t: представляет один символ в кодировке Unicode. Занимает в памяти 2 байта (16 бит). Может хранить любой значение из диапазона от 0 до 65 535
- char32_t: представляет один символ в кодировке Unicode. Занимает в памяти 4 байта (32 бита). Может хранить любой значение из диапазона от 0 до 4 294 967 295
- short: представляет целое число в диапазоне от –32768 до 32767. Занимает в памяти 2 байта (16 бит). Данный тип также имеет синонимы short int, signed short int, signed short.
- unsigned short: представляет целое число в диапазоне от 0 до 65535. Занимает в памяти 2 байта (16 бит). Данный тип также имеет синоним unsigned short int.
- int: представляет целое число. В зависимости от архитектуры процессора может занимать 2 байта (16 бит) или 4 байта (32 бита). Диапазон предельных значений соответственно также может варьироваться от –32768 до 32767 (при 2 байтах) или от −2 147 483 648 до 2 147 483 647 (при 4 байтах). Но в любом случае размер должен быть больше или равен размеру типа short и меньше или равен размеру типа long Данный тип имеет синонимы signed int и signed.
- unsigned int: представляет положительное целое число. В зависимости от архитектуры процессора может занимать 2 байта (16 бит) или 4 байта (32 бита), и из-за этого диапазон предельных значений может меняться: от 0 до 65535 (для 2 байт), либо от 0 до 4 294 967 295 (для 4 байт). В качестве синонима этого типа может использоваться unsigned
- long: представляет целое число в диапазоне от −2 147 483 648 до 2 147 483 647. Занимает в памяти 4 байта (32 бита). У данного типа также есть синонимы long int, signed long int и signed long
- unsigned long: представляет целое число в диапазоне от 0 до 4 294 967 295. Занимает в памяти 4 байта (32 бита). Имеет синоним unsigned long int.
- long long: представляет целое число в диапазоне от −9 223 372 036 854 775 808 до +9 223 372 036 854 775 807. Занимает в памяти, как правило, 8 байт (64 бита). Имеет синонимы long long int, signed long long int и signed long long.
- unsigned long long: представляет целое число в диапазоне от 0 до 18 446 744 073 709 551 615. Занимает в памяти, как правило, 8 байт (64 бита). Имеет синоним unsigned long long int.
- float: представляет вещественное число ординарной точности с плавающей точкой в диапазоне +/- 3.4E-38 до 3.4E+38. В памяти занимает 4 байта (32 бита)
- double: представляет вещественное число двойной точности с плавающей точкой в диапазоне +/- 1.7E-308 до 1.7E+308. В памяти занимает 8 байт (64 бита)
- long double: представляет вещественное число двойной точности с плавающей точкой не менее 8 байт (64 бит). В зависимости от размера занимаемой памяти может отличаться диапазон допустимых значений.
- void: тип без значения

Все типы данных за исключением void могут быть разделены на три группы: 
1. символьные (char, wchar_t, char16_t, char32_t), 
2. целочисленные (short, int, long, long long) 
3. типы чисел с плавающей точкой (float, double, long double).

## Символьные типы
Для представления символов в приложении используются типы char, wchar_t, char16_t и char32_t.

Определим несколько переменных:
```cpp
char c ='d';
wchar_t d ='c';
```
Переменная типа char в качестве значения принимает один символ в одинарных кавычках: char c ='d'. Также можно присвоить число из указанного в списке диапазона: char c = 120. В этом случае значением переменной c будет тот символ, который имеет код 120 в таблице символов ASCII.

Для вывода на консоль символов wchar_t следует использовать не std::cout, а поток std::wcout:
```cpp
#include <iostream>
 
int main()
{
    char a = 'H';
    wchar_t b = 'e';
    std::wcout << a << b << '\n';
    return 0;
}
```
При этом поток std::wcout может работать как с char, так и с wchar_t. А поток std::cout для переменной wchar_t вместо символа будет выводить его числовой код.

В стандарте С++11 были добавлены типы char16_t и char32_t, которые ориентированы на использование Unicode. Однако на уровне ОС пока не реализованы потоки для работы с этими типами. Поэтому если потребуется вывести на консоль значения переменных этих типов, то необходимо преобразовать переменные к типам char или wchar_t:
```cpp
#include <iostream>
 
int main()
{
    char a = 'H';
    wchar_t b = 'e';
    char16_t c = 'l';
    char32_t d = 'o';
    std::cout << a << (char)b << (char)c << (char)d << "\n";
    return 0;
}
```
В данном случае при выводе перед переменными указывается операция приведения к типу char - (char), благодаря чему значения переменных b, c и d преобразуются в тип char и могут быть выведены на консоль с помощью потока std::cout.

## Целочисленные типы
Целочисленные типы представлены следующими типами: short, unsigned short, int, unsigned int, long, unsigned long, long long и unsigned long long:
```cpp
short a = -10;
unsigned short b= 10;
int c = -30;
unsigned int d = 60;
long e = -170;
unsigned long f = 45;
long long g = 89;
```
## Типы чисел с плавающей точкой
Типы чисел с плавающей точкой иили дробные числа представлены такими типами как float, double и long double:
```cpp
float a = -10.45;
double b = 0.00105;
long double c = 30.890045;
```
## Размеры типов данных
Для каждого типа указан размер, который он занимает в памяти. Предельные размеры для типов разработчики компиляторов могут выбирать самостоятельно, исходя из аппаратных возможностей компьютера. Стандарт устанавливает лишь минимальные значения, которые должны быть. Например, для типов int и short минимальное значение - 16 бит, для типа long - 32 бита, для типа long double. При этом размер типа long должен быть не меньше размера типа int, а размер типа int - не меньше размера типа short, а размер типа long double должен быть больше double. К примеру, компилятор g++ под Windows для long double использует 12 байт, а компилятор, встроенный в Visual Studio и также работающий под Windows, для long double использует 8 байт.

Однако бывают ситуации, когда необходимо точно знать размер определенного типа. Для этого в С++ есть оператор sizeof(), который возвращает размер памяти в байтах, которую занимает переменная:
```cpp
#include <iostream>
 
int main()
{
    long double number = 2;
    std::cout << "sizeof(number) =" << sizeof(number);
    return 0;
}
```
Консольный вывод при компиляции в g++:
```cpp
sizeof(number) = 12
// При этом при определении переменных важно понимать, что значение переменной не должно выходить за те пределы, которые очерчены для ее типа. Например:
unsigned short number = -65535;
// Компилятор G++ при компиляции программы с этой строкой выдаст ошибку о том, что значение -65535 не входит в диапазон допустимых значений для типа unsigned short и будет усечено.
```
В Visual Studio компиляция может пройти без ошибок, однако при этом переменная number получит значение 2 - результат преобразования числа -65535 к типу unsigned short. Значение переменной - это всего лишь набор битов в памяти, которые интерпретируются в соответствии с определенным типом. Для разных типов один и тот же набор битов может интерпретироваться по разному. Поэтому важно учитывать диапазоны значений для того или иного типа при присвоении переменной значения.

## Спецификатор auto
Иногда бывает трудно определить тип выражения. Согласно последним стандартам можно предоставить компилятору самому выводить тип объекта. Для этого применяется спецификатор auto. При этом если мы определяем переменную со спецификатором auto, эта переменная должна быть обязательно инициализирована каким-либо значением:
```cpp
auto number = 5;
```
На основании присвоенного значения компилятор выведет тип переменной. Неинициализированные переменные со спецификатором auto не допускаются:
```cpp
auto number;
```
## Статическая типизация и преобразования типов
 
С++ является статически типизированным языком программирования. То есть если мы определили для переменной какой-то тип данных, то в последующем мы этот тип изменить не сможем. Соответственно переменная может получить значения только того типа, который она представляет. 
Нередко возникает необходимость присвоить переменной значения каких-то других типов. И в этом случае применяются преобразования типов.

Ряд преобразований компилятор может производить неявно, то есть автоматически:
```cpp
#include <iostream>
 
int main()
{
    int code = 'g';
    char letter = 103;
    std::cout << letter << " in ASCII is " << code << "\n";
    return 0;
}
```
В данном случае числовой переменной типа int присваивается символ 'g'. Этот символ будет автоматически преобразовываться в число. По факту переменная получит числовой код этого символа в таблице ASCII.

Переменной letter, наоборот, присваивается число, хотя эта переменная представляет тип char. Это число будет преобразовываться в символ, и в итоге переменная letter будет хранить символ, чей код в таблице ASCII равен 103, то есть символ 'g'.

## Как выполняются преобразования:

Переменной типа bool присваивается значение другого типа. В этом случае переменная получает false, если значение равно 0. Во всех остальных случаях переменная получает true.
```cpp
bool a = 1;     // true
bool b = 0;     // false
bool c = 'g'; // true
bool d = 3.4;   // true
```
Числовой или символьной переменной присваивается значение типа bool. В этом случае переменная получает 1, если значений равно true, либо получает 0, если присваиваемое значение равно false.
```cpp
int c = true;       // 1
double d = false;   // 0
```
Целочисленной переменной присваивается дробное число. В этом случае дробная часть после запятой отбрасывается.
```cpp
int a = 3.4;        // 3
int b = 3.6;        // 3
```
Переменной, которая представляет тип с плавающей точкой, присваивается целое число. В этом случае если целое число содержит больше битов, чем может вместить тип переменной, то часть информации усекается.
```cpp
float a = 35005;                // 35005
double b = 3500500000033;       // 3.5005e+012
```
Переменной беззнакового типа (unsigned) присваивается значение не из его диапазона. В этом случае результатом будет остаток от деления по модулю. Например, тип unsigned char может хранить значения от 0 до 255. Если присвоить ему значение вне этого диапазона, то компилятор присвоит ему остаток от деления по модулю 256 (так как тип unsigned char может хранить 256 значений). Так, при присвоении значения -1 переменная типа unsigned char получит 256 - |-1/256| = 255
```cpp
unsigned char a = -5;           // 251
unsigned short b = -3500;       // 62036 ()
unsigned int c = -50000000;     // 4244967296
```
Переменной знакового типа (signed) присваивается значение не из его диапазона. В этом случае результат не определен. Программа может работать нормально, выдавая адекватный результат, а может работать некорректно.

## Опасные и безопасные преобразования
Те преобразования, при которых не происходит потеря информации, являются безопасными. Как правило, это преобразования от типа с меньшей разрядностью к типу с большей разрядностью. В частности, это следующие цепочки преобразований:
```cpp
bool -> char -> short -> int -> double -> long double

bool -> char -> short -> int -> long -> long long

unsigned char -> unsigned short -> unsigned int -> unsigned long

float -> double -> long double
```
Примеры безопасных преобразований:
```cpp
short a = 'g'; // преобразование из char в short
int b = 10;
double c = b; // преобразование из int в double
float d = 3.4;
double e = d; // преобразование из float в double
double f = 35; // преобразование из int в double
```
Но также есть опасные преобразования. При подобных преобразованиях мы потенциально можем потерять точность данных. Как правило, это преобразования от типа с большей разрядностью к типу с меньшей разрядностью.
```cpp
char letter = 295;
std::cout << letter;
```
В данном случае переменной letter присваивается значение, которое выходит за пределы диапазона допустимых значений для типа char, то есть больше 255.

И в подобных примерах многое зависит от компилятора. В ряде случаев компиляторы при компиляции выдают предупреждение, тем не менее программа может быть успешно скомпилирована. В других случаях компиляторы не выдают никакого предупреждения. Собственно в этом и заключается опасность, что программа успешно компилируется, но тем не менее существует риск потери точности данных.

И, как правило, в подобных случаях при компиляции присваиваемое значение усекается до допустимого. Например, в примере выше число 295 будет сокращено до 39. То есть следующие переменные будут содержать одно и то же значение:
```cpp
char letter1 = 295;
char letter2 = 39;
```
## Константы
 
Отличительной особенностью переменных является то, что мы можем многократно в течение работы программы изменять их значение:
```cpp
int x = 7;
x = 9;
x = 5;
```
Кроме переменных в языке программирования C++ можно определять константы. Их значение устанавливается один раз и впоследствии мы его не можем изменить. Константа определяется практически также, как и переменная за тем исключением, что в начале определения константы идет ключевое слово const. Например:
```cpp
const int x = 22;
std::cout << x;
```
Если же мы захотим после определения константы присвоить ей некоторое значение, то компилятор не сможет скомпилировать программу и выведет ошибку:
```cpp
const int x = 22;
x = 78;
```
То есть такой код не будет работать. И так как нельзя изменить значения константы, то ее всегда необходимо инициализировать, если мы хотим, чтобы она имела некоторое значение.

Если константа не будет инициализирована, то компилятор также выведет ошибку и не сможет скомпилировать программу, как в следующем случае:
```cpp
const int x;
```
В качестве значения константам можно передавать как обычные литералы, так и динамически вычысляемые значения, например, значения переменных или других констант:
```cpp
int a = 10;
const int b = 7;
const int d = b;
const int x = a;
```
Обычно в качестве констант определяются такие значения, которые должны оставаться постоянными в течение работы всей программы и не могут быть изменены. Например, если программы выполняет математические операции с использованием числа PI, то было бы оптимально определить данные значение как константу, так как оно все равно неизменно.
## Арифметические операции
 
Арифметические операции производятся над числами. Значения, которые участвуют в операции, называются операндами. В языке программирования C++ арифметические операции бинарными (производятся над двумя операндами) и унарными (выполняются над одним операндом). 
К бинарным операциям относят следующие:
- + Операция сложения возвращает сумму двух чисел:
```cpp
int a = 10;
int b = 7;
int c = a + b;  // 17
int d = 4 + b;  // 11
```
- - Операция вычитания возвращает разность двух чисел:
```cpp
int a = 10;
int b = 7;
int c = a - b;  // 3
int d = 41 - b; // 34

```
- * Операция умножения возвращает произведение двух чисел:
```cpp
int a = 10;
int b = 7;
int c = a * b;  // 70
int d = b * 5;  // 35

```
- / Операция деления возвращает частное двух чисел:
```cpp
int a = 20;
int b = 5;
int c = a / b;  // 4
double d = 22.5 / 4.5;  // 5

```
При делении стоит быть внимательным, так как если в операции участвуют два целых числа, то результат деления будет округляться до целого числа, даже если результат присваивается переменной float или double:
```cpp
double k = 10 / 4;     // 2
std::cout << k;

```
Чтобы результат представлял числос плавающей точкой, один из операндов также должен представлять число с плавающей точкой:
```cpp
double k = 10.0 / 4;     // 2.5
std::cout << k;

```
- % Операция получения остатка от целочисленного деления:
```cpp
int a = 33;
int b = 5;
int c = a % b;  // 3
int d = 22 % 4; // 2 (22 - 4*5 = 2)

```
Также есть две унарные арифметические операции, которые производятся над одним числом: ++ (инкремент) и -- (декремент). Каждая из операций имеет две разновидности: префиксная и постфиксная:

## Префиксный инкремент.
Увеличивает значение переменной на единицу и полученный результат используется как значение выражения ++x
```cpp
int a = 8;
int b = ++a;
std::cout << a << "\n"; // 9
std::cout << b << "\n"; // 9

```
## Постфиксный инкремент.
Увеличивает значение переменной на единицу, но значением выражения x++ будет то, которое было до увеличения на единицу
```cpp
int a = 8;
int b = a++;
std::cout << a << "\n"; // 9
std::cout << b << "\n"; // 8

```
## Префиксный декремент.
Уменьшает значение переменной на единицу, и полученное значение используется как значение выражения --x
```cpp
int a = 8;
int b = --a;
std::cout << a << "\n"; // 7
std::cout << b << "\n"; // 7

```
## Постфиксный декремент.
Уменьшает значение переменной на единицу, но значением выражения x-- будет то, которое было до уменьшения на единицу
```cpp
int a = 8;
int b = a--;
std::cout << a << "\n"; // 7
std::cout << b << "\n"; // 8

```
Арифметические операции вычисляются слева направо. Одни операции имеют больший приоритет чем другие и поэтому выполняются вначале. Операции в порядке уменьшения приоритета:
- + (инкремент), - (декремент)
- * (умножение), / (деление), % (остаток от деления)
- + (сложение), - (вычитание)
Приоритет операций следует учитывать при выполнении набора арифметических выражений:
```cpp
int a = 8;
int b = 7;
int c = a + 5 * ++b;      // 48
std::cout << c;

```
Хотя операции выполняются слева направо, но вначале будет выполняться операция инкремента ++b, которая увеличит значение переменной b и возвратит его в качестве результата, так как эта операция имеет больший приоритет. Затем выполняется умножение 5 * ++b, и только в последнюю очередь выполняется сложение a + 5 * ++b

Скобки позволяют переопределить порядок вычислений:
```cpp
int a = 8;
int b = 7;
int c = (a + 5) * ++b;      // 104
std::cout << c;

```
Несмотря на то, что операция сложения имеет меньший приоритет, но вначале будет выполняться именно сложение, а не умножение, так как операция сложения заключена в скобки.
## Условные выражения
Условные выражения представляют собой некоторое условие и возвращают значение типа bool, то есть значение true (если условие истинно), либо значение false (если условие ложно). К условным выражениям относятся операции отношения и логические операции.

## Операции отношения
В языке программирования C++ есть следующие операции отношения:
- == Операция "равно". Возвращает true, если оба операнда равны, и false, если они не равны:
```cpp
int a = 10;
int b = 4;
bool c = a == b;    // false
bool d = a == 10;       // true

```
- > Операция "больше чем". Возвращает true, если первый операнд больше второго, и false, если первый операнд меньше второго:
```cpp
int a = 10;
int b = 4;
bool c = a > b;  // true

```
- < Операция "меньше чем". Возвращает true, если первый операнд меньше второго, и false, если первый операнд больше второго:
```cpp
bool c = 10 < 4; // false

```
- <= Операция "меньше или равно". Возвращает true, если первый операнд меньше или равен второму, и false, если первый операнд больше второго:
```cpp
bool c = 10 <= 4;    // false
bool d = 10 <= 14;   // true

```
- >= Операция "больше или равно". Возвращает true, если первый операнд больше или равен второму, и false, если первый операнд меньше второго:
```cpp
bool c = 10 >= 4;    // true
bool d = 10 >= 14;   // false

```
- != Операция "не равно". Возвращает true, если первый операнд не равен второму, и false, если оба операнда равны:
```cpp
bool c = 10 != 4;   // true
bool d = 4 != 4;    // false

```
Обычно операции отношения применяются в условных конструкциях типа if...else, которые будут рассмотрены далее.

## Логические операции
Логические операции обычно объединяют несколько операций отношения. 
К логическим операциям относят следующие:
- ! (операция отрицания)
Унарная операция, которая возвращает true, если операнд равен false. Если операнд равен true, операция возвращает false.
```cpp
bool a = true;
bool b = !a;    // false
bool c =!10<5;   // true

```
- && (конъюнкция, логическое умножение)
Возвращает true, если оба операнда не равны false. Возвращает false, если хотя бы один операнд равен false.
```cpp
bool a = true;
bool b = false;
bool c = a && b;    // false
bool d = a && true; // true

```
- || (дизъюнкция, логическое сложение)
Возвращает true, если хотя бы один операнд равен true. Возвращает false, если оба операнда равны false.
```cpp
bool a = true;
bool b = false;
bool c = a || b;        // true
bool d = b || false;    // false

```
Используем одновременно несколько логических операций и операций сравнения:

```cpp
#include <iostream>
 
int main()
{
    bool a = -2 > 5;             // false
    bool b = 0 < 7;              // true
    bool c = 10 > 5 && 7 < 11;    // true
    bool d = a && b || c;       // true
    std::cout << a << "\n";     // 0
    std::cout << b << "\n";     // 1
    std::cout << c << "\n";     // 1
    std::cout << d << "\n";     // 1
    return 0;
}

```
Следует обратить внимание, что на консоль выводится не непосредственно true или false, а их числовые эквиваленты - 1 для true и 0 для false.

И также стоит учитывать, что операции отношения имеют больший приоритет, чем логические операции. Поэтому в выражении 10 > 5 && 7 < 11 вначале будут выполняться подвыражения - операции отношения 10 > 5 и 7 < 11, а затем собственно операция логического умножения.
## Побитовые операции
Побитовые операции выполняются над отдельными разрядами или битами чисел. Данные операции производятся только над целыми числами.

## Операции сдвига
Каждое целое число в памяти представлено в виде определенного количества разрядов. И операции сдвига позволяют сдвинуть битовое представление числа на несколько разрядов вправо или влево. Операции сдвига применяются только к целочисленным операндам. 
Есть две операции:
- << Сдвигает битовое представление числа, представленного первым операндом, влево на определенное количество разрядов, которое задается вторым операндом.
- >> Сдвигает битовое представление числа вправо на определенное количество разрядов.

```cpp
int a = 2 << 2;           // 10  на два разрядов влево = 1000 - 8
int b = 16 >> 3;          // 10000 на три разряда вправо = 10 - 2

```
Число 2 в двоичном представлении 10. Если сдвинуть число 10 на два разряда влево, то получится 1000, что в десятичной системе равно число 8.

Число 16 в двоичном представлении 10000. Если сдвинуть число 10 на три разряда вправо (три последних разряда отбрасываются), то получится 10, что в десятичной системе представляет число 2.

## Поразрядные операции
Поразрядные операции также проводятся только над соответствующими разрядами целочисленных операндов:
- &: поразрядная конъюнкция (операция И или поразрядное умножение). Возвращает 1, если оба из соответствующих разрядов обоих чисел равны 1
- |: поразрядная дизъюнкция (операция ИЛИ или поразрядное сложение). Возвращает 1, если хотя бы один из соответствующих разрядов обоих чисел равен 1
- ^: поразрядное исключающее ИЛИ. Возвращает 1, если только один из соответствующих разрядов обоих чисел равен 1
- ~: поразрядное отрицание или инверсия. Инвертирует все разряды операнда. Если разряд равен 1, то он становится равен 0, а если он равен 0, то он получает значение 1.
```cpp
int a = 5 | 2;          // 101 | 010 = 111  - 7
int b = 6 & 2;          // 110 & 010 = 10  - 2
int c = 5 ^ 2;          // 101 ^ 010 = 111 - 7
int d = ~9;             // -10

```
Например, выражение 5 | 2 равно 7. Число 5 в двоичной записи равно 101, а число 2 - 10 или 010. Сложим соответствующие разряды обоих чисел. При сложении если хотя бы один разряд равен 1, то сумма обоих разрядов равна 1. Поэтому получаем:
```
1   0   1
0   1   0
1   1   1
```
В итоге получаем число 111, что в десятичной записи представляет число 7.

Возьмем другое выражение 6 & 2. Число 6 в двоичной записи равно 110, а число 2 - 10 или 010. Умножим соответствующие разряды обоих чисел. Произведение обоих разрядов равно 1, если оба этих разряда равны 1. Иначе произведение равно 0. Поэтому получаем:
```
1   1   0
0   1   0
0   1   0

```
Получаем число 010, что в десятичной системе равно 2.

## Операции присваивания

Операции присваивания позволяют присвоить некоторое значения. Эти операции выполняются над двумя операндами, причем левый операнд может представлять только модифицируемое именованное выражение, например, переменную.

Базовая операция присваивания = позволяет присвоить значение правого операнда левому операнду:
```cpp
int x; 
x = 2

```
То есть в данном случае переменная x (левый операнд) будет иметь значение 2 (правый операнд).

Стоит отметить, что тип значения правого операнда не всегда может совпадать с типом левого операнда. В этом случае компилятор пытается преобразовать значение правого операнда к типу левого операнда.

При этом операции присваивания имеют правосторонний порядок, то есть выполняются справа налево. И, таким образом, можно выполнять множественное присваивание:
```cpp
int a, b, c;    
a = b = c = 34;

```
Здесь сначала вычисляется значение выражения c = 34. Значение правого операнда - 34 присваивается левому операнду с. Далее вычисляется выражение b = c: значение правого операнда c (34) присваивается левому операнду b. И в конце вычисляется выражение a = b: значение правого операнда b (34) присваивается левому операнду a.

Кроме того, следует отметить, что операции присваивания имеют наименьший приоритет по сравнению с другими типами операций, поэтому выполняются в последнюю очередь:
```cpp
int x;
x = 3 + 5;

```
В соответствии с приоритетом операций вначале выполняется выражение 3 + 5, и только потом его значение присваивается переменной x.

Все остальные операции присваивания являются сочетанием простой операции присваивания с другими операциями:
- +=: присваивание после сложения. Присваивает левому операнду сумму левого и правого операндов: A += B эквивалентно A = A + B
- -=: присваивание после вычитания. Присваивает левому операнду разность левого и правого операндов: A -= B эквивалентно A = A - B
- *=: присваивание после умножения. Присваивает левому операнду произведение левого и правого операндов: A *= B эквивалентно A = A * B
- /=: присваивание после деления. Присваивает левому операнду частное левого и правого операндов: A /= B эквивалентно A = A / B
- %=: присваивание после деления по модулю. Присваивает левому операнду остаток от целочисленного деления левого операнда на правый: A %= B эквивалентно A = A % B
- <<=: присваивание после сдвига разрядов влево. Присваивает левому операнду результат сдвига его битового представления влево на определенное количество разрядов, равное значению правого операнда: A <<= B эквивалентно A = A << B
- >>=: присваивание после сдвига разрядов вправо. Присваивает левому операнду результат сдвига его битового представления вправо на определенное количество разрядов, равное значению правого операнда: A >>= B эквивалентно A = A >> B
- &=: присваивание после поразрядной конъюнкции. Присваивает левому операнду результат поразрядной конъюнкции его битового представления с битовым представлением правого операнда: A &= B эквивалентно A = A & B
- |=: присваивание после поразрядной дизъюнкции. Присваивает левому операнду результат поразрядной дизъюнкции его битового представления с битовым представлением правого операнда: A |= B эквивалентно A = A | B
- ^=: присваивание после операции исключающего ИЛИ. Присваивает левому операнду результат операции исключающего ИЛИ его битового представления с битовым представлением правого операнда: A ^= B эквивалентно A = A ^ B

Примеры операций:
```cpp

int a = 5;
a += 10;        // 15
a -= 3;         // 12
a *= 2;         // 24
a /= 6;         // 4
a <<= 4;      // 64
a >>= 2;      // 16

```
## Ввод и вывод в консоли
 
По умолчанию язык C++ не содержит встроенных средств для ввода с консоли и вывода на консоль, эти средства предоставляются библиотекой iostream. В ней определены два типа: istream и ostream. istream представляет поток ввода, а ostream - поток вывода.

Вобще сам темин "поток" в данном случае представляет последовательность символов, которая записывается на устройство ввода-вывода или считывается с него. И в данном случае под устройством ввода-вывода рассматривается консоль.

Для записи или вывода символов на консоль применяется объект cout, который представляет тип ostream. А для чтения с консоли используется объект cin

Для использования этих объектов в начало исходного файла необходимо подключить библиотеку iostream:
```cpp
#include <iostream>

```
## Вывод на консоль
Для вывода на консоль применяется оператор <<. Этот оператор получает два операнда. Левый операнд представляет объект типа ostream, в данном случае объект cout. А правый операнд - значение, которое надо вывести на консоль.

Так как оператор << возвращает левый операнд - cout, то с помощью цепочки операторов мы можем передать на консоль несколько значений. Например, определим простейшую программу вывода на консоль:
```cpp
#include <iostream>
 
int main()
{   
    int age = 33;
    double weight = 81.23;
    std::cout << "Name: " << "Tom" << "\n";
    std::cout << "Age: " << age << std::endl;
    std::cout << "Weight: " << weight << std::endl;
    return 0;
}

```
Оператору << передаются различные значения - строки, значения переменных, которые выводятся на консоль.

Строки могут содержать управляющие последовательности, которые интерпретируются определенным образом. Например, последовательность "\n" интерпретируется как перевод на новую строку. Из других управляющих последовательностей также нередко употребляется "\t", которая интерпретируется как табуляция.

Также цепочку операторов << можно завершать значением std::endl, которое вызывает перевод на новую строку и сброс буфера. При выводе в поток данные вначале помещаются в буфер. И сброс буфера гарантирует, что все переданные для вывода на консоль данные немедлено будут выведены на консоль.

## Ввод с консоли
Для считывания с консоли данных применяется оператор ввода >>, который принимает два операнда. Левый операнд представляет объект типа istream (в данном случае объект cin), с которого производится считывание, а правый операнд - объект, в который считываются данные.

Например, считаем данные с консоли:
```cpp
#include <iostream>
 
int main()
{   
    int age;
    double weight;
    std::cout << "Input age: ";
    std::cin >> age;
    std::cout << "Input weight: ";
    std::cin >> weight;
    std::cout << "Your age: " << age << "\t your weight: " << weight << std::endl;
    return 0;
}

```
Здесь после приглашений к вводу программа ожидает ввода значений для переменных age и weight.

Стоит отметить, что так оператор ввода в первом случае будет добавлять данные в целочисленную переменную age, то он ожидает ввода числа. В случае с переменной weight оператор ввода ожидает дробное число, причем разделителем целой и дробной части должна быть точка. Поэтому мы не можем ввести любые значения, например, строки. В этом случае программа может выдать некорректный результат.

Оператор ввода >> возвращает левый операнд - объект cin, поэтому мы можем по цепочке считывать данные в различные переменные:
```cpp
#include <iostream>
 
int main()
{   
    int age;
    double weight;
    std::cout << "Input age: ";
    std::cin >> age >> weight;
    std::cout << "Your age: " << age << "\t your weight: " << weight << std::endl;
    return 0;
}

```
После ввода одного из значений надо будет ввести пробел и затем вводить следующее значение.
## Пространства имен и using
При чтении и записи используют объекты std::cout и std::cin соответственно. Причем они использкются с префиксом std::. Этот префикс указывает, что объекты cout, cin, endl определены в пространствен имен std. А само двойное двоеточие :: представляет оператор области видимости (scope operator), который позволяет указать, в каком пространсте имен определен объект. И без префикса эти объекты по умолчанию мы использовать не можем.

Однако подобная запись может показаться несколько громоздкой. И в этом случае можно использовать оператор using, который позволяет ввести в программу объекты из различных пространств имен.

Использование оператора using имеет следующй формат:
using пространство_имен::объект
Например, пусть у нас есть следующая программа:
```cpp
#include <iostream>
 
int main()
{   
    int age;
    std::cout << "Input age: ";
    std::cin >> age;
    std::cout << "Your age: " << age << std::endl;
    return 0;
}

```
Здесь используются сразу три объекта из програнства имен std: cout, cin и endl. Перепишем программу с использованием using:
```cpp
#include <iostream>
using std::cin;
using std::cout;
using std::endl;
 
int main()
{   
    int age;
    cout << "Input age: ";
    cin >> age;
    cout << "Your age: " << age << endl;
    return 0;
}

```
Для каждого объекта из пространства std определяется свое выражение using. При этом программа будет работать также как и раньше.
## Условные конструкции
Условные конструкции направляют ход программы по одному из возможных путей в зависимости от условия.

## Конструкция if
Конструкция if проверяет истинность условия, и если оно истинно, выполняет блок инструкций. Этот оператор имеет следующую сокращенную форму:
```cpp
if (условие)
{
    инструкции;
}

```
В качестве условия использоваться условное выражение, которое возвращает true или false. Если условие возвращает true, то выполняются последующие инструкции, которые входят в блок if. Если условие возвращает false, то последующие инструкции не выполняются. Блок инструкций заключается в фигурные скобки.
Например:
```cpp
#include <iostream>
 
int main()
{
    int x = 60;
      
    if(x > 50)
    {
        std::cout << "x is greater than 50 \n";
    }
      
    if(x < 30)
    {
        std::cout << "x is less than 30 \n";
    }
     
    std::cout << "End of Program" << "\n";
    return 0;
}

```
Здесь определены две условных конструкции if. Они проверят больше или меньше значение переменной x, чем определенное значение. В качестве инструкции в обоих случаях выполняется вывод некоторой строки на консоль.

В первом случае x > 50 условие истинно, так как значение переменной x действительно больше 50, поэтому это условие возвратит true, и, следовательно, будут выполнятся инструкции, которые входят в блок if.

Во втором случае операция отношения x < 30 возвратит false, так как условие ложно, поэтому последующий блок инструкций выполняться не будет. 
Также мы можем использовать полную форму конструкции if, которая включает оператор else:
```cpp
if(выражение_условия)
    инструкция_1
else
    инструкция_2

```
После оператора else мы можем определить набор инструкций, которые выполняются, если условие в операторе if возвращает false. То есть если условие истинно, выполняются инструкции после оператора if, а если это выражение ложно, то выполняются инструкции после оператора else.
```cpp
int x = 50;
if(x > 60) 
    std::cout << "x is greater than 60 \n";
else
    std::cout << "x is less or equal 60 \n";

```
В данном случае условие x > 60 ложно, то есть возвращает false, поэтому будет выполняться блок else. И в итоге на консоль будет выведена строка "x is less or equal 60 \n".

Однако нередко надо обработать не два возможных альтернативных варианта, а гораздо больше. Например, в случае выше можно насчитать три условия: переменная x может быть больше 60, меньше 60 и равна 60. Для проверки альтернативных условий мы можем вводить выражения else if:
```cpp
int x = 60;
     
if(x > 60)
{
    std::cout << "x is greater than 60 \n";
}
else if (x < 60)
{
    std::cout << "x is less than 60 \n";
}
else
{
    std::cout << "x is equal 60 \n";
}

```
То есть в данном случае мы получаем три ветки развития событий в программе.

Если в блоке if или else или else-if необходимо выполнить только одну инструкцию, то фигурные скобки можно опустить:
```cpp
int x = 60;
     
if(x > 60)
    std::cout << "x is greater than 60 \n";
else if (x < 60)
    std::cout << "x is less than 60 \n";
else
    std::cout << "x is equal 60 \n";

```
## Конструкция switch
Другую форму организации ветвления программ представляет конструкция switch...case. Она имеет следующую форму:
```cpp
switch(выражение)
{
    case константа_1: инструкции_1;
    case константа_2: инструкции_2;
     
    default: инструкции;
}

```
После ключевого слова switch в скобках идет сравниваемое выражение. Значение этого выражения последовательно сравнивается со значениями после оператора сase. И если совпадение будет найдено, то будет выполняться определенный блок сase.

В конце конструкции switch может стоять блок default. Он необязателен и выполняется в том случае, если значение после switch не соответствует ни одному из операторов case. Например:
```cpp
#include <iostream>
 
int main()
{
    int x = 2;
      
    switch(x)
    {
        case 1: 
            std::cout << "x = 1" << "\n";
            break;
        case 2: 
            std::cout << "x = 2" << "\n";
            break;
        case 3: 
            std::cout << "x = 3" << "\n";
            break;
        default: 
            std::cout << "x is undefined" << "\n";
            break;
    }
    return 0;
}

```
Чтобы избежать выполнения последующих блоков case/default, в конце каждого блока ставится оператор break. То есть в данном случае будет выполняться оператор
```cpp
case 2: 
    std::cout << "x = 2" << "\n";
    break;

```
После выполнения оператора break произойдет выход из конструкции switch..case, и остальные операторы case будут проигнорированы. 
Стоит отметить важность использования оператора break. Если мы его не укажем в блоке case, то после этого блока выполнение перейдет к следующему блоку case. Например, уберем из предыдущего примера все операторы break:
```cpp
#include <iostream>
 
int main()
{
    int x = 2;
      
    switch(x)
    {
        case 1: 
            std::cout << "x = 1" << "\n";
        case 2: 
            std::cout << "x = 2" << "\n";
        case 3: 
            std::cout << "x = 3" << "\n";
        default: 
            std::cout << "x is undefined" << "\n";
    }
    return 0;
}

```
В этом случае будет выполняться оператор case 2:, так как переменная x=2. Однако так как этот блок case не завершается оператором break, то после его завершения будет выполняться набор инструкций после case 3: даже несмотря на то, что переменная x по прежнему равна 2. 
## Тернарный оператор
Тернарный оператор ?: позволяет сократить определение простейших условных конструкций if и имеет следующую форму:

[первый операнд - условие] ? [второй операнд] : [третий операнд]

Оператор использует сразу три операнда. В зависимости от условия тернарный оператор возвращает второй или третий операнд: если условие равно true (то есть истинно), то возвращается второй операнд; если условие равно false (то есть ложно), то третий. Например:
```cpp
#include <iostream>
 
int main()
{
    setlocale(LC_ALL, "");
    int x = 5; 
    int y = 3;
    char sign;
    std::cout << "Введите знак операции: ";
    std::cin >> sign;
    int result = sign=='+'?x + y:x - y;
    std::cout << "Результат: " << result << "\n";
    return 0;
}

```
В данном случае производится ввод знака операции. Здесь результатом тернарной операции является переменная result. И если переменная sign содержит знак "+", то result будет равно второму операнду - (x+y). Иначе result будет равно третьему операнду.
