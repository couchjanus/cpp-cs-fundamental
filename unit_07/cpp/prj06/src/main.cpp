#include <iostream>

using std::cout;
using std::endl;

int main() {
    // адрес переменной представляет шестнадцатиричное значение:
    std::cout << "адрес переменной представляет шестнадцатиричное значение!" << std::endl;

    int x = 10;     // определяем переменную
    int *p;         // определяем указатель
    p = &x;         // указатель получает адрес переменной
    
    std::cout << "адрес переменной p = " << p << std::endl;
    std::cout << "Value = " << *p << std::endl;

    // Значение, которое получено в результате операции разыменования, можно присвоить другой переменной:
    int y = *p;
    std::cout << "Value = " << y << std::endl;    // 10

    // Используя указатель, мы можем менять значение по адресу, который хранится в указателе:
    *p = 45;
    std::cout << "x = " << x << std::endl;     // 45

    short c = 12;
    int d = 10;
    short s = 2;
      
    short *pcc = &c;          // получаем адрес переменной с типа short
    int *pdi = &d;           // получаем адрес переменной d типа int
    short *ps = &s;         // получаем адрес переменной s типа short
    
    // По адресам можно увидеть, что переменные часто расположены в памяти рядом, 
    // но не обязательно в том порядке, в котором они определены в коде программы:
  
    std::cout << "Variable c: address=" << pcc << "\t value=" << *pcc << std::endl;
    std::cout << "Variable d: address=" << pdi << "\t value=" << *pdi << std::endl;
    std::cout << "Variable s: address=" << ps << "\t value=" << *ps << std::endl;

    int a = 10;
    int b = 2;
      
    int *pa = &a; // указатель pa хранит адрес переменной a
    int *pb = &b;
      
    std::cout << "Variable a: address=" << pa << "\t value=" << *pa << std::endl;
    std::cout << "Variable b: address=" << pb << "\t value=" << *pb << std::endl;
      
    pa = pb;    // теперь указатель pa хранит адрес переменной b
    std::cout << "Variable b: address=" << pa << "\t value=" << *pa << std::endl;

    // Адрес указателя
    // Указатель хранит адрес переменной, и по этому адресу мы можем получить значение этой переменной. 
    // указатель, как и любая переменная, сам имеет адрес, по которому он располагается в памяти. 

    // Этот адрес можно получить также через операцию &:

    std::cout << "address of pointer=" << &pa << std::endl;        // адрес указателя
    std::cout << "address stored in pointer=" << pa << std::endl;  // адрес, который хранится в указателе - адрес переменной a         
    std::cout << "value on pointer=" << *pa << std::endl;          // значение по адресу в указателе - значение переменной a

    // Работа с памятью в языке C++
 
    // Указатели поддерживают ряд операций: 
    // присваивание, получение адреса указателя, получение значения по указателю, 
    // некоторые арифметические операции и операции сравнения.

    // Присваивание
    // Указателю можно присвоить либо адрес объекта того же типа, либо значение другого указателя.
    // Для получения адреса объекта используется операция &:
    // При этом указатель и переменная должны иметь один и тот же тип, в данном случае это тип int.

    // Присвоение указателю другого указателя:
      
    cout << "Variable a: address=" << pa << "\t value=" << *pa << endl;
    cout << "Variable b: address=" << pb << "\t value=" << *pb << endl;

    // Когда указателю присваивается другой указатель, 
    // то фактически первый указатель начинает также указывать на тот же адрес, 
    // на который указывает второй указатель.
      
    pa = pb;    // теперь указатель pa хранит адрес переменной b
    cout << "Variable b: address=" << pa << "\t value=" << *pa << endl;

    // Нулевые указатели
    // Нулевой указатель (null pointer) - это указатель, который не указывает ни на какой объект. 
    // Если мы не хотим, чтобы указатель указывал на какой-то конкретный адрес, 
    // то можно присвоить ему условное нулевое значение. 
    // Для создания нулевого указателя можно применять различные способы:

    int *p2 = NULL;
    int *p3 = 0;


    // =============== Операции сравнения ===================
    // К указателям могут применяться операции сравнения >, >=, <, <=,==, !=. 
    // Операции сравнения применяются только к указателям одного типа и к значениям NULL и nullptr. 
    // Для сравнения используются номера адресов:
     
    if(pa > pb)
        cout << "pa (" << pa << ") is greater than pb ("<< pb << ")" << endl;
    else
        cout << "pa (" << pa << ") is less or equal pb ("<< pb << ")" << endl;
     
    // ================ Приведение типов ===================
    // Для преобразования указателя к другому типу в скобках перед указателем ставится тип, 
    // к которому надо преобразовать. 

    char ch = 'N';
    char *pc = &ch;
    // В этом случае следует выполнить операцию приведения типов с помощью операции (тип_указателя *):
    int *pd = (int *)pc;
    void *pv = (void*)pc;
    std::cout << "pv=" << pv << std::endl;
    std::cout << "pd=" << pd << std::endl;

    // Причем если мы не можем просто создать объект, 
    // например, переменную типа void, то для указателя это вполне будет работать. 
    // То есть можно создать указатель типа void.

    // указатель на тип char (char *pc = &c) при выводе на консоль система интерпретирует как строку:
    std::cout << "pc=" << pc << std::endl;
    // Поэтому если мы хотим вывести на консоль адрес, который хранится в указателе типа char, 
    // то это указатель надо преобразовать к другому типу, например, к void* или к int*.


    // ================= Арифметика указателей ====================
    // Указатели могут участвовать в арифметических операциях (сложение, вычитание, инкремент, декремент). 
    // Однако сами операции производятся немного иначе, чем с числами. 
    // И многое здесь зависит от типа указателя.
    // К указателю можно прибавлять целое число, и также можно вычитать из указателя целое число. 
    // Кроме того, можно вычитать из одного указателя другой указател ь.
    // Рассмотрим вначале операции инкремента и декремента и для этого возьмем указатель на объект типа int:
    
    int n = 10;
          
    int *ptr = &n;
    std::cout << "address=" << ptr << "\tvalue=" << *ptr << std::endl;

    // Операция инкремента ++ увеличивает значение на единицу. 
    // В случае с указателем увеличение на единицу будет означать увеличение адреса, 
    // который хранится в указателе, на размер типа указателя. 

    // В случае с указателем типа int увеличение/уменьшение на единицу 
    // означает изменение адреса на 4 (размер объектов int в большинстве архитектур равен 4 байтам). 
    // Поэтому увеличение указателя типа int на единицу означает увеличение значение указателя на 4. 
    // А после декремента указатель получил предыдущий адрес в памяти.
          
    ptr++;
    std::cout << "address=" << ptr << "\tvalue=" << *ptr << std::endl;
    // Фактически увеличение на единицу означает, что мы хотим перейти к следующему объекту в памяти, 
    // который находится за текущим и на который указывает указатель. 
    // А уменьшение на единицу означает переход назад к предыдущему объекту в памяти.

    // После изменения адреса мы можем получить значение, которое находится по новому адресу, 
    // однако это значение может быть неопределенным. 
    // Аналогично, для указателя типа short эти операции изменяли бы адрес на 2, 
    // а для указателя типа char на 1.

    ptr--;
    std::cout << "address=" << ptr << "\tvalue=" << *ptr << std::endl;

    double dd = 10.6;
    double *pdd = &dd;

    std::cout << "Pointer pd: address:" << pdd << std::endl;
    pdd++;
    std::cout << "Pointer pd: address:" << pdd << std::endl;
    // увеличение на единицу указателя типа double дало увеличения хранимого в нем адреса на 8 единиц 
    // (размер объекта double - 8 байт), 
              
    std::cout << "Pointer pc: address:" << (void*)pc << std::endl;
    pc++;
    std::cout << "Pointer pc: address:" << (void*)pc << std::endl;
    // увеличение на единицу указателя типа char дало увеличение хранимого в нем адреса на 1 
    // (размер типа char - 1 байт).
 
    // Аналогично указатель будет изменяться при прибавлении/вычитании не единицы, 
    // а какого-то другого числа.
    std::cout << "Pointer pd: address:" << pd << std::endl;
     
    // Добавление к указателю типа double числа 2
    pd = pd + 2;
    // означает, что мы хотим перейти на два объекта double вперед, 
    // что подразумевает изменение адреса на 2 * 8 = 16 байт.
    std::cout << "Pointer pd: address:" << pd << std::endl;
          
    std::cout << "Pointer pc: address:" << (void*)pc << std::endl;
    // Вычитание из указателя типа char числа 3
    pc = pc - 3;
    // означает, что мы хотим перейти на три объекта char назад, 
    // что подразумевает изменение адреса на 3 * 1 = 3 байта.

    std::cout << "Pointer pc: address:" << (void*)pc << std::endl;
  
    // В отличие от сложения операция вычитания может применять не только к указателю и целому числу, 
    // но и к двум указателям одного типа:
    // Результатом разности двух указателей является "расстояние" между ними. 
    int ci = pa - pb;
          
    std::cout << "pa: " << pa << std::endl;
    std::cout << "pb: " << pb << std::endl;
    // Так как размер одного объекта int равен 4 байтам, то расстояние между указателями будет равно 1.
    std::cout << "ci: " << ci << std::endl;
    
    // При работе с указателями надо отличать операции с самим указателем 
    // и операции со значением по адресу, на который указывает указатель.
    // в данном случае через операцию разыменования *pa получаем значение, 
    // на которое указывает указатель pa, то есть число 10, и выполняем операцию сложения. 
    // То есть в данном случае обычная операция сложения между двумя числами, 
    // так как выражение *pa представляет число.
    int ba = *pa + 20;   // операция со значением, на который указывает указатель
    pa++;               // операция с самим указателем
    // Но в то же время есть особенности, в частности, с операциями инкремента и декремента. Дело в том, что операции *, ++ и -- имеют одинаковый приоритет и при размещении рядом выполняются справа налево.     
    std::cout << "ba: " << ba << std::endl;  ;  // 30
    
    // Например, выполним постфиксный инкремент:
    std::cout << "pa: address=" << pa << "\tvalue=" << *pa << std::endl;
    int bi = *pa++;      // инкремент адреса указателя
              
    std::cout << "b: value=" << bi << std::endl;
    std::cout << "pa: address=" << pa << "\tvalue=" << *pa << std::endl;

    // В выражении bi = *pa++; сначала к указателю присваивается единица (то есть к адресу добавляется 4, так как указатель типа int). Затем так как инкремент постфиксный, с помощью операции разыменования возвращается значение, которое было до инкремента - то есть число 10. И это число 10 присваивается переменной bi.
    
    // Скобки изменяют порядок операций 
    // Изменим выражение:
    bi = (*pa)++;
    // Здесь сначала выполняется операция разыменования и получение значения, 
    // затем это значение увеличивается на 1. 
    // Теперь по адресу в указателе находится число 11. 
    // И затем так как инкремент постфиксный, переменная bi получает значение, 
    // которое было до инкремента, то есть опять число 10. 
    // Таким образом, в отличие от предыдущего случая все операции производятся над значением по адресу, 
    // который хранит указатель, но не над самим указателем. 
    // И, следовательно, изменится результат работы.
    
    // Аналогично будет с префиксным инкрементом:
    bi = ++*pa;
    
    // В данном случае сначала с помощью операции разыменования получаем значение по адресу 
    // из указателя pa, к этому значению прибавляется единица. 
    // То есть теперь значение по адресу, который хранится в указателе, равно 11. 
    // Затем результат операции присваивается переменной bi
    
    // Изменим выражение:
    bi = *++pa;
    // Теперь сначала изменяет адрес в указателе, затем мы получаем по этому адресу значение 
    // и присваиваем его переменной bi. Полученное значение в этом случае может быть неопределенным

    // ============== Указатели на константы ================
    // Указатели могут указывать как на переменные, так и на константы. 
    // Чтобы определить указатель на константу, он тоже должен объявляться с ключевым словом const:
    
        const int cia = 10;
        const int *pcia = &cia;
        std::cout << "address=" << pcia << "\tvalue=" << *pcia << std::endl;
    
    // Здесь указатель pa указывает на константу cia. 
    // Поэтому даже если мы захотим изменить значение по адресу, 
    // который хранится в указателе, мы не сможем это сделать:
    // *pcia = 34;
    // В этом случае мы просто получим ошибку во время компиляции.

    // Возможна также ситуация, когда указатель на константу на самом деле указывает на переменную:
        int via = 10;
        const int *pvia = &via;
        std::cout <<"value=" << *pvia << std::endl;     // 10
        a = 22;
        std::cout <<"value=" << *pvia << std::endl;     // 22
        //*pvia = 34;     // так делать нельзя
    
    // В этом случае переменную отдельно мы сможем изменять, 
    // однако по прежнему изменить ее значение через указатель мы не сможем.
    
    // Через указатель на константу мы не можем изменять значение переменной/константы. 
    // Но мы можем присвоить указателю адрес любой другой переменной или константы:
    
    const int ac = 10;
    const int *pac = &ac;     // указатель указывает на константу a
    const int bc = 45;
    pac = &bc;                // указатель указывает на константу b

    std::cout <<"value=" << *pac << std::endl;     // 45
    std::cout <<"value=" << ac << std::endl;     // 10 - константа a не изменяется

    
    // ================ Константный указатель ====================
    // От указателей на константы надо отличать константные указатели. 
    // Они не могут изменять адрес, который в них хранится, но могут изменять значение по этому адресу.
    
        int ca = 10;
        int *const pca = &ca;
        std::cout << "value=" << *pca << std::endl;      // 10
        *pca = 22;                                       // меняем значение
        std::cout << "value=" << *pca << std::endl;      // 22
      
        int vb = 45;
        // pca = &vb;         так нельзя сделать
    
    // Константный указатель на константу
    // И объединение обоих предыдущих случаев - константный указатель на константу, 
    // который не позволяет менять ни хранимый в нем адрес, ни значение по этому адресу:
    
    int av = 10;
    const int *const pva = &av;
    //*pva = 22;  так сделать нельзя
     
    int bv = 45;
    // pva = &bv;  так сделать нельзя 

    // =================== Указатели и массивы ==================
 
    // В C++ указатели и массивы тесно связаны. 
    // Обычно компилятор преобразует массив в указатели. 
    // С помощью указателей можно манипулировать элементами массива, как и с помощью индексов.
    
    // Имя массива является адресом его первого элемента. 
    // Соответственно через операцию разыменования мы можем получить значение по этому адресу:
    const int m = 5;
    int ar[m] = {1, 2, 3, 4, 5};
    std::cout << "ar[0] = " << *ar << std::endl;    // ar[0] = 1
    // Прибавляя к адресу первого элемента некоторое число, мы можем получить определенный элемент массив. 
    // Например, в цикле пробежимся по всем элементам:
        for(int i=0; i < m; i++)
        {
            std::cout << "ar[" << i << "]: address=" << ar+i << "\tvalue=" << *(ar+i) << std::endl;
        }
    // То есть, например, адрес второго элемента будет представлять выражение ar+1, 
    // а его значение - *(ar+1).
    
    // В отношении сложения и вычитания здесь действуют те же правила, что и в операциях с указателями. 
    // Добавление единицы означает прибавление к адресу значения, которое равно размеру типа массива. 
    // Так, в данном случае массив представляет тип int, 
    // размер которого, как правило, составляет 4 байта, 
    // поэтому прибавление единицы к адресу означает увеличение адреса на 4. 
    // Прибавляя к адресу 2, мы увеличиваем значение адреса на 4 * 2 = 8. И так далее.

    // Но при этом имя массива это не стандартный указатель, 
    // и мы не можем изменить его адрес, например, так:
    // a++;            // так сделать нельзя
    // int b = 8;
    // a = &b;         // так тоже сделать нельзя
   
    // Имя массива всегда хранит адрес самого первого элемента. 
    // И нередко для перемещения по элементам массива используются отдельные указатели:
    int *ptra = ar;
    int a2 = *(ptra+2);
    std::cout <<  "value: " << a2 << std::endl;  // value: 3
    // Здесь указатель ptr изначально указывает на первый элемент массива. 
    // Увеличив указатель на 2, мы пропустим 2 элемента в массиве и перейдем к элементу a[2].

    // С помощью указателей легко перебрать массив:
    for(int *ptr=ar; ptr<=&ar[4]; ptr++)
    {
        std::cout << "address=" << ptr << "\tvalue=" << *ptr << std::endl;
    }
    
    // Так как указатель хранит адрес, то мы можем продолжать цикл, 
    // пока адрес в указателе не станет равным адресу последнего элемента.

    // Аналогичным образом можно перебрать и многомерный массив:
        
        int arr[3][4] = { {1, 2, 3, 4} , {5, 6, 7, 8}, {9, 10, 11, 12}};
        int nn = sizeof(arr)/sizeof(arr[0]);         // число строк
        int mm = sizeof(arr[0])/sizeof(arr[0][0]);   // число столбцов
          
        int *end = arr[0] + nn * mm - 1;    // указатель на самый последний элемент 0 + 3 * 4 - 1 = 11
        for(int *ptr=arr[0], i=1; ptr <= end; ptr++, i++)
        {
            std::cout << *ptr << "\t";
            // если остаток от целочисленного деления равен 0,
            // переходим на новую строку
            if(i%mm == 0)
            {
                std::cout << std::endl;
            }
        }
    
    // Поскольку в данном случае мы имеем дело с двухмерным массивом, то адресом первого элемента будет выражение arr[0]. Соответственно указатель указывает на этот элемент. 
    // С каждой итерацией указатель увеличивается на единицу, пока его значение не станет равным адресу последнего элемента, который хранится в указателе end.

    // Мы также могли бы обойтись и без указателя на последний элемент, проверяя значение счетчика:
    
        // int *end = arr[0] + nn * mm - 1;    
        // указатель на самый последний элемент 0 + 3 * 4 - 1 = 11
    
        for(int *ptr=arr[0], i=0; i<mm*nn;)
        {
            std::cout << *ptr++ << "\t";
            // если остаток от целочисленного деления равен 0,
            // переходим на новую строку
            if(++i%mm == 0)
            {
                std::cout << std::endl;
            }
        }
    
    // ============= Указатель на массив символов ==================
    // Поскольку массив символов может интерпретироваться как строка, 
    // то указатель на значения типа char тоже может интерпретироваться как строка:
    
        char letters[] = "hello";
        char *pch = letters;
        std::cout << pch << std::endl;        // hello
    
    // Если же необходимо вывести на консоль адрес указателя, то его надо переобразовать к типу void*:
    std::cout << (void*)pch<< std::endl; // 0x60fe8e

    // В остальном работа с указателем на массив символов производится также, 
    // как и с указателями на массивы других типов.

    return 0;
}
