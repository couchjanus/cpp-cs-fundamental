# Наследование в С++

Наследование в C++ происходит между классами и имеет тип отношений является. Класс, от которого наследуют, называется родительским (или базовым, суперклассом), а класс, который наследует, называется дочерним (или производным, подклассом).

Дочерний класс наследует как поведение (методы), так и свойства (переменные-члены) от родителя (с учетом некоторых ограничений доступа). Эти методы и переменные становятся членами дочернего класса.

Поскольку дочерние классы являются полноценными классами, то они могут иметь и свои собственные члены. 

## Тип данных string
большинство современных языков программирования имеют встроенный тип данных string. В языке C++ есть также этот тип, но не как часть основного языка, а как часть Стандартной библиотеки С++.

Чтобы иметь возможность использовать строки в C++, сначала нужно подключить заголовочный файл string. Как только это будет сделано, мы сможем определять переменные типа string:
```c

#include <string>
 
// ... 
std::string name;
// ...

```
Как и с обычными переменными, мы можем инициализировать переменные типа string или присваивать им значения:
```c

std::string name("Sasha"); // инициализируем переменную name строковым литералом "Sasha"
name = "Masha"; // присваиваем переменной name строковый литерал "Masha"

```
Строки также могут содержать числа:
```c

std::string myID("34"); // "34" здесь - это не целое число 34!

```
Стоит отметить, что присваиваемые числа тип string обрабатывает как текст, а не как числа, и, следовательно, ими нельзя манипулировать как обычными числами (например, вы не сможете выполнять с ними арифметические операции). Язык C++ автоматически не преобразовывает их в значения целочисленных типов или типов с плавающей точкой.

## Класс Human
```c

#include <string>
 
class Human
{
public:
    std::string name;
    int age;
 
    Human(std::string name = "", int age = 0)
        : name(name), age(age)
    {
    }
 
    std::string getName() const { return name; }
    int getAge() const { return age; }
 
};

```
В этом классе мы определили только те члены, которые являются общими для всех объектов этого класса. Каждый Человек (независимо от пола, профессии и т.д.) имеет Имя и Возраст.

мы сделали все переменные-члены и методы класса открытыми. Это сделано ради простоты примера. Обычно переменные-члены нужно делать private.

## Класс Student
Предположим, что нам нужно написать программу, которая будет отслеживать информацию о students.
```c

class Student: public Human {
public:
    double rateAverage;
        int rate;

        Student(double average = 0.0, int r = 0)
           : rateAverage(average), rate(r)
        {
        }
};

```
Также нам нужно знать Имя и Возраст, а эта информация уже у нас есть: она хранится в классе Human.

Сделать так, чтобы Student унаследовал необходимые атрибуты от Human. Помните, что тип отношений в наследовании — является. Является ли Student Human?

## Делаем класс Student дочерним

Чтобы класс Student унаследовал информацию от класса Human, нам нужно после объявления Student  использовать двоеточие, ключевое слово public и имя класса, от которого мы хотим унаследовать. Это называется открытым наследованием:
```c

#include "Human.cpp"
// Student открыто наследует Human
class Student: public Human {
public:
    double rateAverage;
        int rate;

        Student(double average = 0.0, int r = 0)
           : rateAverage(average), rate(r)
        {
        }
};

```
Когда Student наследует свойства класса Human, то Student приобретает методы и переменные-члены класса Human. Кроме того, Student имеет еще два своих собственных члена: rateAverage и rate. Здесь есть смысл, так как эти свойства специфичны только для Student, а не для каждого Human.

Таким образом, объекты Student будут иметь 4 члена:
- rateAverage и rate от Student;
- name и age от Human.

## Полный код программы:

```c

#include <string>

class Human {
public:

    std::string name;
    int age;

    Human(std::string n = "", int a = 0)
    : name(n), age(a)
    {
    }

    std::string getName() const { return name; }
    int getAge() const { return age; }

};


#include "Human.cpp"

class Student: public Human {
public:
    double rateAverage;
        int rate;

        Student(double average = 0.0, int r = 0)
           : rateAverage(average), rate(r)
        {
        }
};


#include <iostream>
#include "Student.cpp"

using namespace std;

int main() {
    // Создаем нового student
    Student anton;
    // Присваиваем ему имя (мы можем делать это напрямую, так как m_name является public)
    anton.name = "Anton";
    // Выводим имя student
    std::cout << anton.getName() << '\n'; // используем метод getName(),
    // который мы унаследовали от класса Human
    return 0;
}

```
Это работает, так как anton является объектом класса Student, а все объекты класса Student имеют переменную-член name и метод getName(), унаследованные от класса Human.

## Дочерний класс Employee
Теперь напишем еще один класс, который также будет наследовать свойства Human. Например, класс Employee. Работник является Человеком, поэтому использовать наследование здесь уместно:

```c

// Employee открыто наследует Human
class Employee: public Human
{
public:
    int salary;
    long employeeID;
 
    Employee(int wage = 0, long id = 0)
        : salary(wage), employeeID(id)
    {
    }
 
    void printNameAndWage() const
    {
        std::cout << name << ": " << salary << '\n';
    }
};

```
Работник наследует name и age от Human (а также два метода) и имеет еще две собственные переменные-члены и один метод. Обратите внимание, метод printNameAndWage() использует переменные как из класса, к которому принадлежит (Employee::salary), так и с родительского класса (Human::name).

классы Employee и Student не имеют прямых отношений, хотя оба наследуют свойства класса Human.

```c

#include <iostream>
#include <string>
 
class Human
{
public:
    std::string name;
    int age;
 
    std::string getName() const { return name; }
    int getAge() const { return age; }
 
    Human(std::string n = "", int a = 0)
        : name(n), age(a)
    {
    }
};
 
// Employee открыто наследует Human
class Employee: public Human
{
public:
    int salary;
    long employeeID;
 
    Employee(int wage = 0, long id = 0)
        : salary(wage), employeeID(id)
    {
    }
 
    void printNameAndWage() const
    {
        std::cout << name << ": " << salary << '\n';
    }
};
 
int main()
{
    Employee ivan(350, 787);
    ivan.name = "Ivan"; // мы можем это сделать, так как m_name является public
 
    ivan.printNameAndWage();
    
    return 0;
}

```

## Отделение объявления от реализации
C++ предоставляет способ отделить объявление от реализации. Это делается путем определения методов вне тела самого класса. Для этого просто определите методы класса, как если бы они были обычными функциями, но в качестве префикса добавьте к имени функции имя класса с оператором разрешения области видимости (::).
```c

Human::Human(std::string n, int a)
    : name(n), age(a)
{
}

```

## Классы и заголовочные файлы

Объявления функций можно поместить в заголовочные файлы, чтобы затем иметь возможность использовать эти функции в нескольких файлах или даже в нескольких проектах. Классы в этом плане ничем не отличаются от функций. 
Определения классов могут быть помещены в заголовочные файлы для облегчения их повторного использования в нескольких файлах или проектах. Обычно, определение класса помещается в заголовочный файл с тем же именем, что у класса, а методы, определенные вне тела класса, помещаются в файл .cpp с тем же именем, что у класса.

Вот наш класс Human, но уже разбитый на файлы .cpp и .h:
## Human.h
```c

#include <string>

#ifndef HUMAN_H_
#define HUMAN_H_

class Human {
public:
    std::string name;
    int age;

    Human(std::string n = "", int a = 0);

    std::string getName() const { return name; }
    int getAge() const { return age; }

};

#endif /* HUMAN_H_ */

```
## Human.cpp
```c

#include <string>

#include "Human.h"

Human::Human(std::string n, int a)
    : name(n), age(a)
{
}

```
Теперь любой другой файл .h или .cpp, который захочет использовать класс Human, сможет просто подключить заголовочный файл: #include "Human.h". 
Human.cpp также необходимо добавить до компиляции в проект, который использует Human.h, чтобы линкер смог разобраться с реализацией класса Human.

## Student.cpp
```c

/*
 * Student.cpp
 *
 *  Created on: 13 июл. 2021 г.
 *      Author: janus
 */

#include "Human.h"

class Student: public Human {
public:
    double rateAverage;
        int rate;

        Student(double average = 0.0, int r = 0)
           : rateAverage(average), rate(r)
        {
        }
};

```

Классы — это пользовательские типы данных, которые освобождаются от определения только в одном месте. Поэтому класс, определенный в заголовочном файле, можно свободно подключать в другие файлы.

Методы, определенные внутри тела класса, считаются неявно встроенными. Встроенные функции освобождаются от правила одного определения. А это означает, что проблем с определением простых методов (таких как функции доступа) внутри самого класса возникать не должно.

Методы, определенные вне тела класса, рассматриваются, как обычные функции, и подчиняются правилу одного определения, поэтому эти функции должны быть определены в файле .cpp, а не внутри .h. 

## Параметры по умолчанию
Параметры по умолчанию для методов должны быть объявлены в теле класса (в заголовочном файле), где они будут видны всем, кто подключает этот заголовочный файл с классом.


## Цепочка наследований

Можно наследовать от класса, который сам наследует от другого класса. При этом ничего примечательного или чего-нибудь особенного не происходит — всё аналогично тому, что мы рассмотрели выше. Например, напишем класс Supervisor (Супервайзер). Супервайзер — это Работник, который «является» Человеком. Мы уже написали класс Employee, поэтому будем его использовать в качестве родительского класса:
```c

class Supervisor: public Employee
{
public:
    // Этот Супервайзер может наблюдать максимум за 5-тью Работниками
    long m_nOverseesIDs[5];
 
    Supervisor()
    {
    }
 
};

```
Все объекты Supervisor наследуют методы и переменные от Employee и Human, а также имеют свою собственную переменную-член m_nOverseesIDs.

Построив такие цепочки наследований, мы можем создать набор повторно используемых классов, которые будут иметь общие свойства вверху и становиться всё более специфичными на каждом последующем уровне наследования.

Использование наследования означает, что нам не нужно переопределять информацию из родительских классов в дочерних. Мы автоматически получаем методы и переменные-члены суперкласса через наследование, а затем просто добавляем специфичные методы или переменные-члены, которые хотим. Это не только экономит время и усилия, но также является очень эффективным: если мы когда-либо обновим или изменим базовый класс (например, добавим новые функции или исправим ошибку), то все наши производные классы автоматически унаследуют эти изменения!

Например, если мы добавим новый метод в Human, то Employee и Supervisor автоматически получат доступ к нему. Если мы добавим новую переменную в Employee, Supervisor также получит доступ к ней. Это позволяет создавать новые классы более простым, интуитивно-понятным способом!

Наследование позволяет повторно использовать классы путем наследования членов этих классов другими классами. 

## Порядок построения дочерних классов
```c

class Parent
{
public:
    int m_id;
 
    Parent(int id=0)
        : m_id(id)
    {
    }
 
    int getId() const { return m_id; }
};
 
class Child: public Parent
{
public:
    double m_value;
 
    Child(double value=0.0)
        : m_value(value)
    {
    }
 
    double getValue() const { return m_value; }
};

```
класс Child является дочерним, а класс Parent — родительским:

Child - класс, который состоит из двух частей: первая — Parent, вторая — Child:

```c

int main()
{
    Parent parent;
 
    return 0;
}

```
Parent — это не дочерний класс, так как он не наследует свойства каких-либо других классов. C++ выделяет память для Parent, затем вызывается конструктор по умолчанию класса Parent для выполнения инициализации.

Теперь рассмотрим, что происходит при создании объектов дочернего класса:
```c

int main()
{
    Child child;
 
    return 0;
}

```
Класс Child состоит из двух частей: часть Parent и часть Child. Когда C++ создает объекты дочерних классов, то он делает это поэтапно. Сначала создается самый верхний класс иерархии (родитель). Затем создается дочерний класс, который идет следующим по порядку, и так до тех пор, пока не будет создан последний класс (тот, который находится в самом низу иерархии).

Поэтому, при создании объекта класса Child, сначала создается часть Parent класса Child (с использованием конструктора по умолчанию класса Parent) и после создается вторая часть Child (с использованием конструктора по умолчанию класса Child). 

Этот процесс легко проиллюстрировать:

```c

#include <iostream>
 
class Parent
{
public:
    int m_id;
 
    Parent(int id=0)
        : m_id(id)
    {
        std::cout << "Parent\n";
    }
 
    int getId() const { return m_id; }
};
 
class Child: public Parent
{
public:
    double m_value;
 
    Child(double value=0.0)
        : m_value(value)
    {
        std::cout << "Child\n";
    }
 
    double getValue() const { return m_value; }
};
 
int main()
{
    std::cout << "Instantiating Parent:\n";
    Parent dParent;
 
    std::cout << "Instantiating Child:\n";
    Child dChild;
 
    return 0;
}

```
Это также способствует безопасности и эффективности выполнения кода: дочерний класс часто использует переменные-члены и методы родителя, но родительский класс ничего не знает о своем дочернем классе. Первоначальная инициализация родительского класса гарантирует, что его переменные-члены и методы будут проинициализированы до момента использования их дочерним классом.

## Порядок построения классов в цепочке наследования
Часто случаются ситуации, когда одни классы наследуют свойства других классов, которые, в свою очередь, наследуют свойства своих предыдущих (родительских) классов:
```c

class A
{
public:
    A()
    {
        std::cout << "A\n";
    }
};
 
class B: public A
{
public:
    B()
    {
        std::cout << "B\n";
    }
};
 
class C: public B
{
public:
    C()
    {
        std::cout << "C\n";
    }
};
 
class D: public C
{
public:
    D()
    {
        std::cout << "D\n";
    }
};

```
в C++ всегда идет построение с первого класса иерархии. Затем C++ переходит к следующему классу в иерархии и выполняет его построение. Этот процесс последовательный.

Порядок построения классов в цепочке наследования:

```c

int main()
{
    std::cout << "Constructing A: \n";
    A cA;
 
    std::cout << "Constructing B: \n";
    B cB;
 
    std::cout << "Constructing C: \n";
    C cC;
 
    std::cout << "Constructing D: \n";
    D cD;
}

```
Язык C++ выполняет построение дочерних классов поэтапно, начиная с верхнего класса иерархии и заканчивая нижним классом иерархии. По мере построения каждого класса для выполнения инициализации вызывается соответствующий конструктор соответствующего класса.
