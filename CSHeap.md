# Указатели
 
Указатели позволяют получить доступ к определенной ячейке памяти и произвести определенные манипуляции со значением, хранящимся в этой ячейке.

В языке C# указатели очень редко используются, однако в некоторых случаях можно прибегать к ним для оптимизации приложений. Код, применяющий указатели, еще называют небезопасным кодом. Однако это не значит, что он представляет какую-то опасность. Просто при работе с ним все действия по использованию памяти, в том числе по ее очистке, ложится целиком на нас, а не на среду CLR. И с точки зрения CLR такой код не безопасен, так как среда не может проверить данный код, поэтому повышается вероятность различного рода ошибок.

## установка флага unsafe в c#
Чтобы использовать небезопасный код в C#, надо первым делом указать проекту, что он будет работать с небезопасным кодом. Для этого надо установить в настройках проекта соответствующий флаг - в меню Project (Проект) найти Свойства проекта. Затем в меню Build установить флажок Allow unsafe code (Разрешить небезопасный код)

## Ключевое слово unsafe
Блок кода или метод, в котором используются указатели, помечается ключевым словом unsafe:
```cs
static void Main(string[] args)
{
    // блок кода, использующий указатели
    unsafe
    {
     
    }
}
```
Метод, использующий указатели:
```cs
unsafe private static void PointerMethod()
{
 
}
```
Также с помощью unsafe можно объявлять структуры:
```cs
unsafe struct State
{ 
 
}
```
## Операции * и &
Ключевой при работе с указателями является операция *, которую еще называют операцией разыменовывания. Операция разыменовывания позволяет получить или установить значение по адресу, на который указывает указатель. Для получения адреса переменной применяется операция &:
```cs
static void Main(string[] args)
{
    unsafe
    {       
        // При объявлении указателя указываем тип int* x; - в данном случае объявляется указатель на целое число. Но кроме типа int можно использовать и другие: sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, decimal или bool. Также можно объявлять указатели на типы enum, структуры и другие указатели.


        int* x; // определение указателя
        int y = 10; // определяем переменную

        // Выражение x = &y; позволяет нам получить адрес переменной y и установить на него указатель x. До этого указатель x не на что не указывал.

        x = &y; // указатель x теперь указывает на адрес переменной y
        Console.WriteLine(*x); // 10
        
        // После этого все операции с y будут влиять на значение, получаемое через указатель x и наоборот, так как они указывают на одну и ту же область в памяти.
        y = y + 20;
        Console.WriteLine(*x);// 30

        // Для получения значения, которое хранится в области памяти, на которую указывает указатель x, используется выражение *x.
        *x = 50; 
        Console.WriteLine(y); // переменная y=50
    }
    Console.ReadLine();
}

```

## Получение адреса
Используя преобразование указателя к целочисленному типу, можно получить адрес памяти, на который указывает указатель:
```cs
int* x; // определение указателя
int y = 10; // определяем переменную
 
x = &y; // указатель x теперь указывает на адрес переменной y
 
// получим адрес переменной y
uint addr = (uint)x;
Console.WriteLine("Адрес переменной y: {0}", addr);
```
Так как значение адреса - это целое число, а на 32-разрядных системах диапазон адресов 0 до 4 000 000 000, то для получения адреса используется преобразование в тип uint, long или ulong. Соответственно на 64-разрядных системах диапазон доступных адресов гораздо больше, поэтому в данном случае лучше использовать ulong, чтобы избежать ошибки переполнения.

## Указатель на другой указатель
Объявление и использование указателя на указатель:
```cs
static void Main(string[] args)
{
    unsafe
    {       
        int* x; // определение указателя
        int y = 10; // определяем переменную
 
        x = &y; // указатель x теперь указывает на адрес переменной y
        int** z = &x; // указатель z теперь указывает на адрес, который указывает и указатель x
        **z = **z + 40; // изменение указателя z повлечет изменение переменной y
        Console.WriteLine(y); // переменная y=50
        Console.WriteLine(**z); // переменная **z=50
    }
    Console.ReadLine();
}
```
## Указатели на структуры, члены классов и массивы
 
## Указатели на типы и операция ->
Кроме указателей на простые типы можно использовать указатели на структуры. А для доступа к полям структуры, на которую указывает указатель, используется операция ->:
```cs
class Program
{
    static void Main(string[] args)
    {
        unsafe
        {
            Person person;
            person.age = 29;
            person.height = 176;
            Person* p = &person;
            p->age = 30;
            Console.WriteLine(p->age);
 
            // разыменовывание указателя
            (*p).height = 180;
            Console.WriteLine((*p).height);
        }
    }
}
 
public struct Person
{
    public int age;
    public int height;
}
```
Обращаясь к указателю p->Age = 30; мы можем получить или установить значение свойства структуры, на которую указывает указатель. Обратите внимание, что просто написать p.Age=30 мы не можем, так как p - это не структура Person, а указатель на структуру.

## Альтернативой служит операция разыменования: 
```cs
(*p).height = 180;
```
## Указатели на массивы и stackalloc
С помощью ключевого слова stackalloc можно выделить память под массив в стеке. Смысл выделения памяти в стеке в повышении быстродействия кода. Посмотрим на примере вычисления факториала:
```cs
unsafe
{
    const int size = 7;
    int* factorial = stackalloc int[size]; // выделяем память в стеке под семь объектов int
    int* p = factorial;
                 
    *(p++)= 1; // присваиваем первой ячейке значение 1 и
    // увеличиваем указатель на 1
    for (int i = 2; i <= size; i++, p++)
    {
        // считаем факториал числа
        *p = p[-1] *i;
    }
    for (int i = 1; i <= size; ++i)
    {
        Console.WriteLine(factorial[i-1]);
    }
}

```
Оператор stackalloc принимает после себя массив, на который будет указывать указатель. 
```cs
int* factorial = stackalloc int[size];
```
Для манипуляций с массивом создаем указатель 
```cs
p: int* p = factorial;
```
который указывает на первый элемент массива, в котором всего 7 элементов

Далее начинаются уже сами операции с указателем и подсчет факториала. Так как факториал 1 равен 1, то присваиваем первому элементу, на который указывает указатель p, единицу с помощью операции разыменования: 
```cs
*(p++)= 1;
```
чтобы вложить некоторое значение по адресу, который хранит указатель, надо использовать выражение: 
```cs
*p=1
```
Но кроме этого тут происходит также инкремент указателя p++. То есть сначала первому элементу массива присваивается единица, потом указатель p смещается и начинает указывать уже на второй элемент. Мы могли бы написать это так:
```cs
*p= 1;
p++;
```
Чтобы получить предыдущий элемент и сместиться назад, можно использовать операцию декремента: 
```cs
Console.WriteLine(*(--p));. 
// Обратите внимание, что операции *(--p) и *(p--) различаются, 
// так как в первом случае сначала идет смещение указателя, а затем его разыменовывание. 
// А во втором случае - наоборот.
```
Затем вычисляем факториал всех остальных шести чисел: 
```cs
*p = p[-1] *i;
```
Обращение к указателям как к массивам представляет альтернативу операции разыменовывания для получения значения. В данном случае мы получаем значение предыдущего элемента.

## Оператор fixed и закрепление указателей
кроме структур в C# есть еще и классы, которые в отличие от типов значений, помещают все связанные значения в куче. И в работу данных классов может в любой момент вмешаться сборщик мусора, периодически очищающий кучу. Чтобы фиксировать на все время работы указатели на объекты классов используется оператор fixed.

Допустим, у нас есть класс Person:
```cs
public class Person
{
    public int age;
    public int height;
}
// Зафиксируем указатель с помощью оператора fixed:

unsafe
{
    Person person = new Person();
    person.age = 28;
    person.height = 178;
    // блок фиксации указателя
    fixed(int* p = &person.age)
    {
        if (*p < 30)
        {
            *p = 30;
        }
    }
    Console.WriteLine(person.age); // 30
}
```
Оператор fixed создает блок, в котором фиксируется указатель на поле объекта person. После завершения блока fixed закрепление с переменных снимается, и они могут быть подвержены сборке мусора.

Кроме адреса переменной можно также инициализировать указатель, используя массив, строку или буфер фиксированного размера:
```cs
unsafe
{
    int[] nums = { 0, 1, 2, 3, 7, 88 };
    string str = "Привет мир";
    fixed(int* p = nums)
    {
        int third = *(p+2);     // получим третий элемент
        Console.WriteLine(third); // 2
    }
    fixed(char* p = str)
    // При инициализации указателей на строку следует учитывать, что указатель должен иметь тип char*.
    {
        char forth = *(p + 3);     // получим четвертый элемент
        Console.WriteLine(forth); // в
    }
}
```
## Типы значений и ссылочные типы
Все типы данных можно разделить на типы значений, еще называемые значимыми типами, (value types) и ссылочные типы (reference types). Важно понимать между ними различия.

## Типы значений:
- Целочисленные типы (byte, sbyte, short, ushort, int, uint, long, ulong)
- Типы с плавающей запятой (float, double)
- Тип decimal
- Тип bool
- Тип char
- Перечисления enum
- Структуры (struct)

## Ссылочные типы:
- Тип object
- Тип string
- Классы (class)
- Интерфейсы (interface)
- Делегаты (delegate)

## Память в .NET делится на два типа: стек и куча (heap). 
## Стек
Параметры и переменные метода, которые представляют типы значений, размещают свое значение в стеке. Стек представляет собой структуру данных, которая растет снизу вверх: каждый новый добавляемый элемент помещается поверх предыдущего. Время жизни переменных таких типов ограничено их контекстом. Физически стек - это некоторая область памяти в адресном пространстве.

Когда программа только запускается на выполнение, в конце блока памяти, зарезервированного для стека устанавливается указатель стека. При помещении данных в стек указатель переустанавливается таким образом, что снова указывает на новое свободное место. При вызове каждого отдельного метода в стеке будет выделяться область памяти или фрейм стека, где будут храниться значения его параметров и переменных.

Например:
```cs
class Program
{
    static void Main(string[] args)
    {
        Calculate(5);
        Console.ReadKey();
    }
 
    static void Calculate(int t)
    {
        int x = 6;
        int y = 7;
        int z = y + t;
    }
}
```
Пи запуске такой программы в стеке будут определяться два фрейма - для метода Main (так как он вызывается при запуске программы) и для метода Calculate:

## Структура стека в C#
При вызове метода Calculate в его фрейм в стеке будут помещаться значения t, x, y и z. Они определяются в контексте данного метода. Когда метод отработает, область памяти, которая выделялась под стек, впоследствии может быть использована другими методами.

Причем если параметр или переменная метода представляет тип значений, то в стеке будет храниться непосредсвенное значение этого параметра или переменной. Например, в данном случае переменные и параметр метода Calculate представляют значимый тип - тип int, поэтому в стеке будут храниться их числовые значения.

## Ссылочные типы
Ссылочные типы хранятся в куче или хипе, которую можно представить как неупорядоченный набор разнородных объектов. Физически это остальная часть памяти, которая доступна процессу.

При создании объекта ссылочного типа в стеке помещается ссылка на адрес в куче (хипе). Когда объект ссылочного типа перестает использоваться, в дело вступает автоматический сборщик мусора: он видит, что на объект в хипе нету больше ссылок, условно удаляет этот объект и очищает память - фактически помечает, что данный сегмент памяти может быть использован для хранения других данных.

если мы изменим метод Calculate следующим образом:
```cs
static void Calculate(int t)
{
    object x = 6;
    int y = 7;
    int z = y + t;
}
```
То теперь значение переменной x будет храниться в куче, так как она представляет ссылочный тип object, а в стеке будет храниться ссылка на объект в куче.

## Составные типы
Теперь рассмотим ситуацию, когда тип значений и ссылочный тип представляют составные типы - структуру и класс:
```cs
class Program
{
    private static void Main(string[] args)
    {
        State state1 = new State(); // State - структура, ее данные размещены в стеке
        Country country1 = new Country(); // Country - класс, в стек помещается ссылка на адрес в хипе
                                        // а в хипе располагаются все данные объекта country1
    }
}
struct State
{
    public int x;
    public int y;
    public Country country;
}
class Country
{
    public int x;
    public int y;
}
```
Здесь в методе Main в стеке выделяется память для объекта state1. Далее в стеке создается ссылка для объекта country1 (Country country1), а с помощью вызова конструктора с ключевым словом new выделяется место в хипе (new Country()). Ссылка в стеке для объекта country1 будет представлять адрес на место в хипе, по которому размещен данный объект..

Таким образом, в стеке окажутся все поля структуры state1 и ссылка на объект country1 в хипе.

Однако в структуре State также определена переменная ссылочного типа Country. 
Значение переменной state1.country также будет храниться в куче, так как эта переменная представляет ссылочный тип:
```cs

private static void Main(string[] args)
{
    State state1 = new State();
    state1.country = new Country();
    Country country1 = new Country();
}
```
## Копирование значений
Тип данных надо учитывать при копировании значений. 
- При присвоении данных объекту значимого типа он получает копию данных. 
- При присвоении данных объекту ссылочного типа он получает не копию объекта, а ссылку на этот объект в хипе:
```cs
private static void Main(string[] args)
{
    State state1 = new State(); // Структура State
    State state2 = new State();
    state2.x = 1;
    state2.y = 2;
    state1 = state2;
    state2.x = 5; // state1.x=1 по-прежнему
    Console.WriteLine(state1.x); // 1
    Console.WriteLine(state2.x); // 5
 
    Country country1 = new Country(); // Класс Country
    Country country2 = new Country();
    country2.x = 1;
    country2.y = 4;
    country1 = country2;
    country2.x = 7; // теперь и country1.x = 7, так как обе ссылки и country1 и country2 
                    // указывают на один объект в хипе
    Console.WriteLine(country1.x); // 7
    Console.WriteLine(country2.x); // 7
     
    Console.Read();
}
```
Так как state1 - структура, то при присвоении state1 = state2 она получает копию структуры state2. А объект класса country1 при присвоении country1 = country2; получает ссылку на тот же объект, на который указывает country2. Поэтому с изменением country2, так же будет меняться и country1.

## Ссылочные типы внутри типов значений
внутри структуры у нас может быть переменная ссылочного типа, например, какого-нибудь класса:
```cs
class Program
{
    private static void Main(string[] args)
    {
        State state1 = new State(); 
        State state2 = new State();
         
        state2.country = new Country();
        state2.country.x = 5;
        state1 = state2;
        state2.country.x = 8; // теперь и state1.country.x=8, так как state1.country и state2.country
                            // указывают на один объект в хипе
        Console.WriteLine(state1.country.x); // 8
        Console.WriteLine(state2.country.x); // 8
         
        Console.Read();
    }
}
struct State
{
    public int x;
    public int y;
    public Country country;
}
class Country
{
    public int x;
    public int y;
}
```
Переменные ссылочных типов в структурах также сохраняют в стеке ссылку на объект в хипе. И при присвоении двух структур state1 = state2; структура state1 также получит ссылку на объект country в хипе. Поэтому изменение state2.country повлечет за собой также изменение state1.country.

## Объекты классов как параметры методов
Организацию объектов в памяти следует учитывать при передаче параметров по значению и по ссылке. 
Если параметры методов представляют объекты классов, то использование параметров имеет некоторые особенности. Например, создадим метод, который в качестве параметра принимает объект Person:
```cs
class Program
{
    static void Main(string[] args)
    {
        Person p = new Person { name = "Tom", age=23 };
        ChangePerson(p);  
 
        Console.WriteLine(p.name); // Alice
        Console.WriteLine(p.age); // 23
 
        Console.Read();
    }
 
    static void ChangePerson(Person person)
    {
        // При передаче объекта класса по значению в метод передается копия ссылки на объект. 
        // Эта копия указывает на тот же объект, что и исходная ссылка, потому мы можем изменить отдельные поля и свойства объекта, но не можем изменить сам объект. 

        // сработает только строка person.name = "Alice".
        person.name = "Alice";

        // строка person = new Person { name = "Bill", age = 45 } создаст новый объект в памяти, и person теперь будет указывать на новый объект в памяти.
        // сработает только в рамках данного метода
        person = new Person { name = "Bill", age = 45 };
        // Даже если после этого мы его изменим, то это никак не повлияет на ссылку p в методе Main, поскольку ссылка p все еще указывает на старый объект в памяти.
        Console.WriteLine(person.name); // Bill
    }
}
class Person
{
    public string name;
    public int age;
}
```
## Передача параметра по ссылке (с помощью ключевого слова ref)
Но при передаче параметра по ссылке (с помощью ключевого слова ref) в метод в качестве аргумента передается сама ссылка на объект в памяти. Поэтому можно изменить как поля и свойства объекта, так и сам объект:
```cs
class Program
{
    static void Main(string[] args)
    {
        Person p = new Person { name = "Tom", age=23 };
        ChangePerson(ref p);  
 
        Console.WriteLine(p.name); // Bill
        Console.WriteLine(p.age); // 45
 
        Console.Read();
    }
 
    static void ChangePerson(ref Person person)
    {
        // сработает
        person.name = "Alice";

        // Операция new создаст новый объект в памяти, 
        // и теперь ссылка person (она же ссылка p из метода Main) 
        // будет указывать уже на новый объект в памяти.
        person = new Person { name = "Bill", age = 45 };
    }
}
class Person
{
    public string name;
    public int age;
}
```