# Переменные и основные типы данных в C++

## Адреса и переменные
Память компьютера организована в последовательные части, каждая из которых имеет свой адрес. Адреса позволяют найти и получить доступ к содержимому, которое находится в определенном месте памяти. В современных компьютерах, у каждого бита по отдельности нет своего собственного адреса. Наименьшей единицей с адресом является байт (8 битов).

Поскольку все данные компьютера — это лишь последовательность битов, то мы используем тип данных, чтобы сообщить компилятору, как интерпретировать содержимое памяти.

Когда вы указываете тип данных для переменной, то компилятор и процессор заботятся о деталях преобразования вашего значения в соответствующую последовательность бит определенного типа данных. Когда вы просите ваше значение обратно, то оно восстанавливается из этой же последовательности бит.

## Инициализация переменных

Язык C++ поддерживает 2 основных способа инициализации переменных.

1. Копирующая инициализация (или «инициализация копированием») с помощью знака равенства =:
```c

int nValue = 5; // копирующая инициализация

```
2. Прямая инициализация с помощью круглых скобок ():
```c

int nValue(5); // прямая инициализация

```
## uniform-инициализация
Прямая или копирующая инициализация работают не со всеми типами данных (например, вы не сможете использовать эти способы для инициализации списка значений).

В попытке обеспечить единый механизм инициализации, который будет работать со всеми типами данных, в C++11 добавили новый способ инициализации, который называется uniform-инициализация:
```c

int value{5};

```
Инициализация переменной с пустыми фигурными скобками указывает на инициализацию по умолчанию (переменной присваивается 0):
```c

int value{}; // инициализация переменной по умолчанию значением 0 (ноль)

```
В uniform-инициализации есть еще одно дополнительное преимущество: вы не сможете присвоить переменной значение, которое не поддерживает её тип данных — компилятор выдаст предупреждение или сообщение об ошибке:
```c

int value{4.5}; // ошибка: целочисленная переменная не может содержать нецелочисленные значения
```

## Присваивание переменных

Когда переменной присваивается значение после её объявления (не в момент объявления), то это копирующее присваивание (или просто присваивание):
```c

int nValue;
nValue = 5; // копирующее присваивание

```
В языке C++ нет встроенной поддержки способов прямого/uniform-присваивания, есть только копирующее присваивание.

### Объявление нескольких переменных

В одном стейтменте можно объявить сразу несколько переменных одного и того же типа данных, разделяя их имена запятыми. Например, следующие 2 фрагмента кода выполняют одно и то же:
```c

int a, b;

```
Кроме того, вы даже можете инициализировать несколько переменных в одной строке:
```c

int a = 5, b = 6;
int c(7), d(8);
int e{9}, f{10};

```
3 ошибки, которые совершают новички при объявлении нескольких переменных в одном стейтменте:

1. Указание каждой переменной одного и того же типа данных при инициализации нескольких переменных в одном стейтменте. Это не критичная ошибка, так как компилятор легко её обнаружит и сообщит вам об этом:
```c

int a, int b; // неправильно (ошибка компиляции)
 
int a, b; // правильно

```
2. Использование разных типов данных в одном стейтменте. Переменные разных типов должны быть объявлены в разных стейтментах. Эту ошибку компилятор также легко обнаружит:
```c

int a, double b; // неправильно (ошибка компиляции)
 
int a; double b; // правильно (но не рекомендуется)
 
// Правильно и рекомендуется (+ читабельнее)
int a;
double b;

```
3. Инициализация двух переменных с помощью одной операции:
```c

int a, b = 5; // неправильно (переменная a остаётся неинициализированной)
 
int a, b = 5; // неправильно (переменная a остаётся неинициализированной)
 
int a = 5, b = 5; // правильно

```
Хороший способ запомнить эту ошибку и не допускать в будущем — использовать прямую или uniform-инициализацию:
```c

int a, b(5);
int c, d{5};

```
Этот вариант наглядно показывает, что значение 5 присваивается только переменным b и d.

В языке С++ приоритетным является объявление (а также инициализация) переменных как можно ближе к их первому использованию:
```c

#include <iostream>
 
int main()
{
    std::cout << "Enter a number: ";
    int x; // мы используем x в следующей строке, поэтому объявляем эту переменную здесь (как можно ближе к её первому использованию)
    std::cin >> x; // первое использование переменной x
 
    return 0;
}

```
Такой стиль написания кода имеет несколько преимуществ:
- Во-первых, возле переменных, которые объявлены как можно ближе к их первому использованию, находится другой код, который способствует лучшему представлению и пониманию происходящего. Если бы переменная х была объявлена в начале функции main(), то мы бы не имели ни малейшего представления, для чего она используется. Для понимания смысла переменной пришлось бы целиком просматривать всю функцию. Объявление переменной х возле операций ввода/вывода данных позволяет нам понять, что эта переменная используется для ввода/вывода данных.
- Во-вторых, объявление переменных только там, где они необходимы, сообщает нам о том, что эти переменные не влияют на код, расположенный выше, что делает программу проще для понимания.
- И, наконец, уменьшается вероятность случайного создания неинициализированных переменных.

## Тип данных void

Тип void — это самый простой тип данных, который означает отсутствие любого типа данных. Следовательно, переменные не могут быть типа void:
```c

void value; // не будет работать, так как переменная не может иметь тип void

```
Тип void, как правило, используется в 3-х случаях:

1. Указать, что функция не возвращает значение:
```c

void writeValue(int x) // здесь void означает, что функция не возвращает никакое значение
{
    std::cout << "The value of x is: " << x << std::endl;
    // Нет стейтмента return, так как тип функции - void
}

```
2. Указать, что функция не имеет никаких параметров (перешло из языка Cи):
```c

int getValue(void) // здесь void означает, что функция не имеет никаких параметров
{
    int x;
    std::cin >> x;
    return x;
}

```
Указание типа void как никаких параметров является пережитком, сохранившимся еще со времен языка Cи. Следующий код равнозначен и более предпочтителен для использования в языке C++:
```c

int getValue() // пустые скобки означают то же, что и void
{
    int x;
    std::cin >> x;
    return x;
}

```
Используйте пустой список параметров вместо void для указания отсутствия параметров в функции.


## Размер типов данных

Есть несколько причин по которым полезно знать, сколько памяти занимает определенная переменная/тип данных.

Во-первых, чем больше она занимает, тем больше информации сможет хранить. Так как каждый бит содержит либо 0, либо 1, то 1 бит может иметь 2 возможных значения.

2 бита могут иметь 4 возможных значения:
```
бит 0   бит 1
0   	0
0   	1
1   	0
1   	1

```
3 бита могут иметь 8 возможных значений:
```

бит 0   бит 1   бит 2
0   	0   	0
0   	0   	1
0   	1   	0
0   	1   	1
1   	0   	0
1   	0   	1
1   	1   	0
1   	1   	1

```
По сути, переменная с n-ным количеством бит может иметь 2n возможных значений. Поскольку байт состоит из 8 бит, то он может иметь 28 (256) возможных значений.

Размер переменной накладывает ограничения на количество информации, которую она может хранить. Следовательно, переменные, которые используют больше байт, могут хранить более широкий диапазон значений.
 
Во-вторых, компьютеры имеют ограниченное количество свободной памяти. Каждый раз, когда мы объявляем переменную, небольшая часть этой свободной памяти выделяется до тех пор, пока переменная существует. Поскольку современные компьютеры имеют много памяти, то в большинстве случаев это не является проблемой, особенно когда в программе всего лишь несколько переменных. Тем не менее, для программ с большим количеством переменных (например, 100 000), разница между использованием 1-байтовых или 8-байтовых переменных может быть значительной.

## Размер основных типов данных в C++

Язык C++ гарантирует только их минимальный размер:
```

Категория   					Тип 		Минимальный размер

Логический тип данных   		bool    	1 байт
Символьный тип данных   		char    	1 байт
								wchar_t 	1 байт
								char16_t    2 байта
								char32_t    4 байта

Целочисленный тип данных    	short   	2 байта
								int 		2 байта
								long    	4 байта
								long long   8 байт

Тип данных с плавающей запятой  float   	4 байта
								double  	8 байт
								long double 8 байт

```
Фактический размер переменных может отличаться на разных компьютерах, поэтому для его определения используют оператор sizeof.
## Оператор sizeof
Оператор sizeof — это унарный оператор, который вычисляет и возвращает размер определенной переменной или определенного типа данных в байтах. 
```c

#include <iostream>
 
int main()
{
    std::cout << "bool:\t\t" << sizeof(bool) << " bytes" << std::endl;
    std::cout << "char:\t\t" << sizeof(char) << " bytes" << std::endl;
    std::cout << "wchar_t:\t" << sizeof(wchar_t) << " bytes" << std::endl;
    std::cout << "char16_t:\t" << sizeof(char16_t) << " bytes" << std::endl;  
    std::cout << "char32_t:\t" << sizeof(char32_t) << " bytes" << std::endl;    
    std::cout << "short:\t\t" << sizeof(short) << " bytes" << std::endl;
    std::cout << "int:\t\t" << sizeof(int) << " bytes" << std::endl;
    std::cout << "long:\t\t" << sizeof(long) << " bytes" << std::endl;
    std::cout << "long long:\t" << sizeof(long long) << " bytes" << std::endl;
    std::cout << "float:\t\t" << sizeof(float) << " bytes" << std::endl;
    std::cout << "double:\t\t" << sizeof(double) << " bytes" << std::endl;
    std::cout << "long double:\t" << sizeof(long double) << " bytes" << std::endl;
    return 0;
}

```
Обратите внимание, оператор sizeof не используется с типом void, так как последний не имеет размера.

sizeof — это один из 3-х операторов в языке C++, который является словом, а не символом (еще есть new и delete).

Вы также можете использовать оператор sizeof и с переменными:
```c

#include <iostream>
 
int main()
{
    int x;
    std::cout << "x is " << sizeof(x) << " bytes" << std::endl;
    // Результат выполнения программы: x is 4 bytes
}

```

## Фиксированный размер целочисленных типов данных

Почему размер целочисленных типов не является фиксированным?
Если говорить в общем, то всё еще началось с языка Cи, когда производительность имела первостепенное значение. В языке Cи намеренно оставили размер целочисленных типов нефиксированным для того, чтобы компилятор мог самостоятельно подобрать наиболее подходящий размер для определенного типа данных в зависимости от компьютерной архитектуры.

Программистам не всегда удобно иметь дело с переменными, размер которых варьируется в зависимости от компьютерной архитектуры.

## Целочисленные типы фиксированного размера
Чтобы решить вопрос кроссплатформенности, в язык С++ добавили набор целочисленных типов фиксированного размера, которые гарантированно имеют один и тот же размер на любой архитектуре:
```

Название    Тип 				Диапазон значений
int8_t  	1 байт signed   	от -128 до 127
uint8_t 	1 байт unsigned 	от 0 до 255
int16_t 	2 байта signed  	от -32 768 до 32 767
uint16_t    2 байта unsigned    от 0 до 65 535
int32_t 	4 байта signed  	от -2 147 483 648 до 2 147 483 647
uint32_t    4 байта unsigned    от 0 до 4 294 967 295
int64_t 	8 байт signed   	от -9 223 372 036 854 775 808 до 9 223 372 036 854 775 807
uint64_t    8 байт unsigned 	от 0 до 18 446 744 073 709 551 615

```
Начиная с C++11 доступ к этим типам осуществляется через подключение заголовочного файла cstdint (находятся эти типы данных в пространстве имен std). Рассмотрим пример на практике:
```c

#include <iostream>
#include <cstdint>
 
int main()
{
    std::int16_t i(5); // прямая инициализация
    std::cout << i << std::endl;
    return 0;
}

```
Поскольку целочисленные типы фиксированного размера были добавлены еще до C++11, то некоторые старые компиляторы предоставляют доступ к ним через подключение заголовочного файла stdint.h.

### Предупреждение насчет std::int8_t и std::uint8_t

По определенным причинам в C++ большинство компиляторов определяют и обрабатывают типы int8_t и uint8_t идентично типам char signed и char unsigned (соответственно), но это происходит далеко не во всех случаях. Следовательно, std::cin и std::cout могут работать не так, как вы ожидаете. Например:
```c

#include <iostream>
#include <cstdint>
 
int main()
{
    std::int8_t myint = 65;
    std::cout << myint << std::endl;
 
    return 0;
    // На большинстве компьютеров с различными архитектурами результат выполнения этой программы следующий: A

}

```
Т.е. программа, приведенная выше, обрабатывает myint как переменную типа char. Однако на некоторых компьютерах результат может быть следующим: 65

Поэтому идеальным вариантом будет избегать использования std::int8_t и std::uint8_t вообще (используйте вместо них std::int16_t или std::uint16_t). Однако, если вы все же используете std::int8_t или std::uint8_t, то будьте осторожны с любой функцией, которая может интерпретировать std::int8_t или std::uint8_t как символьный тип, вместо целочисленного (например, с объектами std::cin и std::cout).

Избегайте использования std::int8_t и std::uint8_t. Если вы используете эти типы, то будьте внимательны, так как в некоторых случаях они могут быть обработаны как тип char.

## Недостатки целочисленных типов фиксированного размера
Целочисленные типы фиксированного размера могут не поддерживаться на определенных архитектурах (где они не имеют возможности быть представлены). Также эти типы могут быть менее производительными, чем фундаментальные типы данных, на определенных архитектурах.

### unsigned

Многие разработчики считают, что программисты должны избегать использования целочисленных типов unsigned вообще. Главная причина — непредсказуемое поведение и результаты, которые могут возникнуть при смешивании целочисленных типов signed и unsigned в программе.
```c

void doSomething(unsigned int x)
{
    // Выполнение некоего кода x раз
}
 
int main()
{
    doSomething(-1);
}

```
-1 преобразуется в другое большое число (скорее всего в 4 294 967 295). Но самое грустное в этом то, что предотвратить это мы не сможем. Язык C++ свободно конвертирует числа с типами unsigned в типы signed и наоборот без проверки диапазона допустимых значений определенного типа данных. А это, в свою очередь, может привести к переполнению.

Бьёрн Страуструп, создатель языка C++, считает, что: «Использовать тип unsigned (вместо signed) для получения еще одного бита для представления положительных целых чисел, почти никогда не является хорошей идеей».

Это не означает, что вы должны избегать использования типов unsigned вообще — нет. Но если вы их используете, то используйте только там, где это действительно имеет смысл, а также позаботьтесь о том, чтобы не допустить «смешивания» типов unsigned с типами signed (как в вышеприведенном примере).

## Типы данных с плавающей точкой: float, double и long double

### Типы данных с плавающей точкой
Целочисленные типы данных отлично подходят для работы с целыми числами, но есть ведь еще и дробные числа. И тут нам на помощь приходит тип данных с плавающей точкой (или «тип данных с плавающей запятой», floating point). Переменная такого типа может хранить любые действительные дробные значения, например: 4320.0, -3.33 или 0.01226. Почему точка плавающая? Дело в том, что точка/запятая перемещается (плавает) между цифрами, разделяя целую и дробную части значения.

Есть три типа данных с плавающей точкой: float, double и long double. Язык C++ определяет только их минимальный размер (как и с целочисленными типами). Типы данных с плавающей точкой всегда являются signed (т.е. могут хранить как положительные, так и отрицательные числа).
```

Категория   					Тип 		Минимальный размер  Типичный размер
Тип данных с плавающей точкой   float   	4 байта 			4 байта
								double  	8 байт  			8 байт
								long double 8 байт  			8, 12 или 16 байт

```
Объявление переменных разных типов данных с плавающей точкой:
```c

float fValue;
double dValue;
long double dValue2;

```
Если нужно использовать целое число с переменной типа с плавающей точкой, то тогда после этого числа нужно поставить разделительную точку и нуль. Это позволяет различать переменные целочисленных типов от переменных типов с плавающей запятой:
```c

int n(5); // 5 - это целочисленный тип 
double d(5.0); // 5.0 - это тип данных с плавающей точкой (по умолчанию double)
float f(5.0f); // 5.0 - это тип данных с плавающей точкой ("f" от "float")

```
Обратите внимание, литералы типа с плавающей точкой по умолчанию относятся к типу double. f в конце числа означает тип float.

### Экспоненциальная запись

Экспоненциальная запись очень полезна для написания длинных чисел в краткой форме. Числа в экспоненциальной записи имеют следующий вид: мантисса × 10экспонент. Например, рассмотрим выражение 1.2 × 104. Значение 1.2 — это мантисса (или значащая часть числа), а 4 — это экспонент (или порядок числа). Результатом этого выражения является значение 12000.

Обычно, в экспоненциальной записи, в целой части находится только одна цифра, все остальные пишутся после разделительной точки (в дробной части).

Рассмотрим массу Земли. В десятичной системе счисления она представлена как 5973600000000000000000000 кг. Это число даже трудно читать. Но используя экспоненциальную запись, массу Земли можно представить, как 5.9736 × 1024кг. Еще одним преимуществом экспоненциальной записи является сравнение двух очень больших или очень маленьких чисел — для этого достаточно просто сравнить их экспоненты.

В языке C++ буква е /Е означает, что число 10 нужно возвести в степень, которая следует за этой буквой. Например, 1.2 × 104 эквивалентно 1.2e4, значение 5.9736 × 1024 еще можно записать как 5.9736e24.

Для чисел меньше единицы экспонент может быть отрицательным. Например, 5e-2 эквивалентно 5 * 10-2, что, в свою очередь, означает 5 / 102 или 0.05. Масса электрона равна 9.1093822e-31 кг.

На практике экспоненциальная запись может использоваться в операциях присваивания следующим образом:
```c

double d1(5000.0);
double d2(5e3); // другой способ присвоить значение 5000
 
double d3(0.05);
double d4(5e-2); // другой способ присвоить значение 0.05

```
### Конвертация чисел в экспоненциальную запись
Для конвертации чисел в экспоненциальную запись необходимо следовать процедуре, указанной ниже:
1. Ваш экспонент начинается с нуля.
2. Переместите разделительную точку (которая разделяет целую и дробную части) влево, чтобы слева от нее осталась только одна ненулевая цифра:
- каждое перемещение точки влево увеличивает экспонент на 1;
- каждое перемещение точки вправо уменьшает экспонент на 1.
3. Откиньте все нули перед первой ненулевой цифрой в целой части.
4. Откиньте все конечные нули в правой (дробной) части, только если исходное число является целым (без разделительной точки).

```

Исходное число: 42030
Перемещаем разделительную точку на 4 цифры влево: 4.2030e4
Слева (в целой части) нет нулей: 4.2030e4
Отбрасываем конечный нуль в дробной части: 4.203e4 (4 значащие цифры)

Исходное число: 0.0078900
Перемещаем разделительную точку на 3 цифры вправо: 0007.8900e-3
Отбрасываем нули слева: 7.8900e-3
Не отбрасываем нули справа (исходное число является дробным): 7.8900e-3 (5 значащих цифр)

Исходное число: 600.410
Перемещаем разделительную точку на 2 цифры влево: 6.00410e2
Слева нет нулей: 6.00410e2
Нули справа оставляем: 6.00410e2 (6 значащих цифр)

```
нужно запомнить, что цифры в мантиссе (часть перед e) называются значащими цифрами. Количество значащих цифр определяет точность самого значения. Чем больше цифр в мантиссе, тем точнее значение.

### Точность и диапазон типов с плавающей точкой

Десятичное представление этого числа 1/3 — 0.33333333333333… (с тройками до бесконечности). Бесконечное число требует бесконечной памяти для хранения, а у нас в запасе, как правило, 4 или 8 байт. Переменные типа с плавающей запятой могут хранить только определенное количество значащих цифр, остальные — отбрасываются. Точность определяется количеством значащих цифр, которые представляют число без потери данных.

Когда мы выводим переменные типа с плавающей точкой, то точность объекта cout, по умолчанию, составляет 6. Т.е. на экране мы увидим только 6 значащих цифр, остальные — потеряются. Например:
```c

#include <iostream>
 
int main()
{
    float f;
    f = 9.87654321f;
    std::cout << f << std::endl;
    f = 987.654321f;
    std::cout << f << std::endl;
    f = 987654.321f;
    std::cout << f << std::endl;
    f = 9876543.21f;
    std::cout << f << std::endl;
    f = 0.0000987654321f;
    std::cout << f << std::endl;
    return 0;
}
// Результат выполнения программы:

// 9.87654
// 987.654
// 987654
// 9.87654e+06
// 9.87654e-05

```
Обратите внимание, каждое из вышеприведенных значений имеет только 6 значащих цифр (цифры перед e, а не перед точкой).

Также, в некоторых случаях, cout сам может выводить числа в экспоненциальной записи. В зависимости от компилятора, экспонент может быть дополнен нулями. Например, 9.87654e+06 — это то же самое, что и 9.87654e6 (просто с добавленным нулем и знаком +). Минимальное количество цифр экспонента определяется компилятором.

Также мы можем переопределить точность cout, используя функцию std::setprecision(), которая находится в заголовочном файле iomanip:
```c

#include <iostream>
#include <iomanip> // для std::setprecision()
 
int main()
{
    std::cout << std::setprecision(16); // задаем точность в 16 цифр
    float f = 3.33333333333333333333333333333333333333f;
    std::cout << f << std::endl;
    double d = 3.3333333333333333333333333333333333333;
    std::cout << d << std::endl;
    return 0;
}
// Результат выполнения программы:

// 3.333333253860474
// 3.333333333333333

```
Так как мы увеличили точность до 16, то каждая переменная выводится 16-ю цифрами.

Точность зависит от размера типа данных (в типе float точность меньше, чем в типе double) и от присваиваемого значения:
- точность float: от 6 до 9 цифр (в основном 7);
- точность double: от 15 до 18 цифр (в основном 16);
- точность long double: 15, 18 или 33 цифры (в зависимости от того, сколько байт занимает тип данных на компьютере).

Этот принцип относится не только к дробным числам, но и ко всем значениям, которые имеют слишком большое количество значащих цифр. Например:
```c

#include <iostream>
#include <iomanip> // для std::setprecision()
 
int main()
{
    float f(123456789.0f); // переменная f имеет 10 значащих цифр
    std::cout << std::setprecision(9); // задаем точность в 9 цифр 
    std::cout << f << std::endl;
    return 0;
}
// Результат:
// 123456792

```
Но ведь 123456792 больше чем 123456789, не так ли? Значение 123456789.0 имеет 10 значащих цифр, но точность float равна 7. Поэтому мы и получили другое число, произошла потеря данных!

Следовательно, нужно быть осторожными, когда вы используете переменные типа с плавающей точкой вместе с очень большими/очень маленькими числами, которые требуют большей точности, чем их текущий тип данных может предложить.

Диапазон и точность типов данных с плавающей точкой, согласно стандарту IEEE 754:
```

Размер  Диапазон    							Точность
4 байта от ±1.18 x 10-38 до ±3.4 x 1038 		6-9 значащих цифр (в основном 7)
8 байт  от ±2.23 x 10-308 до ±1.80 x 10308  	15-18 значащих цифр (в основном 16)
12 байт от ±3.36 x 10-4932 до ±1.18 x 104932    18-21 значащих цифр
16 байт от ±3.36 x 10-4932 до ±1.18 x 104932    33-36 значащих цифр

```
Может показаться немного странным, что 12-байтовая переменная типа с плавающей точкой имеет тот же диапазон, что и 16-байтовая переменная. Это потому, что они имеют одинаковое количество бит, выделенных для экспонента (только в 16-байтовой переменной точность будет выше).

Используйте по умолчанию тип double вместо типа float, так как его точность выше.


### Ошибки округления
Рассмотрим дробь 1/10. В десятичной системе счисления эту дробь можно представить, как 0.1. В двоичной системе счисления эта дробь представлена в виде бесконечной последовательности — 0.00011001100110011… Именно из-за подобных разногласий в представлении чисел в разных системах счисления, у нас могут возникать проблемы с точностью. Например:
```c

#include <iostream>
#include <iomanip> // для std::setprecision()
 
int main()
{
    double d(0.1);
    std::cout << d << std::endl; // используем точность cout по умолчанию (6 цифр)
    std::cout << std::setprecision(17);
    std::cout << d << std::endl;
    return 0;
}
// Результат выполнения программы:

// 0.1
// 0.10000000000000001

```
Первый cout выводит 0.1. После того, как мы изменили для объекта cout точность вывода до 17 цифр, мы увидели, что значением переменной d является не совсем 0.1! Подобное происходит из-за ограничений в количестве выделяемой памяти для переменных типа double, а также из-за необходимости округлять числа. По факту мы получили типичную ошибку округления.

Подобные ошибки могут иметь неожиданные последствия:
```c

#include <iostream>
#include <iomanip> // для std::setprecision()
 
int main()
{
    std::cout << std::setprecision(17);
 
    double d1(1.0);
    std::cout << d1 << std::endl;
    
    double d2(0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1); // должно получиться 1.0
    std::cout << d2 << std::endl;
}
// Результат выполнения программы:
// 1
// 0.99999999999999989

```
Хотя мы ожидали, что d1 и d2 окажутся равными, но это не так. А что, если бы нам довелось сравнивать эти переменные и, исходя из результата, выполнять определенный сценарий? В таком случае ошибок нам не миновать.

Математические операции (например, сложение или умножение), как правило, только увеличивают масштаб этих ошибок. Даже если 0.1 имеет погрешность в 17-й значащей цифре, то при выполнении операции сложения десять раз, ошибка округления переместится к 16-й значащей цифре.

### nan и inf

Есть две специальные категории чисел типа с плавающей запятой:
1. inf (или бесконечность, infinity), которая может быть либо положительной, либо отрицательной.
2. nan (или не число, not a number). Их есть несколько видов.

```c

#include <iostream>
 
int main()
{
    double zero = 0.0;
    double posinf = 5.0 / zero; // положительная бесконечность 
    std::cout << posinf << "\n";
 
    double neginf = -5.0 / zero; // отрицательная бесконечность 
    std::cout << neginf << "\n";
 
    double nan = zero / zero; // не число (математически некорректно)
    std::cout << nan << "\n";
 
    return 0;
}
// Результат выполнения программы:
// inf
// -inf
// -nan(ind)

```
inf означает бесконечность, а ind означает неопределенный (indeterminate). Обратите внимание, результаты вывода inf и nan зависят от компилятора/архитектуры компьютера, поэтому ваш результат выполнения вышеприведенной программы может отличаться от моего результата.

Переменные типа с плавающей точкой отлично подходят для хранения очень больших или очень маленьких (в том числе и дробных) чисел до тех пор, пока они имеют ограниченное количество значащих цифр (не превышают точность определенного типа данных).

Переменные типа с плавающей точкой могут иметь небольшие ошибки округления, даже если точность типа не превышена. В большинстве случаев такие ошибки остаются незамеченными, так как они не столь значительны. Но следует помнить, что сравнение переменных типов с плавающей точкой может иметь неопределенные последствия/результаты (а выполнение математических операций с такими переменными может только увеличить масштаб этих ошибок).

## Логический тип данных bool

С++ логический тип данных bool (boolean).

## Переменные логического типа данных
Логические переменные — это переменные, диапазон которых состоит только из двух возможных значений: true (1) и false (0).

Для объявления логической переменной используется ключевое слово bool:
```c

bool b;

```
Инициализировать логическую переменную или выполнить операцию присваивания можно с помощью ключевых слов true или false:
```c

bool b1 = true; // копирующая инициализация
bool b2(false); // прямая инициализация
bool b3 { true }; // uniform-инициализация (C++11)
b3 = false; // операция присваивания

```
Аналогично работе унарного оператора минус (-), с помощью которого мы можем сделать число отрицательным, с помощью логического оператора НЕ (!) мы можем изменить true на false и наоборот (false на true):
```c

bool b1 = !true; // значение b1 - false
bool b2(!false); // значение b2 - true

```
На самом деле, логические значения не сохраняются как true или false. Они обрабатываются в виде целых чисел: вместо true — единица, вместо false — ноль.

Следовательно, если мы попытаемся вывести логические значения с помощью std::cout, то увидим либо 0, либо 1:
```c

#include <iostream>
 
int main()
{
    std::cout << true << std::endl; // вместо true единица
    std::cout << !true << std::endl; // вместо !true ноль
 
    bool b(false);
    std::cout << b << std::endl; // b - false (0)
    std::cout << !b << std::endl; // !b - true (1)
    return 0;
}

```

Если вы хотите, чтобы std::cout выводил true или false (вместо целых чисел), то тогда используйте манипулятор форматирования std::boolalpha:
```c

#include <iostream>
 
int main()
{
    std::cout << true << std::endl;
    std::cout << false << std::endl;
 
    std::cout << std::boolalpha; // выводим логические значения как "true" или "false"
 
    std::cout << true << std::endl;
    std::cout << false << std::endl;
    return 0;
}
Результат выполнения программы:

```

## Использование логического типа данных в ветвлениях if

Очень часто логические переменные используются в ветвлениях if. Ветвление if выглядит следующим образом:
```c

if (выражение) стейтмент1;

Либо:

if (выражение) стейтмент1;
else стейтмент2;

```
(выражение) еще называется «условием», либо «условным выражением».

В обоих случаях, если результатом условия является ненулевое значение, то выполняется стейтмент1. Если же результатом условия является нулевое значение, то выполняется стейтмент2.

```c

if (true) // true - это условие
    std::cout << "The condition is true!" << std::endl;
else
    std::cout << "The condition is false!" << std::endl;

```

Следующая программа работает аналогично:
```c

bool b(false);
if (b)
    std::cout << "b is true!" << std::endl;
else
    std::cout << "b is false!" << std::endl;

```

Оператор равенства (==) используется для сравнения двух чисел (являются ли они равными). Оператор == возвращает true, если операнды равны и false, если таковыми не являются:
```c

#include <iostream>
 
int main()
{
    std::cout << "Enter an integer: ";
    int x;
    std::cin >> x;
 
    if (x == 0)
        std::cout << "The value is zero" << std::endl;
    else
        std::cout << "The value is non-zero" << std::endl;
    return 0;
}

```

## Возвращаемые значения логического типа данных
Логические значения часто используются в качестве возвращаемых значений в функциях. Названия таких функций очень часто начинаются со слов is (например, isEqual) или has (например, hasCommonDivisor).

```c

#include <iostream>
 
// Возвращаем true, если x и y равны, в противном случае - возвращаем false 
bool isEqual(int x, int y)
{
    return (x == y); // оператор == возвращает true, если x равно y, в противном случае - false 
}
 
int main()
{
    std::cout << "Enter an integer: ";
    int x;
    std::cin >> x;
 
    std::cout << "Enter another integer: ";
    int y;
    std::cin >> y;
 
    if (isEqual(x, y))
        std::cout << x << " and " << y << " are equal" << std::endl;
    else
        std::cout << x << " and " << y << " are not equal" << std::endl;
 
    return 0;
}

```

## Символьный тип данных char

Хоть тип char и относится к целочисленным типам данных, работа с char несколько отличается от работы с обычными целочисленными типами.


## Тип данных char
Переменная типа char занимает 1 байт. Однако вместо конвертации значения типа char в целое число, оно интерпретируется как ASCII-символ.

ASCII (American Standard Code for Information Interchange) — это американский стандартный код для обмена информацией, который определяет способ представления символов английского языка (+ несколько других) в виде чисел от 0 до 127. Например: код буквы 'а' — 97, код буквы 'b' — 98. Символы всегда помещаются в одинарные кавычки.

### Таблица ASCII-символов:
```
Код Символ  					Код Символ  Код Символ  Код Символ
0   NUL (null)  				32  (space) 64  @   96  `
1   SOH (start of header)   	33  !   65  A   97  a
2   STX (start of text) 		34  ”   66  B   98  b
3   ETX (end of text)   		35  #   67  C   99  c
4   EOT (end of transmission)   36  $   68  D   100 d
5   ENQ (enquiry)   			37  %   69  E   101 e
6   ACK (acknowledge)   		38  &   70  F   102 f
7   BEL (bell)  				39  ’   71  G   103 g
8   BS (backspace)  			40  (   72  H   104 h
9   HT (horizontal tab) 		41  )   73  I   105 i
10  LF (line feed/new line) 	42  *   74  J   106 j
11  VT (vertical tab)   		43  +   75  K   107 k
12  FF (form feed / new page)   44  ,   76  L   108 l
13  CR (carriage return)    	45  —   77  M   109 m
14  SO (shift out)  			46  .   78  N   110 n
15  SI (shift in)   			47  /   79  O   111 o
16  DLE (data link escape)  	48  0   80  P   112 p
17  DC1 (data control 1)    	49  1   81  Q   113 q
18  DC2 (data control 2)    	50  2   82  R   114 r
19  DC3 (data control 3)    	51  3   83  S   115 s
20  DC4 (data control 4)    	52  4   84  T   116 t
21  NAK (negative acknowledge)  53  5   85  U   117 u
22  SYN (synchronous idle)  	54  6   86  V   118 v
23  ETB (endtransmission block) 55  7   87  W   119 w
24  CAN (cancel)    			56  8   88  X   120 x
25  EM (end of medium)  		57  9   89  Y   121 y
26  SUB (substitute)    		58  :   90  Z   122 z
27  ESC (escape)    			59  ;   91  [   123 {
28  FS (file separator) 		60  <   92  \   124 |
29  GS (group separator)    	61  =   93  ]   125 }
30  RS (record separator)   	62  >   94  ^   126 ~
31  US (unit separator) 		63  ?   95  _   127 DEL (delete)

```
Символы от 0 до 31 в основном используются для форматирования вывода. Большинство из них уже устарели.

Символы от 32 до 127 используются для вывода. Это буквы, цифры, знаки препинания, которые большинство компьютеров использует для отображения текста (на английском языке).

Следующие два стейтмента выполняют одно и то же (присваивают переменным типа char целое число 97):
```c

char ch1(97); // инициализация переменной типа char целым числом 97
char ch2('a'); // инициализация переменной типа char символом 'a' (97)

```
Будьте внимательны при использовании фактических чисел с числами, которые используются для представления символов (из ASCII-таблицы). Следующие два стейтмента выполняют не одно и то же:
```c

char ch(5); // инициализация переменной типа char целым числом 5
char ch('5'); // инициализация переменной типа char символом '5' (53)

```
### Вывод символов

При выводе переменных типа char, объект cout выводит символы вместо цифр:
```c

#include <iostream>
 
int main()
{
    char ch(97); // несмотря на то, что мы инициализируем переменную ch целым числом
    std::cout << ch << std::endl; // cout выводит символ 
    return 0;
}

```
Также вы можете выводить литералы типа char напрямую:
```c

std::cout << 'b' << std::endl;

```

### Оператор static_cast
Если вы хотите вывести символы в виде цифр, а не в виде букв, то вам нужно сообщить cout выводить переменные типа char в виде целочисленных значений. Не очень хороший способ это сделать — присвоить переменной типа int переменную типа char и вывести её:
```c

#include <iostream>
 
int main()
{
    char ch(97);
    int i(ch); // присваиваем значение переменной ch переменной типа int
    std::cout << i << std::endl; // выводим значение переменной типа int
    return 0;
}

```
Лучшим способом является конвертация переменной из одного типа данных в другой с помощью оператора static_cast.

## Синтаксис static_cast выглядит следующим образом:
```c

static_cast<новый_тип_данных>(выражение)

```
Оператор static_cast принимает значение из (выражения) в качестве входных данных и конвертирует его в указанный вами <новый_тип_данных>.

Пример использования оператора static_cast для конвертации типа char в тип int:
```c

#include <iostream>
 
int main()
{
    char ch(97);
    std::cout << ch << std::endl;
    std::cout << static_cast<int>(ch) << std::endl;
    std::cout << ch << std::endl;
    return 0;
}

```

static_cast принимает (выражение) в качестве входных данных. Если мы используем переменную в (выражении), то эта переменная изменяет свой тип только в стейтменте с оператором static_cast. Процесс конвертации никак не влияет на исходную переменную с её значением! В вышеприведенном примере, переменная ch остается переменной типа char с прежним значением, чему является подтверждением последний стейтмент с cout.

Также в static_cast нет никакой проверки по диапазону, так что если вы попытаетесь использовать числа, которые будут слишком большие или слишком маленькие для конвертируемого типа, то произойдет переполнение.

### Ввод символов

Следующая программа просит пользователя ввести символ. Затем она выводит этот символ и его ASCII-код:
```c

#include <iostream>
 
int main()
{
    std::cout << "Input a keyboard character: ";
 
    char ch;
    std::cin >> ch;
    std::cout << ch << " has ASCII code " << static_cast<int>(ch) << std::endl;
 
    return 0;
}

```

даже если cin позволит вам ввести несколько символов, переменная ch будет хранить только первый символ (именно он и помещается в переменную). Остальная часть пользовательского ввода останется во входном буфере, который использует cin, и будет доступна для использования последующим вызовам cin.
```c

#include <iostream>
 
int main()
{
    std::cout << "Input a keyboard character: "; // предположим, что пользователь ввел abcd
 
    char ch;
    std::cin >> ch; // ch = 'a', "bcd" останется во входном буфере
    std::cout << ch << " has ASCII code " << static_cast<int>(ch) << std::endl;
 
    // Обратите внимание, следующий cin не просит пользователя что-либо ввести, данные берутся из входного буфера!
    std::cin >> ch; // ch = 'b', "cd" останется в буфере
    std::cout << ch << " has ASCII code " << static_cast<int>(ch) << std::endl;
    
    return 0;
}

```

### Размер, диапазон и знак типа сhar
В языке С++ для переменных типа char всегда выделяется 1 байт. По умолчанию, char может быть как signed, так и unsigned (хотя обычно signed). Если вы используете char для хранения ASCII-символов, то вам не нужно указывать знак переменной (поскольку signed и unsigned могут содержать значения от 0 до 127).

Но если вы используете тип char для хранения небольших целых чисел, то тогда следует уточнить знак. Переменная типа char signed может хранить числа от -128 до 127. Переменная типа char unsigned имеет диапазон от 0 до 255.

## Управляющие символы

В языке C++ есть управляющие символы (или «escape-последовательности»). Они начинаются с бэкслеша (\), а затем следует определенная буква или цифра.

Наиболее распространенным управляющим символов в языке С++ является '\n', который обозначает символ новой строки:
```c

#include <iostream>
 
int main()
{
    std::cout << "First line\nSecond line" << std::endl;
    return 0;
}

```

Еще одним часто используемым управляющим символом является \t, который заменяет клавишу TAB, вставляя большой отступ:
```c

#include <iostream>
 
int main()
{
    std::cout << "First part\tSecond part";
    return 0;
}

```

### Таблица всех управляющих символов в языке C++:
```

Название    						Символ  Значение
Предупреждение (alert)  			\a  Предупреждение (звуковой сигнал)
Backspace   						\b  Перемещение курсора на одну позицию назад
formfeed    						\f  Перемещение курсора к следующей логической странице
Символ новой строки (newline)   	\n  Перемещение курсора на следующую строку
Возврат каретки (carriage return)   \r  Перемещение курсора в начало строки
Горизонтальный таб (horizontal tab) \t  Вставка горизонтального TAB-а
Вертикальный таб (vertical tab) 	\v  Вставка вертикального TAB-а
Одинарная кавычка   				\’  Вставка одинарной кавычки (или апострофа)
Двойная кавычка 					\”  Вставка двойной кавычки
Бэкслеш 							\\  Вставка обратной косой черты (бэкслэша)
Вопросительный знак 				\?  Вставка знака вопроса
Восьмеричное число  				\(number)   Перевод числа из восьмеричной системы счисления в тип char
Шестнадцатеричное число 			\x(number)  Перевод числа из шестнадцатеричной системы счисления в тип char

```
```c

#include <iostream>
 
int main()
{
    std::cout << "\"This is quoted text\"\n";
    std::cout << "This string contains a single backslash \\" << std::endl;
    std::cout << "6F in hex is char \'\x6F\'" << std::endl;
    return 0;
}

```
Что использовать: ‘\n’ или std::endl?
Вы могли заметить, что в последнем примере мы использовали '\n' для перемещения курсора на следующую строку. Но мы могли бы использовать и std::endl.

При использовании std::cout, данные для вывода могут помещаться в буфер, т.е. std::cout может не отправлять данные сразу же на вывод. Вместо этого он может оставить их при себе на некоторое время (в целях улучшения производительности).

И '\n', и std::endl оба переводят курсор на следующую строку. Только std::endl еще гарантирует, что все данные из буфера будут выведены, перед тем, как продолжить.

когда использовать '\n', а когда std::endl?
- Используйте std::endl, когда нужно, чтобы ваши данные выводились сразу же (например, при записи в файл или при обновлении индикатора состояния какого-либо процесса). Обратите внимание, это может повлечь за собой незначительное снижение производительности, особенно если запись на устройство происходит медленно (например, запись файла на диск).
- Используйте '\n' во всех остальных случаях.

## Другие символьные типы: wchar_t, char16_t и char32_t

Тип wchar_t следует избегать практически во всех случаях (кроме тех, когда происходит взаимодействие с Windows API).

Так же, как и стандарт ASCII использует целые числа для представления символов английского языка, так и другие кодировки используют целые числа для представления символов других языков. Наиболее известный стандарт (после ASCII) — Unicode, который имеет в запасе более 110 000 целых чисел для представления символов из разных языков.

Существуют следующие кодировки Unicode:
- UTF-32 — требует 32 бита для представления символа.
- UTF-16 — требует 16 бит для представления символа.
- UTF-8 — требует 8 бит для представления символа.

Типы char16_t и char32_t были добавлены в C++11 для поддержки 16-битных и 32-битных символов Unicode (8-битные символы и так поддерживаются типом char).

В чём разница между одинарными и двойными кавычками при использовании с символами?
Как вы уже знаете, символы всегда помещаются в одинарные кавычки (например, 'а', '+', '5'). Переменная типа char представляет только один символ (например, буква а, символ +, число 5). 

Следующий стейтмент не является корректным:
```c

char ch('56'); // переменная типа char может хранить только один символ

```
Текст, который находится в двойных кавычках, называется строкой (например, "Hello, world!"). Строка (тип string) — это набор последовательных символов.

Вы можете использовать литералы типа string в коде:
```c

std::cout << "Hello, world!"; // "Hello, world!" - это литерал типа string

```

## Литералы и магические числа

В языке C++ есть два вида констант: литеральные и символьные.

## Литеральные константы
Литеральные константы (или просто «литералы») — это значения, которые вставляются непосредственно в код. Поскольку они являются константами, то их значения изменить нельзя. Например:
```c

bool myNameIsAlex = true; // true - это литеральная константа типа bool
int x = 5; // 5 - это литеральная константа типа int
int y = 2 * 3; // 2 и 3 - это литеральные константы типа int

```
С литералами типов bool и int всё понятно, а вот для литералов типа с плавающей точкой есть два способа объявления:
```c

double pi = 3.14159; // 3.14159 - это литерал типа double 
double avogadro = 6.02e23; // число avogadro - 6.02 x 10^23

```
Во втором способе объявления, число после экспонента может быть и отрицательным:
```c

double electron = 1.6e-19; // заряд электрона - 1.6 x 10^-19

```
Числовые литералы могут иметь суффиксы, которые определяют их типы. Эти суффиксы не являются обязательными, так как компилятор понимает из контекста, константу какого типа данных вы хотите использовать.
```

Тип данных  Суффикс 									Значение
int 		u или U 									unsigned int
int 		l или L 									long
int 		ul, uL, Ul, UL, lu, lU, Lu или LU   		unsigned long
int 		ll или LL   								long long
int 		ull, uLL, Ull, ULL, llu, llU, LLu или LLU   unsigned long long
double  	f или F 									float
double  	l или L 									long double

```
Суффиксы есть даже для целочисленных типов (но они почти не используются):
```c

unsigned int nValue = 5u; // тип int unsigned
long nValue2 = 5L; // тип long

```
По умолчанию литеральные константы типа с плавающей точкой являются типа double. Для конвертации литеральных констант в тип float можно использовать суффикс f или F:
```c

float fValue = 5.0f; // тип float
double d = 6.02e23; // тип double (по умолчанию)

```
Язык C++ также поддерживает литералы типов string и char:
```c

char c = 'A'; // 'A' - это литерал типа char 
std::cout << "Hello, world!"; // "Hello, world!" - это литерал строки C-style
std::cout << "Hello," " world!"; // C++ связывает последовательные литералы типа string

```
Литералы хорошо использовать в коде до тех пор, пока их значения понятны и однозначны. Это выполнение операций присваивания, математических операций или вывода текста в консоль.

### Литералы в восьмеричной и шестнадцатеричной системах счисления

В повседневной жизни мы используем десятичную систему счисления, которая состоит из десяти цифр: 0, 1, 2, 3, 4, 5, 6, 7, 8 и 9. По умолчанию язык C++ использует десятичную систему счисления для чисел в программах:
```c

int x = 12; // предполагается, что 12 является числом десятичной системы счисления

```
В двоичной (бинарной) системе счисления всего 2 цифры: 0 и 1. Значения: 0, 1, 10, 11, 100, 101, 110, 111 и т.д.

Есть еще две другие системы счисления: восьмеричная и шестнадцатеричная.

Восьмеричная система счисления состоит из 8 цифр: 0, 1, 2, 3, 4, 5, 6 и 7. Значения: 0, 1, 2, 3, 4, 5, 6, 7, 10, 11, 12 и т.д.

В восьмеричной системе счисления нет цифр 8 и 9, так что сразу перескакиваем от 7 к 10.

Десятичная система счисления    0   1   2   3   4   5   6   7   8   9   10  11
Восьмеричная система счисления  0   1   2   3   4   5   6   7   10  11  12  13

Для использования литерала из восьмеричной системы счисления, используйте префикс 0 (ноль):
```c

#include <iostream>
 
int main()
{
    int x = 012; // 0 перед значением означает, что это восьмеричный литерал
    std::cout << x;
    return 0;
}

```
std::cout выводит числа в десятичной системе счисления, а 12 в восьмеричной системе = 10 в десятичной.

Восьмеричная система счисления используется крайне редко.

Шестнадцатеричная система счисления состоит из 16 символов: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, А, В, С, D, Е, F.

Десятичная система  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17
Шестнадцатеричная система   0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F   10  11
Для использования литерала из шестнадцатеричной системы счисления, используйте префикс 0x:
```c

#include <iostream>
 
int main()
{
    int x = 0xF; // 0x перед значением означает, что это шестнадцатеричный литерал
    std::cout << x;
    return 0;
}

```

Поскольку в этой системе 16 символов, то одна шестнадцатеричная цифра занимает 4 бита. Следовательно, две шестнадцатеричные цифры занимают 1 байт.

Рассмотрим 32-битное целое число из двоичной системы счисления: 0011 1010 0111 1111 1001 1000 0010 0110. Из-за длины и повторения цифр его сложно прочесть. В шестнадцатеричной системе счисления это же значение будет выглядеть следующим образом: 3A7F 9826. Такой удобный/сжатый формат является преимуществом шестнадцатеричной системы счисления, поэтому шестнадцатеричные значения часто используются для представления адресов памяти или необработанных значений в памяти.

До C++14 использовать литерал из двоичной системы счисления было невозможно. Тем не менее, шестнадцатеричная система счисления может нам в этом помочь:
```c

#include <iostream>
 
int main()
{
    int bin(0);
    bin = 0x01; // присваиваем переменной бинарный литерал 0000 0001 
    bin = 0x02; // присваиваем переменной бинарный литерал 0000 0010 
    bin = 0x04; // присваиваем переменной бинарный литерал 0000 0100 
    bin = 0x08; // присваиваем переменной бинарный литерал 0000 1000 
    bin = 0x10; // присваиваем переменной бинарный литерал 0001 0000 
    bin = 0x20; // присваиваем переменной бинарный литерал 0010 0000 
    bin = 0x40; // присваиваем переменной бинарный литерал 0100 0000 
    bin = 0x80; // присваиваем переменной бинарный литерал 1000 0000 
    bin = 0xFF; // присваиваем переменной бинарный литерал 1111 1111 
    bin = 0xB3; // присваиваем переменной бинарный литерал 1011 0011 
    bin = 0xF770; // присваиваем переменной бинарный литерал 1111 0111 0111 0000 
 
    return 0;
}

```
### Бинарные литералы и разделитель цифр в C++14
В C++14 мы можем использовать бинарные (двоичные) литералы, добавляя префикс 0b:
```c

#include <iostream>
 
int main()
{
    int bin(0);
    bin = 0b1; // присваиваем переменной бинарный литерал 0000 0001 
    bin = 0b11; // присваиваем переменной бинарный литерал 0000 0011 
    bin = 0b1010; // присваиваем переменной бинарный литерал 0000 1010 
    bin = 0b11110000; // присваиваем переменной бинарный литерал 1111 0000 
 
    return 0;
}

```
Поскольку длинные литералы читать трудно, то в C++14 добавили возможность использовать одинарную кавычку ' в качестве разделителя цифр:
```c

#include <iostream>
 
int main()
{
    int bin = 0b1011'0010; // присваиваем переменной бинарный литерал 1011 0010 
    long value = 2'532'673'462; // намного проще читать, нежели 2532673462
 
    return 0;
}

```
Если ваш компилятор не поддерживает C++14, то использовать бинарные литералы и разделитель цифр вы не сможете — компилятор выдаст ошибку.

## Магические числа.

Рассмотрим следующий фрагмент кода:
```c

int maxStudents = numClassrooms * 30;
// число 30 является магическим числом
```
Магическое число — это хорошо закодированный литерал (обычно, число) в строке кода, который не имеет никакого контекста. 

Использование магических чисел является плохой практикой, так как в дополнение к тому, что они не предоставляют никакого контекста (для чего и почему используются), они также могут создавать проблемы, если их значения необходимо будет изменить. 

Старайтесь свести к минимуму использование магических чисел в ваших программах.

## const, constexpr и символьные константы

## Константы
Возьмем к примеру величину силы тяжести на Земле: 9.8м/с^2. Она вряд ли поменяется в ближайшее время. Использовать константу в этом случае будет наилучшим вариантом, так как мы предотвратим, таким образом, любое (даже случайное) изменение этого значения.

Чтобы сделать переменную константой — используйте ключевое слово const перед типом переменной или после него:
```c

const double gravity { 9.8 }; // предпочтительнее использовать const перед типом данных
int const sidesInSquare { 4 }; // ок, но вариант выше - лучше

```
Несмотря на то, что язык C++ позволяет размещать const как перед типом данных, так и после него, хорошей практикой считается размещать const перед типом данных.

Константы должны быть инициализированы при объявлении. Изменить их значения с помощью операции присваивания нельзя:
```c

const double gravity { 9.8 };
gravity = 9.9; // не допускается - ошибка компиляции

```
Объявление константы без её инициализации также вызовет ошибку компиляции:
```c

const double gravity; // ошибка компиляции, константа должна быть инициализирована

```
Обратите внимание, константы могут быть инициализированы и с помощью неконстантных значений:
```c

std::cout << "Enter your age: ";
int age;
std::cin >> age;
 
const int usersAge (age); // в дальнейшем значение переменной usersAge не может быть изменено

```
Ключевое слово const является наиболее полезным (и наиболее часто используемым) с параметрами функций:
```c

void printInteger(const int myValue)
{
    std::cout << myValue;
}

```
Таким образом, при вызове функции константа-параметр сообщает и гарантирует нам то, что функция не изменит значение переменной myValue.

### Время компиляции и время выполнения

Когда вы находитесь в процессе компиляции программы, то это время компиляции (compile time). Компилятор проверяет вашу программу на синтаксические ошибки и, если их нет, конвертирует код в объектные файлы.

Временной промежуток с момента старта выполнения программы и до момента окончания её работы называется временем выполнения программы (англ. «runtime»). Код выполняется строка за строкой.

## Спецификатор constexpr
В языке C++ есть два вида констант:
1. Константы времени выполнения. Их значения определяются только во время выполнения программы. Переменные типа usersAge и myValue выше являются константами времени выполнения, так как компилятор не может определить их значения во время компиляции. usersAge зависит от пользовательского ввода (который можно получить только во время выполнения программы), а myValue зависит от значения, переданного в функцию (это значение также определится только во время выполнения программы).

2. Константы времени компиляции. Их значения определяются во время компиляции программы. Например, переменная со значением силы тяжести на Земле является константой времени компиляции, так как мы её определяем во время написания программы (до начала её выполнения).

В большинстве случаев не важно какой тип константы вы используете: времени выполнения или времени компиляции. Однако, все же есть несколько ситуаций, когда C++ может потребовать константу времени компиляции вместо времени выполнения (например, при определении длины массива фиксированного размера — мы рассмотрим это несколько позже). Так как есть 2 типа констант, то компилятору нужно постоянно отслеживать, к какому из них относится какая переменная. Чтобы упростить это задание, в C++11 добавили спецификатор constexpr, который сообщает компилятору, что текущая переменная является константой времени компиляции:
```c

constexpr double gravity (9.8); // ок, значение определяется во время компиляции программы
constexpr int sum = 4 + 5; // ок, результат выражения 4 + 5 определяется во время компиляции программы
 
std::cout << "Enter your age: ";
int age;
std::cin >> age;
constexpr int myAge = age; // неправильно, переменная age не определяется во время компиляции программы

```
Любая переменная, которая не должна изменять свое значение после инициализации, должна быть объявлена с помощью спецификатора const (или constexpr).

## Имена констант

Некоторые программисты пишут имена констант заглавными буквами. Другие используют обычные имена, только с префиксом k. Мы же не будем их как-то выделять, так как константы — это те же обычные переменные, просто с фиксированными значениями, вот и всё. Особой причины их выделять — нет.

## Символьные константы
Символьная константа — это тот же литерал (магическое число), только с идентификатором. Есть 2 способа объявления символьных констант в языке C++.

Плохой способ: Использовать макросы-объекты с текст_замена в качестве символьных констант.
Раньше этот способ широко использовался, так что вы все еще можете его увидеть в старых программах.

Как мы уже знаем, макросы-объекты имеют две формы: с текст_замена и без текст_замена. Рассмотрим первый вариант с текст_замена. Он выглядит следующим образом:
```c

#define идентификатор текст_замена

```
Как только препроцессор встретит эту директиву, все дальнейшие появления идентификатор будут заменены на текст_замена. идентификатор обычно пишется заглавными буквами с нижним подчёркиванием вместо пробелов.

Например:
```c

#define MAX_STUDENTS_PER_CLASS 30
 
//...
int max_students = numClassrooms * MAX_STUDENTS_PER_CLASS;
//...

```
Во время компиляции программы, препроцессор заменит все идентификаторы MAX_STUDENTS_PER_CLASS на литерал 30.


Рассмотрим еще один пример:
```c

#define MAX_STUDENTS_PER_CLASS 30
#define MAX_NAME_LENGTH 30
 
int max_students = numClassrooms * MAX_STUDENTS_PER_CLASS;
setMax(MAX_NAME_LENGTH);

```
Здесь понятно, что MAX_STUDENTS_PER_CLASS и MAX_NAME_LENGTH не являются одним и тем же объектом, хоть и имеют одинаковые значения.

почему же этот способ плохой:
- Во-первых, макросы обрабатываются препроцессором, который заменяет идентификаторы на определенные значения. Эти значения не отображаются в отладчике (во время отладки вашей программы). При компиляции int max_students = numClassrooms * 30; в отладчике вы увидите int max_students = numClassrooms * MAX_STUDENTS_PER_CLASS;. 
- Во-вторых, эти директивы всегда имеют глобальную область видимости. Это означает, что значения #define в одной части кода могут конфликтовать со значениями #define в другой части кода.

Не используйте директиву #define для создания символьных констант.

### Использовать переменные со спецификатором const.
```c

const int maxStudentsPerClass { 30 };
const int maxNameLength { 30 };

```
Такие значения отображаются в отладчике, а также следуют всем правилам обычных переменных (в том числе и по области видимости).

## Использование символьных констант в программе

Во многих программах символьные константы используются часто. Это могут быть физические или математические константы (например, число Пи или число Авогадро), или специфические значения в вашей программе. Чтобы не писать их каждый раз, когда они необходимы — просто определите их в одном месте и используйте везде, где они нужны. Таким образом, если вам придется изменить их значения — достаточно будет зайти в один файл и внести в него правки, а не искать эти константы по всей программе.

Алгоритм использования символьных констант в вашей программе:
1. Создайте заголовочный файл для хранения констант.
2. В заголовочном файле объявите пространство имен.
3. Добавьте все ваши константы в созданное пространство имен (убедитесь, что все константы имеют спецификатор const).
4. #include заголовочный файл везде, где нужны константы.

Например, файл constants.h:
```c

#ifndef CONSTANTS_H
#define CONSTANTS_H
 
// Определите собственное пространство имен для хранения констант
namespace constants
{
    const double pi(3.14159);
    const double avogadro(6.0221413e23);
    const double my_gravity(9.2); 
    // ... другие константы 
}
#endif

```
Используйте оператор разрешения области видимости :: для доступа к константам в файлах .cpp:
```c

#include "constants.h"
 
//...
double circumference = 2 * radius * constants::pi;
//...

```
Если в программе много констант разных типов, то сделайте отдельные файлы для каждого из этих типов. Таким образом, отделив математические константы от специфических значений (которые могут быть разными в разных программах), вы сможете подключать файл с математическими константами к любой другой программе.



## Задачи

1. Запишите следующие числа в экспоненциальной записи в стиле языка C++ (используя букву е, как символ экспонента) и определите, сколько значащих цифр имеет каждое из следующих чисел:
```
   34.50

   0.004000

   123.005

   146000

   146000.001

   0.0000000008

   34500.0

```

2. Напишите программу, которая просит пользователя ввести простое целое число, меньшее 10. Если пользователь ввел одно из следующих чисел: 2, 3, 5 или 7 — программа должна вывести The digit is prime, в противном случае — The digit is not prime.

Используйте ветвление if для сравнения чисел и логические значения для отслеживания того, является ли пользовательское число простым или нет.
