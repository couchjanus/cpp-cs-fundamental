# Указатель

Указатели представляют собой объекты, значением которых служат адреса других объектов (переменных, констант, указателей) или функций.

Обычно указатели используются для работы с динамически созданными объектами, для построения связанных структур данных, таких, как связанные списки и иерархические деревья, и для передачи в функции больших объектов – массивов и объектов классов – в качестве параметров.

Каждый указатель ассоциируется с некоторым типом данных, причем их внутреннее представление не зависит от внутреннего типа: и размер памяти, занимаемый объектом типа указатель, и диапазон значений у них одинаков . Разница состоит в том, как компилятор воспринимает адресуемый объект. Указатели на разные типы могут иметь одно и то же значение, но область памяти, где размещаются соответствующие типы, может быть различной:
- указатель на int, содержащий значение адреса 1000, направлен на область памяти 1000-1003 (в 32-битной системе);
- указатель на double, содержащий значение адреса 1000, направлен на область памяти 1000-1007 (в 32-битной системе).

Для определения указателя надо указать тип объекта, на который указывает указатель, и символ звездочки * Например, определим указатель на объект типа int:
```c

int *p;

```
Пока указатель не ссылается ни на какой объект. При этом в отличие от ссылки указатель необязательно инициализировать каким-либо значением. Теперь присвоим указателю адрес переменной:
```c

int x = 10;     // определяем переменную
int *p;         // определяем указатель
p = &x;         // указатель получает адрес переменной

```
Для получения адреса переменной применяется операция &. Что важно, переменная x имеет тип int, и указатель, который указывает на ее адрес, тоже имеет тип int. То есть должно быть соответствие по типу.
```c

// адрес переменной представляет шестнадцатиричное значение:

#include <iostream>
 
int main()
{
    int x = 10;     // определяем переменную
    int *p;         // определяем указатель
    p = &x;         // указатель получает адрес переменной
    std::cout << "p = " << p << std::endl;
    return 0;
}

```

То есть в памяти компьютера есть адрес, по которому располагается переменная x. Так как переменная x представляет тип int, то на большинстве архитектур она будет занимать следующие 4 байта (на конкретных архитектурах размер памяти для типа int может отличаться).


## Разыменование указателя
Эта операция позволяет получить объект по адресу, который хранится в указателе.

Но так как указатель хранит адрес, то мы можем по этому адресу получить хранящееся там значение, то есть значение переменной x. Для этого применяется операция * или операция разыменования. Результатом этой операции всегда является объект, на который указывает указатель:
```c
// Операция разыменования указателя представляет выражение в виде *имя_указателя. 
#include <iostream>
using std::cout;
using std::endl;
 
int main()
{
    int x = 10;
    int *p;
    p = &x;
    // указатель p будет ссылаться на адрес, по которому располагается переменная x.
    std::cout << "Address = " << p << std::endl;
    std::cout << "Value = " << *p << std::endl;
    

    int a = 10;
      
    int *pa = &a;
    int *pb = pa;
      
    *pa = 25;
      
    cout << "Value on pointer pa: " << *pa << endl;  // 25
    cout << "Value on pointer pb: " << *pb << endl;  // 25
    cout << "Value of variable a: " << a << endl;    // 25
     
    return 0;
}
// Через выражение *pa мы можем получить значение по адресу, который хранится в указателе pa, а через выражение типа *pa = значение вложить по этому адресу новое значение.

// И так как в данном случае указатель pa указывает на переменную a, то при изменении значения по адресу, на который указывает указатель, также изменится и значение переменной a.

```

Значение, которое получено в результате операции разыменования, можно присвоить другой переменной:
```c

int x = 10;
int *p  = &x;
int y = *p;
std::cout << "Value = " << y << std::endl;    // 10

// И также используя указатель, мы можем менять значение по адресу, который хранится в указателе:

int x = 10;
int *p = &x;
*p = 45;
std::cout << "x = " << x << std::endl;     // 45

```
Так как по адресу, на который указывает указатель, располагается переменная x, то соответственно ее значение изменится.


Создадим еще несколько указателей:
```c

#include <iostream>
 
int main()
{
    short c = 12;
    int d = 10;
    short s = 2;
      
    short *pc = &c;          // получаем адрес переменной с типа short
    int *pd = &d;           // получаем адрес переменной d типа int
    short *ps = &s;         // получаем адрес переменной s типа short

// По адресам можно увидеть, что переменные часто расположены в памяти рядом, но не обязательно в том порядке, в котором они определены в коде программы:
      
    std::cout << "Variable c: address=" << pc << "\t value=" << *pc << std::endl;
    std::cout << "Variable d: address=" << pd << "\t value=" << *pd << std::endl;
    std::cout << "Variable s: address=" << ps << "\t value=" << *ps << std::endl;
     
    return 0;
}

```
## Адрес указателя
Указатель хранит адрес переменной, и по этому адресу мы можем получить значение этой переменной. Но кроме того, указатель, как и любая переменная, сам имеет адрес, по которому он располагается в памяти. Этот адрес можно получить также через операцию &:
```c

int a = 10;
int *pa = &a;
std::cout << "address of pointer=" << &pa << std::endl;        // адрес указателя
std::cout << "address stored in pointer=" << pa << std::endl;  // адрес, который хранится в указателе - адрес переменной a         
std::cout << "value on pointer=" << *pa << std::endl;          // значение по адресу в указателе - значение переменной a
```

## Работа с памятью в языке C++
 
Указатели поддерживают ряд операций: присваивание, получение адреса указателя, получение значения по указателю, некоторые арифметические операции и операции сравнения.

## Присваивание
Указателю можно присвоить либо адрес объекта того же типа, либо значение другого указателя.

Для получения адреса объекта используется операция &:
```c

int a = 10;
int *pa = &a;   // указатель pa хранит адрес переменной a
// При этом указатель и переменная должны иметь один и тот же тип, в данном случае это тип int.
```

## Присвоение указателю другого указателя:
```c

#include <iostream>
using std::cout;
using std::endl;
 
int main()
{
    int a = 10;
    int b = 2;
      
    int *pa = &a;
    int *pb = &b;
      
    cout << "Variable a: address=" << pa << "\t value=" << *pa << endl;
    cout << "Variable b: address=" << pb << "\t value=" << *pb << endl;
    
    // Когда указателю присваивается другой указатель, то фактически первый указатель начинает также указывать на тот же адрес, на который указывает второй указатель.
      
    pa = pb;    // теперь указатель pa хранит адрес переменной b
    cout << "Variable b: address=" << pa << "\t value=" << *pa << endl;
     
    return 0;
}

```

## Нулевые указатели
Нулевой указатель (null pointer) - это указатель, который не указывает ни на какой объект. Если мы не хотим, чтобы указатель указывал на какой-то конкретный адрес, то можно присвоить ему условное нулевое значение. Для создания нулевого указателя можно применять различные способы:
```c

int *p1 = nullptr;
int *p2 = NULL;
int *p3 = 0;

```
## Операции сравнения
К указателям могут применяться операции сравнения >, >=, <, <=,==, !=. Операции сравнения применяются только к указателям одного типа и к значениям NULL и nullptr. Для сравнения используются номера адресов:
```c

#include <iostream>
using std::cout;
using std::endl;
 
int main()
{
    int a = 10;
    int b = 20;
    int *pa = &a;
    int *pb = &b;
     
    if(pa > pb)
        cout << "pa (" << pa << ") is greater than pb ("<< pb << ")" << endl;
    else
        cout << "pa (" << pa << ") is less or equal pb ("<< pb << ")" << endl;
     
    return 0;
}

```

## Приведение типов
Для преобразования указателя к другому типу в скобках перед указателем ставится тип, к которому надо преобразовать. 

```c
#include <iostream>
 
int main()
{
    char c = 'N';
    char *pc = &c;
    // В этом случае следует выполнить операцию приведения типов с помощью операции (тип_указателя *):
    int *pd = (int *)pc;
    void *pv = (void*)pc;
    std::cout << "pv=" << pv << std::endl;
    std::cout << "pd=" << pd << std::endl;
 
    return 0;
}

```
Причем если мы не можем просто создать объект, например, переменную типа void, то для указателя это вполне будет работать. То есть можно создать указатель типа void.

```c
// указатель на тип char (char *pc = &c) при выводе на консоль система интерпретирует как строку:
std::cout << "pc=" << pc << std::endl;
// Поэтому если мы все-таки хотим вывести на консоль адрес, который хранится в указателе типа char, то это указатель надо преобразовать к другому типу, например, к void* или к int*.

```

## Арифметика указателей
 
Указатели могут участвовать в арифметических операциях (сложение, вычитание, инкремент, декремент). Однако сами операции производятся немного иначе, чем с числами. И многое здесь зависит от типа указателя.

К указателю можно прибавлять целое число, и также можно вычитать из указателя целое число. Кроме того, можно вычитать из одного указателя другой указатель.

Рассмотрим вначале операции инкремента и декремента и для этого возьмем указатель на объект типа int:
```c

#include <iostream>
 
int main()
{
    int n = 10;
      
    int *ptr = &n;
    std::cout << "address=" << ptr << "\tvalue=" << *ptr << std::endl;
      
    ptr++;
    std::cout << "address=" << ptr << "\tvalue=" << *ptr << std::endl;
      
    ptr--;
    std::cout << "address=" << ptr << "\tvalue=" << *ptr << std::endl;
 
    return 0;
}

```
Операция инкремента ++ увеличивает значение на единицу. В случае с указателем увеличение на единицу будет означать увеличение адреса, который хранится в указателе, на размер типа указателя. 

В случае с указателем типа int увеличение/уменьшение на единицу означает изменение адреса на 4 (размер объектов int в большинстве архитектур равен 4 байтам). Поэтому увеличение указателя типа int на единицу означает увеличение значение указателя на 4. А после декремента указатель получил предыдущий адрес в памяти.

Фактически увеличение на единицу означает, что мы хотим перейти к следующему объекту в памяти, который находится за текущим и на который указывает указатель. А уменьшение на единицу означает переход назад к предыдущему объекту в памяти.

После изменения адреса мы можем получить значение, которое находится по новому адресу, однако это значение может быть неопределенным.

Аналогично, для указателя типа short эти операции изменяли бы адрес на 2, а для указателя типа char на 1.
```c
#include <iostream>
 
int main()
{
    double d = 10.6;
    double *pd = &d;
    std::cout << "Pointer pd: address:" << pd << std::endl;
    pd++;
    std::cout << "Pointer pd: address:" << pd << std::endl;
    // увеличение на единицу указателя типа double дало увеличения хранимого в нем адреса на 8 единиц (размер объекта double - 8 байт), 
          
    char c = 'N';
    char *pc = &c;
    std::cout << "Pointer pc: address:" << (void*)pc << std::endl;
    pc++;
    std::cout << "Pointer pc: address:" << (void*)pc << std::endl;
    // увеличение на единицу указателя типа char дало увеличение хранимого в нем адреса на 1 (размер типа char - 1 байт).
    return 0;
}

```
Аналогично указатель будет изменяться при прибавлении/вычитании не единицы, а какого-то другого числа.
```c

#include <iostream>
 
int main()
{
    double d = 10.6;
    double *pd = &d;
    std::cout << "Pointer pd: address:" << pd << std::endl;
 
    // Добавление к указателю типа double числа 2
    pd = pd + 2;
    // означает, что мы хотим перейти на два объекта double вперед, что подразумевает изменение адреса на 2 * 8 = 16 байт.
    std::cout << "Pointer pd: address:" << pd << std::endl;
      
    char c = 'N';
    char *pc = &c;
    std::cout << "Pointer pc: address:" << (void*)pc << std::endl;
    // Вычитание из указателя типа char числа 3
    pc = pc - 3;
    // означает, что мы хотим перейти на три объекта char назад, что подразумевает изменение адреса на 3 * 1 = 3 байта.

    std::cout << "Pointer pc: address:" << (void*)pc << std::endl;
 
    return 0;
}

```
В отличие от сложения операция вычитания может применять не только к указателю и целому числу, но и к двум указателям одного типа:
```c

#include <iostream>
 
int main()
{
    int a = 10;
    int b = 23;
    int *pa = &a;
    int *pb = &b;

    // Результатом разности двух указателей является "расстояние" между ними. 
    int c = pa - pb;
      
    std::cout << "pa: " << pa << std::endl;
    std::cout << "pb: " << pb << std::endl;
    // Так как размер одного объекта int равен 4 байтам, то расстояние между указателями будет равно 1.
    std::cout << "c: " << c << std::endl;
 
    return 0;
}

```
При работе с указателями надо отличать операции с самим указателем и операции со значением по адресу, на который указывает указатель.
```c

int a = 10;
int *pa = &a;
// в данном случае через операцию разыменования *pa получаем значение, на которое указывает указатель pa, то есть число 10, и выполняем операцию сложения. То есть в данном случае обычная операция сложения между двумя числами, так как выражение *pa представляет число.
int b = *pa + 20;   // операция со значением, на который указывает указатель
pa++;               // операция с самим указателем
// Но в то же время есть особенности, в частности, с операциями инкремента и декремента. Дело в том, что операции *, ++ и -- имеют одинаковый приоритет и при размещении рядом выполняются справа налево.     
std::cout << "b: " << b << std::endl;  ;  // 30

```
Например, выполним постфиксный инкремент:
```c
int a = 10;
int *pa = &a;
std::cout << "pa: address=" << pa << "\tvalue=" << *pa << std::endl;
int b = *pa++;      // инкремент адреса указателя
          
std::cout << "b: value=" << b << std::endl;
std::cout << "pa: address=" << pa << "\tvalue=" << *pa << std::endl;

// В выражении b = *pa++; сначала к указателю присваивается единица (то есть к адресу добавляется 4, так как указатель типа int). Затем так как инкремент постфиксный, с помощью операции разыменования возвращается значение, которое было до инкремента - то есть число 10. И это число 10 присваивается переменной b.
```
## Скобки изменяют порядок операций 
```c
// Изменим выражение:
b = (*pa)++;
```
Скобки изменяют порядок операций. Здесь сначала выполняется операция разыменования и получение значения, затем это значение увеличивается на 1. Теперь по адресу в указателе находится число 11. И затем так как инкремент постфиксный, переменная b получает значение, которое было до инкремента, то есть опять число 10. Таким образом, в отличие от предыдущего случая все операции производятся над значением по адресу, который хранит указатель, но не над самим указателем. И, следовательно, изменится результат работы.
```c
// Аналогично будет с префиксным инкрементом:
b = ++*pa;
```
В данном случае сначала с помощью операции разыменования получаем значение по адресу из указателя pa, к этому значению прибавляется единица. То есть теперь значение по адресу, который хранится в указателе, равно 11. Затем результат операции присваивается переменной b
```c
// Изменим выражение:
b = *++pa;
// Теперь сначала изменяет адрес в указателе, затем мы получаем по этому адресу значение и присваиваем его переменной b. Полученное значение в этом случае может быть неопределенным
```
## Указатели на константы
Указатели могут указывать как на переменные, так и на константы. Чтобы определить указатель на константу, он тоже должен объявляться с ключевым словом const:
```c
#include <iostream>
 
int main()
{
    const int a = 10;
    const int *pa = &a;
    std::cout << "address=" << pa << "\tvalue=" << *pa << std::endl;
     
    return 0;
}
```
Здесь указатель pa указывает на константу a. Поэтому даже если мы захотим изменить значение по адресу, который хранится в указателе, мы не сможем это сделать:
```c
*pa = 34;
// В этом случае мы просто получим ошибку во время компиляции.
```
Возможна также ситуация, когда указатель на константу на самом деле указывает на переменную:
```c
#include <iostream>
 
int main()
{
    int a = 10;
    const int *pa = &a;
    std::cout <<"value=" << *pa << std::endl;     // 10
    a = 22;
    std::cout <<"value=" << *pa << std::endl;     // 22
    //*pa = 34;     // так делать нельзя
     
    return 0;
}
```
В этом случае переменную отдельно мы сможем изменять, однако по прежнему изменить ее значение через указатель мы не сможем.

Через указатель на константу мы не можем изменять значение переменной/константы. Но мы можем присвоить указателю адрес любой другой переменной или константы:
```c
const int a = 10;
const int *pa = &a;     // указатель указывает на константу a
const int b = 45;
pa = &b;                // указатель указывает на константу b
std::cout <<"value=" << *pa << std::endl;     // 45
std::cout <<"value=" << a << std::endl;     // 10 - константа a не изменяется

```
## Константный указатель
От указателей на константы надо отличать константные указатели. Они не могут изменять адрес, который в них хранится, но могут изменять значение по этому адресу.
```c
#include <iostream>
 
int main()
{
    int a = 10;
    int *const pa = &a;
    std::cout << "value=" << *pa << std::endl;      // 10
    *pa = 22;                                       // меняем значение
    std::cout << "value=" << *pa << std::endl;      // 22
  
    int b = 45;
    // pa = &b;         так нельзя сделать
     
    return 0;
}

```
## Константный указатель на константу
И объединение обоих предыдущих случаев - константный указатель на константу, который не позволяет менять ни хранимый в нем адрес, ни значение по этому адресу:
```c
int a = 10;
const int *const pa = &a;
 
//*pa = 22;  так сделать нельзя
 
int b = 45;
// pa = &b;  так сделать нельзя 
```
## Указатели и массивы
 
В C++ указатели и массивы тесно связаны. Обычно компилятор преобразует массив в указатели. С помощью указателей можно манипулировать элементами массива, как и с помощью индексов.

Имя массива по сути является адресом его первого элемента. Соответственно через операцию разыменования мы можем получить значение по этому адресу:
```c
int a[] = {1, 2, 3, 4, 5};
std::cout << "a[0] = " << *a << std::endl;    // a[0] = 1
// Прибавляя к адресу первого элемента некоторое число, мы можем получить определенны элемент массив. Например, в цикле пробежимся по всем элементам:

#include <iostream>
 
int main()
{
    const int n = 5;
    int a[n] = {1, 2, 3, 4, 5};
     
    for(int i=0; i < n; i++)
    {
        std::cout << "a[" << i << "]: address=" << a+i << "\tvalue=" << *(a+i) << std::endl;
    }
     
    return 0;
}
// То есть, например, адрес второго элемента будет представлять выражение a+1, а его значение - *(a+1).
```
В отношении сложения и вычитания здесь действуют те же правила, что и в операциях с указателями. Добавление единицы означает прибавление к адресу значения, которое равно размеру типа массива. Так, в данном случае массив представляет тип int, размер которого, как правило, составляет 4 байта, поэтому прибавление единицы к адресу означает увеличение адреса на 4. Прибавляя к адресу 2, мы увеличиваем значение адреса на 4 * 2 = 8. И так далее.

Но при этом имя массива это не стандартный указатель, и мы не можем изменить его адрес, например, так:
```c
int a[5] = {1, 2, 3, 4, 5};
a++;            // так сделать нельзя
int b = 8;
a = &b;         // так тоже сделать нельзя

```
## Указатели на массивы
Имя массива всегда хранит адрес самого первого элемента. И нередко для перемещения по элементам массива используются отдельные указатели:
```c
int a[5] = {1, 2, 3, 4, 5};
int *ptr = a;
int a2 = *(ptr+2);
std::cout <<  "value: " << a2 << std::endl;  // value: 3
```
Здесь указатель ptr изначально указывает на первый элемент массива. Увеличив указатель на 2, мы пропустим 2 элемента в массиве и перейдем к элементу a[2].

## С помощью указателей легко перебрать массив:
```c
int a[5] = {1, 2, 3, 4, 5};
 
for(int *ptr=a; ptr<=&a[4]; ptr++)
{
    std::cout << "address=" << ptr << "\tvalue=" << *ptr << std::endl;
}
```
Так как указатель хранит адрес, то мы можем продолжать цикл, пока адрес в указателе не станет равным адресу последнего элемента.

Аналогичным образом можно перебрать и многомерный массив:
```c
#include <iostream>
 
int main()
{
    int a[3][4] = { {1, 2, 3, 4} , {5, 6, 7, 8}, {9, 10, 11, 12}};
    int n = sizeof(a)/sizeof(a[0]);         // число строк
    int m = sizeof(a[0])/sizeof(a[0][0]);   // число столбцов
      
    int *end = a[0] + n * m - 1;    // указатель на самый последний элемент 0 + 3 * 4 - 1 = 11
    for(int *ptr=a[0], i=1; ptr <= end; ptr++, i++)
    {
        std::cout << *ptr << "\t";
        // если остаток от целочисленного деления равен 0,
        // переходим на новую строку
        if(i%m == 0)
        {
            std::cout << std::endl;
        }
    }
     
    return 0;
}

```
Поскольку в данном случае мы имеем дело с двухмерным массивом, то адресом первого элемента будет выражение a[0]. Соответственно указатель указывает на этот элемент. С каждой итерацией указатель увеличивается на единицу, пока его значение не станет равным адресу последнего элемента, который хранится в указателе end.

Мы также могли бы обойтись и без указателя на последний элемент, проверяя значение счетчика:
```c
#include <iostream>
 
int main()
{
    int a[3][4] = { {1, 2, 3, 4} , {5, 6, 7, 8}, {9, 10, 11, 12}};
    int n = sizeof(a)/sizeof(a[0]);         // число строк
    int m = sizeof(a[0])/sizeof(a[0][0]);   // число столбцов
      
    int *end = a[0] + n * m - 1;    // указатель на самый последний элемент 0 + 3 * 4 - 1 = 11
    for(int *ptr=a[0], i=0; i<m*n;)
    {
        std::cout << *ptr++ << "\t";
        // если остаток от целочисленного деления равен 0,
        // переходим на новую строку
        if(++i%m == 0)
        {
            std::cout << std::endl;
        }
    }
     
    return 0;
}
```
## Указатель на массив символов
Поскольку массив символов может интерпретироваться как строка, то указатель на значения типа char тоже может интерпретироваться как строка:
```c
#include <iostream>
  
int main()
{
    char letters[] = "hello";
    char *p = letters;
    std::cout << p << std::endl;        // hello
    return 0;
}
// Если же необходимо вывести на консоль адрес указателя, то его надо переобразовать к типу void*:
std::cout << (void*)p << std::endl; // 0x60fe8e

```
В остальном работа с указателем на массив символов производится также, как и с указателями на массивы других типов.

## Указатели в параметрах функции
Параметры функции в C++ могут представлять указатели. 
Указатели передаются в функцию по значению, то есть функция получает копию указателя. В то же время копия указателя будет в качестве значения иметь тот же адрес, что оригинальный указатель. Поэтому используя в качестве параметров указатели, мы можем получить доступ к значению аргумента и изменить его.

Например, пусть у нас будет простейшая функция, которая увеличивает число на единицу:
```c
#include <iostream>
 
void increment(int);
 
int main()
{
    int n = 10;
    increment(n);
    std::cout << "main function: " <<  x << std::endl;
    return 0;
}
void increment(int x)
{
    x++;
    std::cout << "increment function: " <<  x << std::endl;
}

```
Здесь переменная n передается в качестве аргумента для параметра x. Передача происходит по значению, поэтому любое изменение параметра x в функции increment никак не скажется на значении переменной n.

Теперь изменим функцию increment, использовав в качестве параметра указатель:
```c
#include <iostream>
 
void increment(int*);
 
int main()
{
    int n = 10;
    increment(&n);
    std::cout << "main function: " <<  n << std::endl;
    return 0;
}
void increment(int *x)
{
    (*x)++;
    std::cout << "increment function: " <<  *x << std::endl;
}
// Для изменения значения параметра применяется операция разыменования с последующим инкрементом: (*x)++. Это изменяет значение, которое находится по адресу, хранимому в указателе x.

```
Поскольку теперь функция в качестве параметра принимает указатель, то при ее вызове необходимо передать адрес переменной: increment(&n);.

В итоге изменение параметра x также повлияет на переменную n

В то же время поскольку аргумент передается в функцию по значению, то есть функция получает копию адреса, то если внутри функции будет изменен адрес указателя, то это не затронет внешний указатель, который передается в качестве аргумента:
```c
#include <iostream>
 
void increment(int*);
 
int main()
{
    int n = 10;
    int *ptr = &n;
    increment(ptr);
    std::cout << "main function: " <<  n << std::endl;
    return 0;
}
void increment(int *x)
{
    int z = 6;
    x = &z;     // переустанавливаем адрес указателя x
    std::cout << "increment function: " <<  *x << std::endl;
}

```
В функцию increment передается указатель ptr. При вызове функция получает копию этого указателя в виде парамета x. В функции изменяется адрес указателя x. Но это никак не затронет указатель ptr, так как он предствляет другую копию. В итоге поле переустановки адреса указатели x и ptr будут хранить разные адреса.

## Массивы в параметрах функции
Если функция принимает в качестве параметра массив, то фактически в эту функцию передается указатель на первый элемент массива. То есть как и в случае с указателями нам доступен адрес, по которому мы можем менять значения. Поэтому следующие объявления функции будут по сути равноценны:
```c

void print(int numbers[]);
void print(int *numbers);

// Передадим в функцию массив:
void print(int[]);
 
int main()
{
    int nums[] = {1, 2, 3, 4, 5};
    print(nums);
    return 0;
}
 
void print(int numbers[])
{
    std::cout << "First number: " <<  numbers[0] << std::endl;
}
// В данном случае функция print выводит на консоль первый элемент массива.

// Теперь определим параметр как указатель:
void print(int*);
 
int main()
{
    int nums[] = {1, 2, 3, 4, 5};
    print(nums);
    return 0;
}
 
void print(int *numbers)
{
    std::cout << "First number: " <<  *numbers << std::endl;
}
// Здесь также в функцию передается массив, однако параметр представляет указатель на первый элемент массива

```
## Ограничения
Поскольку параметр, определенный как массив, рассматривается именно как указатель на первый элемент, то мы не сможем корректно получить длину массива следующим образом:
```c
void print(int numbers[])
{
    int size = sizeof(numbers) / sizeof(numbers[0]);
    std::cout << size << std::endl;
}

```
## Передача маркера конца массива
Чтобы определять конец массив, перебирать элементы массива, необходимо использовать специальный маркер, который бы сигнализировал об окончании массива.

Первый подход заключается в том, чтобы один из элементов массива сам сигнализировал о его окончании. В частности, массив символов может представлять строку - набор символов, который завершается нулевым символом '\0'. Фактически нулевой символ служит признком окончания символьного массива:
```c
#include <iostream>
 
void print(char[]);
 
int main()
{
    char chars[] = "Hello";
 
    print(chars);
    return 0;
}
 
void print(char chars[])
{
    for (int i = 0; chars[i] != '\0'; i++)
    {
        std::cout << chars[i] << "\t";
    }
}

```
Второй подход заключается в передаче в функцию размера массива:
```c
#include <iostream>
 
void print(int[], int);
 
int main()
{
    int nums[] = {1, 2, 3, 4, 5};
    int n = sizeof(nums)/sizeof(nums[0]);
    print(nums, n);
    return 0;
}
 
void print(int numbers[], int n)
{
    for(int i=0; i < n; i++)
    {
        std::cout << numbers[i] << "\t";
    }
}
```
Третий подход заключается в передаче указателя на конец массива. Можно вручную вычислять вычислять указатель на конец массива. А можно использовать встроенные библиотечные функции std::begin() и std::end():
```c
int nums[] = { 1, 2, 3, 4, 5 };
int *begin = std::begin(nums);      // указатель на начало массива
int *end = std::end(nums);      // указатель на конец массива

```
Причем end возвращает указатель не на последний элемент, а адрес за последним элементом в массиве.

```c
#include <iostream>
 
void print(int*, int*);
 
int main()
{
    int nums[] = { 1, 2, 3, 4, 5 };
    int *begin = std::begin(nums);
    int *end = std::end(nums);
 
    print(begin, end);
    return 0;
}
 
void print(int *begin, int *end)
{
    for (int *ptr  = begin; ptr != end; ptr++)
    {
        std::cout << *ptr << "\t";
    }
}

```
## Константные массивы
Поскольку при передаче массива передается фактически указатель на первый элемент, то используя этот указатель, мы можем изменить элемены массива. Если нет необходимости в изменении массива, то лучше параметр-массив определять как константный:
```c
#include <iostream>
 
void print(const int*, const int*);
void twice(int*, int*);
 
int main()
{
    int nums1[] = { 1, 2, 3, 4, 5 };
    int *begin = std::begin(nums1);
    int *end = std::end(nums1);
    print(begin, end);
    std::cout << std::endl;
 
    int nums2[] = { 1, 2, 3, 4, 5 }; 
    begin = std::begin(nums2);
    end = std::end(nums2);
    twice(begin, end);
    for (int *ptr = begin; ptr != end; ptr++)
    {
        std::cout << *ptr << "\t";
    }
    std::cout << std::endl;
    return 0;
}
 
void print(const int *begin, const int *end)
{
    for (const int *ptr  = begin; ptr != end; ptr++)
    {
        std::cout << *ptr << "\t";
    }
}
void twice(int *begin, int *end)
{
    for (int *ptr = begin; ptr != end; ptr++)
    {
        *ptr = *ptr * 2;
    }
}

```
В данном случае функция print просто выводит значения из массива, поэтому параметры этой функции помечаются как константные.

Функция twice изменяет элементы массива - увеличивает их в два раза, поэтому в этой функции параметры являются неконстантными. Причем поле выполнения функции twice массив nums3 будет изменен.

## Передача многомерного массива
Многомерный массив также передается как указатель наего первый элемент. В то же время поскольку элементами многомерного массива являются другие массивы, то указатель на первый элемент многомерного массива фактически будет представлять указатель на массив.

При определении параметра как указателя на массив размер второй размерности (а также всех последующих размерностей) должен быть определен, так как данный размер является частью типа элемента. Пример объявления:
```c
void print(int (*numbers)[3])
```
Здесь предполагается, что передаваемый массив будет двухмерным, и все его подмассивы будут иметь по 3 элемента. Стоит обратить внимание на скобки вокруг имени параметра, которые и позволяют определить параметр как указатель на массив. И от этой ситуации стоит отличать следующую:
```c
void print(int *numbers[3])
```
В данном случае параметр определен как массив указателей, а не как указатель на массив.

## применение указателя на массив:
```c
#include <iostream>
 
void print(int(*)[3], int);
int main()
{
    int table[3][3] = { {1, 2, 3}, {4, 5, 6}, {7, 8, 9} };
    // количество строк или подмассивов
    int rowsCount = sizeof(table) / sizeof(table[0]);
 
    print(table, rowsCount);
    return 0;
}
 
void print(int (*numbers)[3], int rowsCount)
{
    // количество столбцов или элементов в каждом подмассиве
    int columnsCount = sizeof(*numbers)/ sizeof(*numbers[0]);
    for(int i =0; i < rowsCount; i++)
    {
        for (int j = 0; j < columnsCount; j++)
        {
            std::cout << numbers[i][j] << "\t";
        }
        std::cout << std::endl;
    }
}
```
В функции main определяется двухмерных массив - он состоит из трех подмассивов. Каждый подмассив имеет по три элемента.

В функцию print вместе с массивом передается и число строк - по сути число подмассивов. В самой функции print получаем количество элементов в каждом подмассиве и с помощью двух циклов перебираем все элементы. С помощью выражения number[0] можно обратиться к первому подмассиву в двухмерном массиве, а с помощью выражения numbers[0][0] - к первому элементу первого подмассива. И таким образом, манипулируя индексами можно перебрать весь двухмерный массив.

Также мы могли бы определить параметр функци print непосредственно как двухмерный массив, но в этом случае опять же надо было бы указать явным образом вторую размерность:
```c
void print(int numbers[][3], int rowsCount)
{
    // количество столбцов или элементов в каждом подмассиве
    int columnsCount = sizeof(numbers[0])/ sizeof(numbers[0][0]);
    for(int i =0; i < rowsCount; i++)
    {
        for (int j = 0; j < columnsCount; j++)
        {
            std::cout << numbers[i][j] << "\t";
        }
        std::cout << std::endl;
    }
}

```
## Указатели на функции
Указатель на функцию (function pointer) хранит адрес функции. По сути указатель на функцию содержит адрес первого байта в памяти, по которому располагается выполняемый код функции.

Самым распространенным указателем на функцию является ее имя. С помощью имени функции можно вызывать ее и получать результат ее работы.

Указатель на функцию мы можем определять в виде отдельной переменной с помощью следующего синтаксиса:
```c
тип (*имя_указателя) (параметры);
```
- тип представляет тип возвращаемого функцией значения.
- имя_указателя представляет произвольно выбранный идентификатор в соответствии с правилами о наименовании переменных.
- параметры определяют тип и название параметров через запятую при их наличии.

Например, определим указатель на функцию:
```c
void (*message) ();>

```
В данном случае определен указатель, который имеет имя message. Он может указывать на функции без параметров, которые возвращают тип void (то есть ничего не возвращают).

Используем указатель на функцию:
```c
#include <iostream>
 
void hello();
void goodbye();
  
int main()
{
    void (*message)();
      
    message=hello;
    message();
    message = goodbye;
    message();
      
    return 0;
}
void hello()
{
    std::cout << "Hello, World" << std::endl;
}
void goodbye()
{
    std::cout << "Good Bye, World" << std::endl;
}

```
Указателю на функцию можно присвоить функцию, которая соответствует указателю по возвращаемому типу и спецификации параметров:
```c
message=hello;

```
То есть в данном случае указатель message теперь хранит адрес функции hello. И посредством обращения к указателю мы можем вызвать эту функцию:
```c
message();
```
В качестве альтернативы мы можем обращаться к указателю на функцию следующим образом:
```c
(*message)();
```
Впоследствии мы можем присвоит указателю адрес другой функции. 

При определении указателя стоит обратить внимание на скобки вокруг имени. 
Так, использованное выше определение
```c
void (*message) ();
```
НЕ будет аналогично следующему определению:
```c
void *message ();
// определен не указатель на функцию, а прототип функции message, которая возвращает указатель типа void*.
```
Рассмотрим еще один указатель на функцию:
```c
#include <iostream>
 
int add(int, int);
int subtract(int, int);
  
int main()
{
    int a = 10;
    int b = 5;
    int result;
    int (*operation)(int a, int b);
      
    operation=add;
    result = operation(a, b);
    // result = (*operation)(a, b); // альтернативный вариант
    std::cout << "result=" << result << std::endl;     // result=15
      
    operation = subtract;
    result = operation(a, b);
    std::cout << "result=" << result << std::endl;     // result=5
      
    return 0;
}
int add(int x, int y)
{
    return x+y;
}
int subtract(int x, int y)
{
    return x-y;
}

```
Здесь определен указатель operation, который может указывать на функцию с двумя параметрами типа int, возвращающую также значение типа int. Соответственно мы можем присвоить указателю адреса функций add и subtract и вызвать их, передав при вызове указателю некоторые значения для параметров.

## Массивы указателей на функции
Кроме одиночных указателей на функции мы можем определять их массивы. Для этого используется следующий формальный синтаксис:
```c
тип (*имя_массива[размер]) (параметры)
// Например:
double (*actions[]) (int, int)
// Здесь actions представляет массив указателей на функции, каждая из которых обязательно должна принимать два параметра типа int и возвращать значение типа double.
```
Применение массива указателей на функции:
```c
#include <iostream>
 
void add(int, int);
void subtract(int, int);
void multiply(int, int);
 
int main()
{
    int a = 10;
    int b = 5;
    void (*operations[3])(int, int) = {add, subtract, multiply};
      
    // получаем длину массива
    int length = sizeof(operations)/sizeof(operations[0]);
      
    for(int i=0; i < length;i++)
    {
        operations[i](a, b);    // вызов функции по указателю
    }
      
    return 0;
}
void add(int x, int y)
{
    std::cout << "x + y = " << x + y << std::endl;
}
void subtract(int x, int y)
{
    int result = x - y;
    std::cout << "x - y = " << x - y << std::endl;
}
void multiply(int x, int y)
{
    std::cout << "x * y = " << x * y << std::endl;
}
```
Здесь массив operations содержит три функции add, subtract и multiply, которые последовательно вызываются в цикле через перебор массива в функции main.

## Указатели на функции как параметры
Указатель на функцию может передаваться в другую функцию в качестве параметра:
```c

#include <iostream>
 
int add(int, int);
int subtract(int, int);
int operation(int(*)(int, int), int, int);
 
int main()
{
    int a = 10;
    int b = 5;
    int result;
    result = operation(add, a, b);
    std::cout << "result: " << result << std::endl;
 
    result = operation(subtract, a, b);
    std::cout << "result: " << result << std::endl;
    return 0;
}
 
int add(int x, int y)
{
    return x + y;
}
int subtract(int x, int y)
{
    return x - y;
}
// Определению указателя соответствуют две функции: add и subtract, поэтому их адрес можно передать в вызов функции operation: operation(add, a, b).

int operation(int(*op)(int, int), int a, int b)
{
    return op(a, b);
}
// В данном случае первый параметр функции operation - int (*op)(int, int) - представляет указатель на функцию, которая возвращает значение типа int и принимает два параметра типа int. Результатом функции является вызов той функции, на которую указывает указатель.
```
Другой пример - функция, которая может принимать в качестве параметра некоторое условие:
```c
#include <iostream>
 
int isEven(int);
int isPositive(int);
void action(int(*)(int), int[], int);
 
int main()
{
    int nums[] = { -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5 };
    int n = sizeof(nums) / sizeof(nums[0]);
    
    // При вызове функции action() в нее можно передать нужное условие: action(isEven, nums, n);. В итоге программа выведет на экран числа из массива nums, которые соответствуют переданному условию:
 
    std::cout << "Even numbers: " << std::endl;
    action(isEven, nums, n);
 
    std::cout << "Positive numbers: " << std::endl;
    action(isPositive, nums, n);
 
    return 0;
}

// В программе условия представлены двумя функциями. 
// Функция isEven() возвращает 1, если число четное, и 0, если число нечетное. 
int isEven(int x)
{
    return x % 2 == 0;
}

// А функция isPositive() возвращает 1, если число положительное, и 0, если отрицательное.
int isPositive(int x)
{
    return x>0;
}

void action(int(*condition)(int), int numbers[], int n)
{
    for (int i = 0; i<n; i++)
    {
        if (condition(numbers[i]) != 0)
        {
            std::cout << numbers[i] << "\t";
        }
    }
    std::cout << std::endl;
}
// Первый параметр функции action - указатель int (*condition)(int) представляет функцию, которая принимает целое число и в зависимости от того, соответствует оно условию или нет, возвращает 1 (если соответствует) или 0. На момент определения функции action точное условие может быть неизвестно.
```

## Указатель на функцию как возвращаемое значение

Функция может возвращать указатель на другую функцию. Это может быть актуально, если имеется ограниченное количество вариантов - выполняемых функций, и надо выбрать одну из них. Но при этом набор вариантов и выбор из них определяется в промежуточной функции.
```c
#include <iostream>
 
void goodmorning();
void goodevening();
void(*message(int))();
 
int main()
{
    void(*action)();    // указатель на выбранную функцию
    action = message(15);
    action();       // выполняем полученную функцию
    return 0;
}
 
void(*message(int hour))()
{
    if (hour > 12)
        return goodevening;
    else
        return goodmorning;
}
void goodmorning()
{
    std::cout << "Good Morning!" << std::endl;
}
void goodevening()
{
    std::cout << "Good Evening!" << std::endl;
}

```
Здесь определена функция message, которая в зависимости от переданного числа возвращает одну из двух функций goodmorning или goodevening. Рассмотрим объявление функции message:
```c
void(*message(int hour))()
```
Вначале указан тип, который возвращается функцией, которая возвращается из message, то есть тип void (функции goodmorning и goodevening имеют тип void). Далее идет в скобках имя функции со списком параметров, то есть функция message принимает один параметр типа int: (*message(int hour)). После этого отдельно в скобках идет спецификация параметров функции, которая будет возвращаться из message. Поскольку функции goodmorning и goodevening не принимают никаких параметров, то указываются пустые скобки.

Имя функции фактически представляет указатель на нее, поэтому в функции message мы можем возвратить нудную функцию, указав после оператора return ее имя.

Для получения указателя на функцию определяем переменную action:
```c
void(*action)();
```
Эта переменная представляет указатель на функцию, которая не принимает параметров и имеет в качестве возвращаемого типа тип void, то есть она соответствует функциям goodmorning и goodevening.
Затем вызываем функцию message и получаем указатель на функцию в переменную action:
```c
action = message(15);
```
Далее, используя указатель action, вызываем полученную функцию:
```c
action();
```
Поскольку в функцию message передается число 15, то она будет возвращать указатель на функцию goodevening, поэтому при ее вызове на консоль будет выведено сообщение "Good Evening!"


### в зависимости от выбора пользователя выполняется та или иная арифметическая операция над двумя числами:
```c
#include <iostream>
 
int add(int, int);
int subtract(int, int);
int multiply(int, int);
int(*select())(int, int);
 
int main()
{
    int x = 8;
    int y = 5;
    std::cout << "x = " << x << "\ty = " << y << std::endl;
    std::cout << "1: Add" << std::endl;
    std::cout << "2: Subtract" << std::endl;
    std::cout << "3: Multiply" << std::endl;
    std::cout << "4: Exit" << std::endl;
 
    int(*action)(int, int);    // указатель на выбранную функцию
    int result;       // результат функции
    while (1)
    {
        action = select();  // получаем указатель на функцию
        if (action == NULL)
            break;
        result = action(x, y); // выполняем функцию
        std::cout << "Result: " << result << std::endl;
    }
    std::cout << "The End" << std::endl;
 
    return 0;
}
 
int(*select())(int, int)
{
    int choice; // выбранный пункт
    // массив указателей на функции, которые будут возвращаться
    int (*actions[])(int x, int y) = { add, subtract, multiply };
    // выбираем действие по номеру
    std::cout << "Enter action (1, 2, 3, 4): ";
    std::cin >> choice;
    // возвращаем нужную функцию
    if (choice >0 && choice<4)
        return actions[choice - 1];
    else
        return NULL;
}
int add(int x, int y)
{
    return x + y;
}
int subtract(int x, int y)
{
    return x - y;
}
int multiply(int x, int y)
{
    return x * y;
}
```
В данной программе мы предполагаем, что пользователь должен выбрать для выполнения одну из трех функций: add, subtract, multiply. И выбранная функция будет выполнять определенное действие над двумя числами x и y.
Сам выбор происходит в функции select(). Она возвращает указатель на функцию - по сути выбранную функцию.

Все выбираемые функции имеют прототип вида:
```c
int add(int, int);
```
И прототип функции select должна соответствовать этому прототипу:
```c
int (*select())(int, int)
```
То есть в начале идет тип - возвращаемый тип указателя на функцию, то есть int. Затем идет определение самой функции select - ее название со списком параметров помещается в скобках - (*select()). Затем идет спецификация параметров функции, на которую определяется указатель. Так как функции add, subtract и multiply принимают два значения типа int, то соответственно спецификация параметров выглядит следующим образом (int, int).

Для хранения всех действий в функции select определен массив указателей на функции actions:
```c
int (*actions[])(int x, int y) = { add, subtract, multiply };
```
С помощью введенного с клавиатуры числа определяем номер нужного действия, которое надо выполнить. Если номер меньше 1 или больше 3, то возвращается константа NULL.

В главной функции main() в бесконечном цикле вызываем функцию select, получая в качестве результата указатель на функцию:
```c
action = select();
```
И если указатель не равен NULL, то после этого мы сможем вызвать функцию по указателю. Поскольку функция по указателю должна принимать два значения типа int, то мы их можем передать в вызываемую функцию и получить ее результат:
```c
result = action(x,y);
```
## Ссылочный тип
Ссылка — это тип переменной в языке C++, который работает как псевдоним другого объекта или значения. Язык C++ поддерживает 3 типа ссылок:
- Ссылки на неконстантные значения (обычно их называют просто «ссылки» или «неконстантные ссылки»).
- Ссылки на константные значения (обычно их называют «константные ссылки»).
- В C++11 добавлены ссылки r-value.

Ссылочный тип, иногда называемый псевдонимом, служит для задания объекту дополнительного имени. Ссылка позволяет косвенно манипулировать объектом, точно так же, как это делается с помощью указателя. Однако эта косвенная манипуляция не требует специального синтаксиса, необходимого для указателей. Обычно ссылки употребляются как формальные параметры функций. 

Ссылка (на неконстантное значение) объявляется с использованием амперсанда (&) между типом данных и именем ссылки:
```c
int value = 7; // обычная переменная
int &ref = value; // ссылка на переменную value
int &ref = value; // корректная ссылка: инициализирована переменной value
int &invalidRef; // некорректная ссылка: ссылка должна ссылаться на что-либо
```
В этом контексте амперсанд не означает «оператор адреса», он означает «ссылка на».

## Ссылки в качестве псевдонимов
Ссылки обычно ведут себя идентично значениям, на которые они ссылаются. В этом смысле ссылка работает как псевдоним объекта, на который она ссылается:
```c
#include <iostream>
 
int main()
{
    int value = 7; // обычная переменная
    int &ref = value; // ссылка на переменную value
 
    value = 8; // value теперь 8
    ref = 9; // value теперь 9
 
    std::cout << value << std::endl; // выведется 9
    ++ref;
    std::cout << value << std::endl; // выведется 10
 
    return 0;
}
```
## Инициализация ссылок
Ссылки должны быть инициализированы при создании:
```c
int value = 7;
```
В отличие от указателей, которые могут содержать нулевое значение, ссылки нулевыми быть не могут.
```c
int ival = 1024;
// правильно: refVal - ссылка на ival
int &refVal = ival;
// ошибка: ссылка должна быть инициализирована
int &refVal2;
```
Ссылка должна быть инициализирована не адресом объекта, а его значением. Таким объектом может быть и указатель:
```c
int ival = 1024;

// ошибка: refVal имеет тип int, а не int*
int &refVal = &ival;
int *pi = &ival;
// правильно: ptrVal - ссылка на указатель
int *&ptrVal2 = pi;
```
Ссылки на неконстантные значения могут быть инициализированы только неконстантными l-values. Они не могут быть инициализированы константными l-values или r-values:
```c
int a = 7;
int &ref1 = a; // ок: a - это неконстантное l-value
 
const int b = 8;
int &ref2 = b; // не ок: b - это константное l-value
 
int &ref3 = 4; // не ок: 4 - это r-value
```
Обратите внимание, во втором случае вы не можете инициализировать неконстантную ссылку константным объектом. В противном случае, вы бы могли изменить значение константного объекта через ссылку, что уже является нарушением понятия «константа».

После инициализации изменить объект, на который указывает ссылка — нельзя:
```c
int value1 = 7;
int value2 = 8;
 
int &ref = value1; // ок: ref - теперь псевдоним для value1
ref = value2; // присваиваем 8 (значение переменной value2) переменной value1. Здесь НЕ изменяется объект, на который ссылается ссылка!
```
Вместо переприсваивания ref (ссылаться на переменную value2), значение из value2 присваивается переменной value1 (на которое и ссылается ref).

Определив ссылку, вы уже не сможете изменить ее так, чтобы работать с другим объектом (именно поэтому ссылка должна быть инициализирована в месте своего определения). В следующем примере оператор присваивания не меняет значения refVal, новое значение присваивается переменной ival – ту, которую адресует refVal.
```c
int min_val = 0;
// ival получает значение min_val,
// а не refVal меняет значение на min_val
refVal = min_val;

```
Все операции со ссылками реально воздействуют на адресуемые ими объекты. В том числе и операция взятия адреса:
```c
refVal += 2; // прибавляет 2 к ival – переменной, на которую ссылается refVal.
int ii = refVal; // присваивает ii текущее значение,
int *pi = &refVal; // инициализирует pi адресом.
```
 
Если мы определяем ссылки в одной инструкции через запятую, перед каждым объектом типа ссылки должен стоять амперсанд (&) – оператор взятия адреса (точно так же, как и для указателей):
```c
// определено два объекта типа int
int ival = 1024, ival2 = 2048;

// определена одна ссылка и один объект
int &rval = ival, rval2 = ival2;

// определен один объект, один указатель и одна ссылка
int inal3 = 1024, *pi = ival3, &ri = ival3;

// определены две ссылки
int &rval3 = ival3, &rval4 = ival2;

```
## Константная ссылка 
Константная ссылка может быть инициализирована объектом другого типа (если существует возможность преобразования одного типа в другой), а также безадресной величиной – такой, как литеральная константа:
```c
double dval = 3.14159;

// верно только для константных ссылок
const int &ir = 1024;
const int &ir2 = dval;
const double &dr = dval + 1.0;

```
Что касается объектов другого типа, то компилятор преобразует исходный объект в некоторый вспомогательный. Например, если мы пишем:
```c
double dval = 1024;
const int &ri = dval;
// то компилятор преобразует это примерно так:
int temp = dval;
const int &ri = temp;
```
Если бы мы могли присвоить новое значение ссылке ri, мы бы реально изменили не dval, а temp. Значение dval осталось бы тем же, что совершенно неочевидно. Поэтому компилятор запрещает такие действия, и единственная возможность проинициализировать ссылку объектом другого типа – объявить ее как const.

Мы хотим определить ссылку на адрес константного объекта, но наш первый вариант вызывает ошибку компиляции:
```c
const int ival = 1024;
// ошибка: нужна константная ссылка
int *&pi_ref = &ival;
 
// Попытка исправить дело добавлением спецификатора const тоже не проходит:
 
const int ival = 1024;
// все равно ошибка
const int *&pi_ref = &ival;
```
pi_ref является ссылкой на константный указатель на объект типа int. А нам нужен неконстантный указатель на константный объект, поэтому правильной будет следующая запись:
```c

const int ival = 1024;
// правильно
int *const &piref = &ival;

```
## Между ссылкой и указателем существуют два основных отличия. 
Во-первых, ссылка обязательно должна быть инициализирована в месте своего определения. 
Во-вторых, всякое изменение ссылки преобразует не ее, а тот объект, на который она ссылается. 

Если мы пишем:
```c
int *pi = 0;
// мы инициализируем указатель pi нулевым значением, а это значит, что pi не указывает ни на какой объект. 
// В то же время запись
const int &ri = 0;
// означает примерно следующее:
int temp = 0;
const int &ri = temp;

// Что касается операции присваивания, то в следующем примере:

int ival = 1024, ival2 = 2048;
int *pi = &ival, *pi2 = &ival2;
pi = pi2;
// переменная ival, на которую указывает pi, остается неизменной, а pi получает значение адреса переменной ival2. И pi, и pi2 и теперь указывают на один и тот же объект ival2.

// Если же мы работаем со ссылками:
 int &ri = ival, &ri2 = ival2;
 ri = ri2;
 // то само значение ival меняется, но ссылка ri по-прежнему адресует ival.

```
В реальных С++ программах ссылки редко используются как самостоятельные объекты, обычно они употребляются в качестве формальных параметров функций:
```c
// пример использования ссылок
// Значение возвращается в параметре next_value
bool get_next_value( int &next_value );

// перегруженный оператор
Matrix operator+( const Matrix&, const Matrix& );

// Как соотносятся самостоятельные объекты-ссылки и ссылки-параметры? Если мы пишем:
int ival;
while (get_next_value( ival )) ...

// это равносильно следующему определению ссылки внутри функции:
int &next_value = ival;
``` 
## Ссылки в качестве параметров в функциях
Ссылки чаще всего используются в качестве параметров в функциях. В этом контексте ссылка-параметр работает как псевдоним аргумента, а сам аргумент не копируется при передаче в параметр. Это в свою очередь улучшает производительность, если аргумент слишком большой или затратный для копирования.

передача аргумента-указателя в функцию позволяет функции при разыменовании этого указателя напрямую изменять значение аргумента.

Ссылки работают аналогично. Поскольку ссылка-параметр — это псевдоним аргумента, то функция, использующая ссылку-параметр, может изменять аргумент, переданный ей, также напрямую:
```c
#include <iostream>
 
// ref - это ссылка на переданный аргумент, а не копия аргумента
void changeN(int &ref)
{
	ref = 8;
}
 
int main()
{
	int x = 7;
 
	std::cout << x << '\n';
 
	changeN(x); // обратите внимание, этот аргумент не обязательно должен быть ссылкой
 
	std::cout << x << '\n';
	return 0;
}
```
Когда аргумент x передается в функцию, то параметр функции ref становится ссылкой на аргумент x. Это позволяет функции изменять значение x непосредственно через ref! Обратите внимание, переменная x не обязательно должна быть ссылкой.

Передавайте аргументы в функцию через неконстантные ссылки-параметры, если они должны быть изменены функцией в дальнейшем.

Основным недостатком использования неконстантных ссылок в качестве параметров в функциях является то, что аргумент должен быть неконстантным l-value (т.е. константой или литералом он быть не может). 

## Ссылки как более легкий способ доступа к данным
Второе (гораздо менее используемое) применение ссылок заключается в более легком способе доступа к вложенным данным. Рассмотрим следующую структуру:
```c
struct Something
{
    int value1;
    float value2;
};
 
struct Other
{
    Something something;
    int otherValue;
};

Other other;
```

Предположим, что нам нужно работать с полем value1 структуры Something переменной other структуры Other. Обычно, доступ к этому полю осуществлялся бы через other.something.value1.

если нам нужно неоднократно получать доступ к этому члену, ссылки предоставляют более легкий способ доступа к данным:
```c
int &ref = other.something.value1;
// ref теперь может использоваться вместо other.something.value1
// Таким образом, следующие два стейтмента идентичны:
other.something.value1 = 7;
ref = 7;

```
## Ссылки позволяют сделать ваш код более чистым и понятным.
Ссылка — это тот же указатель, который неявно разыменовывается при доступе к значению, на которое он указывает (ссылки реализованы с помощью указателей). Таким образом, в следующем коде:
```c
int value = 7;
int *const ptr = &value;
int &ref = value;
*ptr и ref обрабатываются одинаково. Т.е. это одно и то же:

*ptr = 7;
ref = 7;
```
Поскольку ссылки должны быть инициализированы корректными объектами (они не могут быть нулевыми) и не могут быть изменены позже, то они, как правило, безопаснее указателей (так как риск разыменования нулевого указателя отпадает). Однако они немного ограничены в функциональности по сравнению с указателями.

Если определенное задание может быть решено с помощью как ссылок, так и указателей, то лучше использовать ссылки. Указатели следует использовать только в тех ситуациях, когда ссылки являются недостаточно эффективными (например, при динамическом выделении памяти).

## Ссылки на указатели
Так как ссылка не является объектом, то нельзя определить указатель на ссылку, однако можно определить ссылку на указатель. Через подобную ссылку можно изменять значение, на которое указывает указатель или изменять адрес самого указателя:
```c
#include <iostream>
 
int main()
{
    int a = 10;
    int b = 6;
     
    int *p = 0;     // указатель
    int *&pRef = p;     // ссылка на указатель
    pRef = &a;          // через ссылку указателю p присваивается адрес переменной a
    std::cout << "p value=" << *p << std::endl;   // 10
    *pRef = 70;         // изменяем значение по адресу, на который указывает указатель
    std::cout << "a value=" << a << std::endl;    // 70
     
    pRef = &b;          // изменяем адрес, на который указывает указатель
    std::cout << "p value=" << *p << std::endl;   // 6
     
    return 0;
}
```
## Динамические объекты

В C++ можно использовать различные типы объектов, которые различаются по использованию памяти. Так, глобальные объекты создаются при запуске программы и освобождаются при ее завершении. Локальные автоматические объекты создаются в блоке кода и удаляются, когда этот блок кода завершает работу. Локальные статические объекты создаются перед их первым использованием и освобождаются при завершении программы.

Глобальные, а также статические локальные объекты помещаются в статической памяти, а локальные автоматические объекты размещаются в стеке. Объекты в статической памяти и стеке создаются и удаляются компилятором. Статическая память очищается при завершении программы, а объекты из стека существуют, пока выполняется блок, в котором они определены.

В дополнение к этим типам в C++ можно создавать динамические объекты. Продолжительность их жизни не зависит от того, где они созданы. Динамические объекты существуют, пока не будут удалены явным образом. Динамические объекты размещаются в динамической памяти (free store).

Для управления динамическими объектами применяются операторы new и delete.

- Оператор new выделяет место в динамической памяти для объекта и возвращает указатель на этот объект.
- Оператор delete получает указатель на динамический объект и удаляет его из памяти.

## Выделение памяти
Создание динамического объекта:
```c
int *ptr = new int;
```
Оператор new создает новый объект типа int в динамической памяти и возвращает указатель на него. Значение такого объекта неопределено.

Также можно инициализировать объект при создании:
```c
int *p1 = new int();    // значение по умолчанию - 0
std::cout << "p1: " << *p1 << std::endl;  // 0
 
int *p2 = new int(12);
std::cout << "p2: " << *p2 << std::endl;   // 12

```
## Освобождение памяти
Динамические объекты будут существовать пока не будут явным образом удалены. И после завершения использования динамических объектов следует освободить их память с помощью оператора delete:
```c

int *p1 = new int(12);
std::cout << "p1: " << *p1 << std::endl;  // 0
delete p1;

```
Особенно это надо учитывать, если динамический объект создается в одной части кода, а используется в другой:
```c
#include <iostream>
 
int* createPtr(int value)
{
    int *ptr = new int(value);
    return ptr;
}
void usePtr()
{
    int *p1 = createPtr(10);
    std::cout << *p1 << std::endl;  // 10
    delete p1;  // объект надо освободить
}
int main()
{
    usePtr();
 
    return 0;
}
```
В функции usePtr получаем из функции createPtr указатель на динамический объект. Однако после выполнения функции usePtr этот объект автоматически не удаляется из памяти (как это происходит в случае с локальными автоматическими объектами). Поэтому его надо явным образом удалить, использовав оператор delete.

Использование объекта по указателю после его удаления или повторное применение оператора delete к указателю могут привести к непредсказуемым результатам:
```c

int *p1 = new int(12);
std::cout << *p1 << std::endl;  // 0
delete p1;
 
// ошибочные сценарии
std::cout << *p1 << std::endl;  // объект по указателю p1 уже удален!
delete p1;  // объект по указателю p1 уже удален!

```
Поэтому следует удалять объект только один раз.

Также нередко имеет место ситуация, когда на один и тот же динамический объект указывают сразу несколько указателей. Если оператор delete применен к одному из указателей, то память объекта освобождается, и по второму указателю этот объект мы использовать уже не сможем. Если же после этого ко второму указателю применить оператор delete, то динамическая память может быть нарушена.

В то же время недопустимость указателей после применения к ним оператора delete не означает, что эти указатели мы в принципе не сможем использовать. Мы сможем их использовать, если присвоим им адрес другого объекта:
```c
#include <iostream>
 
int main()
{
    int *p1 = new int(12);
    int *p2 = p1;
    delete p1;      // адреса в p1 и p2 недопустимы
 
    p1 = new int(11);   // p1 указывает на новый объект
    std::cout << *p1 << std::endl;  // 11
    delete p1;
 
    return 0;
}

```
Здесь после удаления объекта, на который указывает p1, этому указателю передается адрес другого объекта в динамической памяти. Соответственно мы также можем использовать указатель p1. В то же время адрес в указателе p2 по прежнему будет недействительным.

## Динамические массивы
Кроме отдельных динамических объектов в языке C++ мы можем использовать динамические массивы. Для выделения памяти под динамический массив также используется оператор new, после которого в квадратных скобках указывается, сколько массив будет содержать объектов:
```c
int *numbers = new int[4]; // динамический массив из 4 чисел
```
Причем в этом случае оператор new также возвращает указатель на объект типа int - первый элемент в созданном массиве.
В данном случае определяется массив из четырех элементов типа int, но каждый из них имеет неопределенное значение. Однако мы также можем инициализировать массив значениями:
```c

int *n1 = new int[4];   // каждый элемент имеет неопределенное значение
int *n2 = new int[4](); // каждый элемент имеет значение по умолчанию - 0
int *n3 = new int[4]{ 1, 2, 3, 4 }; // массив состоит из чисел 1, 2, 3, 4

```
В последнем случае при инициализации массива конкретными значениями следует учитывать, что если значений в фигурных скобках больше чем длина массива, то оператор new потерпит неудачу и не сможет создать массив. Если переданных значений, наоборот, меньше, то элементы, для которых не предоставлены значения, иницилизируются значением по умолчанию.

После создания динамического массива мы сможем с ним работать по полученному указателю, получать и изменять его элементы:
```c

int n = 5;  // размер массива
int *p = new int[n]{ 1, 2, 3, 4, 5 };
for (int *q = p; q != p + n; q++)
{
    std::cout << *q << "\t";
}

```
Для удаления динамического массива и освобождения его памяти применяется специальная форма оператора delete: delete [] указатель_на_динамический_массив;

Например:
```c
#include <iostream>
 
int main()
{
    int n = 5;  // размер массива
    int *p = new int[n]{ 1, 2, 3, 4, 5 }; // массив состоит из чисел 1, 2, 3, 4
    for (int *q = p; q != p + n; q++)
    {
        std::cout << *q << "\t";
    }
 
    std::cout << std::endl;
 
    delete [] p;
 
    return 0;
}
```

## Упражнения

1. Даны определения переменных:
```c
int ival = 1024, ival2 = 2048;
int *pi1 = &ival, *pi2 = &ival2, **pi3 = 0;
// Что происходит при выполнении нижеследующих операций присваивания? Допущены ли в данных примерах ошибки?
(a) ival = *pi3; (e) pi1 = *pi3;
(b) *pi2 = *pi3; (f) ival = *pi1;
(c) ival = pi2; (g) pi1 = ival;
(d) pi2 = *pi1; (h) pi3 = &pi2;

```

2. Работа с указателями – один из важнейших аспектов С и С++, однако в ней легко допустить ошибку. Например, код
```c

pi = &ival;
pi = pi + 1024;

```
почти наверняка приведет к тому, что pi будет указывать на случайную область памяти. Что делает этот оператор присваивания и в каком случае он не приведет к ошибке?


3. Данная программа содержит ошибку, связанную с неправильным использованием указателей:
```c

int foobar(int *pi) {
   *pi = 1024;
   return *pi;
}

int main() {
   int *pi2 = 0;
  int ival = foobar(pi2);
  return 0;
}

```
В чем состоит ошибка? Как можно ее исправить?

4. Ошибки из предыдущих двух упражнений проявляются и приводят к фатальным последствиям из-за отсутствия в С++ проверки правильности значений указателей во время работы программы. Как вы думаете, почему такая проверка не была реализована? Можете ли вы предложить некоторые общие рекомендации для того, чтобы работа с указателями была более безопасной?


5. Есть ли ошибки в данных определениях? Поясните. Как бы вы их исправили?
```c

(a) int ival = 1.01; (b) int &rval1 = 1.01;
(c) int &rval2 = ival; (d) int &rval3 = &ival;
(e) int *pi = &ival; (f) int &rval4 = pi;
(g) int &rval5 = pi*; (h) int &*prval1 = pi;
(i) const int &ival2 = 1; (j) const int &*prval2 = &ival;

```

6. Если ли среди нижеследующих операций присваивания ошибочные (используются определения из предыдущего упражнения)?
```c
(a) rval1 = 3.14159;
(b) prval1 = prval2;
(c) prval2 = rval1;
(d) *prval2 = ival2;

```

7. Найдите ошибки в приведенных инструкциях:
```c

(a) int ival = 0;
    const int *pi = 0;
    const int &ri = 0;

(b) pi = &ival;
    ri = &ival;
    pi = &rval;

```